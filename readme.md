# M1 - Управление Приложением (master)
---
## Оглавление

  - [Ссылки](#link1)
  - [Введение](#link2)
  - [Общее описание работы пакета](#link3)
	- [Функционал](#link4)
	- [Схемы взаимодействий с другими пакетами](#link5)
	- [Установка, обновление, удаление](#link6)
  - [Заметки к релизам](#link100)

---

## Ссылки <a id="link1"></a>
```

  > Адрес репозитория пакета М1 на github
      https://github.com/4gekkman/M1

	
			
```

## Введение <a id="link2"></a>
```

  • Это М-пакет для управления приложением.
  • В нём сосредоточен весь соответствующий функционал.
  • Он является корневым для всего приложения.
  • Без него приложение не будет функционировать корректно.
  • Но это не значит, что остальные М-пакеты зависят от этого.
  • Они могут с успехом работать и без него.
  • Однако, это будет в 100 раз менее удобно, чем с этим М-пакетом.

 
```
## Общее описание работы пакета <a id="link3"></a>
```
---------------------------------------
Подоглавление:

  - Что умеет делать пакет

    • Парсить приложение (C1_parseapp)
    • Синхронизировать регистрации сервис-провайдеров пакетов приложения (C2_sp_regs_update)
    • Публиковать ресурсы зарегистрированных пакетов приложения (C3_allrespublish)
    • Устанавливать / Обновлять базы данных M-пакетов приложения (C4_m_dbs_update)
    • Создавать новый релиз указанного пакета на github (C32_release)
    • Обновлять конфиги M,D,L,W-пакетов (C33_mdlw_cfgs_update)
    • Синхронизировать задания пакетов приложения для планировщика (C35_m_schedules_update)
    • Синхронизировать модели указанного пакета с его БД (C36_workbench_sync)
    • Осуществлять очистку pivot-таблиц оборванных межпакетных взаимодействий (C38_clear_interpack_rels)
    • Создавать и удалять все типы пакетов и их ресурсов

  - Межпакетные связи между базами данных M-пакетов

    • Введение в проблемы
    • Решение всех проблем
    • Кейсы

  - Подробнее о работе с конфигами пакетов

    • Конфиги публикуются для M,D,L,W-пакетов
    • Как публикуются конфиги
    • Как обновляются конфиги
    • Примеры работы с конфигами

  - Локализация пакетов

    • Общая информация о локализации пакетов
    • Глобальная локализация
    • Локальная локализация
    • Локализация в M,D,L,W-пакетах
      ▪ Основная информация
      ▪ Как пользоваться
    • Как получить локаль в клиенте

  - Подробнее о работе с базами данных M-пакетов

    • Суть работы с БД M-пакетов
    • Когда происходит обновление БД M-пакета
    • Ведение истории обновление БД M-пакета в конфиге

  - События Event и Broadcast

    • Общая информация об архитектуре событий приложения
    • Событие Event
    • Событие Broadcast

  - Пространства имён пакетов

    • Общая информация о пространствах имён пакетов
    • Пространство имён указывается в composer.json пакета
    • Пространство имён для разрабатываемых пакетов

  - Какие типы пакетов бывают у вендора 4gekkman

    • M-пакет
    • D-пакет
    • L-пакет
    • W-пакет
    • R-пакет

  - Возможные взаимные схемы зависимостей для пакетов разных типов
  - Система управления фронтендом им. 4gekkman'а для laravel-приложения

---------------------------------------

# Что умеет делать пакет

  • Парсить приложение (C1_parseapp)
    - Команда парсит все пакеты приложения, их типы, ресурсы.
    - Как бы делает слепок текущего состояния приложения.
    - И сохраняет все эти результаты в базу данных пакета M1.

  • Синхронизировать регистрации сервис-провайдеров пакетов приложения (C2_sp_regs_update)
    - Обычно при установке пакетов надо добавлять их сервис-провайдеры в конфиг app.php.
    - При установке/удалении пакетов приложения, эта команда делает всё за тебя.
    - Это относится не ко всем пакетам, а лишь к пакетам вендора 4gekkman.

  • Публиковать ресурсы зарегистрированных пакетов приложения (C3_allrespublish)
    - У пакетов приложения есть различные ресурсы, которые требуется опубликовать.
    - Эта команда публикует все подобные ресурсы разом.

  • Устанавливать / Обновлять базы данных M-пакетов приложения (C4_m_dbs_update)
    - Большинство M-пакетов имеют свои базы данных.
    - При установке пакетов эти базы данных требуется устанавливать.
    - А при обновлении пакетов эти БД может потребоваться обновлять.
    - Всё это делает за тебя данная команда.
    - Это относится не ко всем пакетам, а лишь к пакетам вендора 4gekkman.

  • Создавать новый релиз указанного пакета на github (C32_release)
    - Эта команда позволяет создать новый релиз пакета на github.
    - Однако, она не закачивает туда свежую версию пакета.

  • Обновлять конфиги M,D,L,W-пакетов (C33_mdlw_cfgs_update)
    - Все пакеты имеют свои конфиги в configs.
    - Эти конфиги обычно не изменяются при обновлениях пакетов.
    - Однако, их всё же иногда при обновлениях требуется обновлять.
    - Эта команда автоматически это делает.
    - Это относится не ко всем пакетам, а лишь к пакетам вендора 4gekkman.

  • Синхронизировать задания пакетов приложения для планировщика (C35_m_schedules_update)
    - Laravel не позволяет определять задания для планировщиков в сервис-провайдерах пакетов.
    - Однако, с помощью данной команды, ты можешь это делать.
    - Она автоматически выполняет всю необходимую работу.

  • Синхронизировать модели указанного пакета с его БД (C36_workbench_sync)
    - Эта команда позволяет за секунды создать все необходимые модели для M-пакета.
    - Она парсит существующую структуру БД указанного M-пакета.
    - И на её основе создаёт необходимые модели.

  • Осуществлять очистку pivot-таблиц оборванных межпакетных взаимодействий (C38_clear_interpack_rels)
    - БД M-пакетов могут быть объединены межпакетными m:n связями.
    - В соответствующей pivot-таблице накапливаются данные.
    - В случае обрыва связи эти данные становятся не валидными.
    - Данная команда автоматически очищает pivot-таблицу в этом случае.

  • Создавать и удалять все типы пакетов и их ресурсов
    - Это CLI-приложение по управлению ресурсами приложения.
    - Оно позволяет через CLI-интерфейс создавать/удалять пакеты и их ресурсы.

# Межпакетные связи между базами данных M-пакетов

  • Введение в проблемы

    1) Хранение межпакетных данных
      - В M4 есть таблица MD1_routes.
      - В M1 есть таблица MD2_packages.
      - Приложению нужны связи между роутами и пакетами.
      - Оно хочет знать для каждого пакета, с какими роутами он связан.
      - Оно хочет знать для каждого роута, с какими пакетами он связан.
      - Для этой связи требуется наличие pivot-таблицы.
      - Но где её хранить?

    2) Обеспечение наличия связей в моделях
      - M1 и M4 полностью независимы друг от друга.
      - И могут как присутствовать в системе, так и отсутствовать.
      - Если оба присутствуют, связи в соотв.моделях должны быть.
      - Если оба отсутствуют, связей с воотв.моделях быть не должно.

    3) Безопасный запрос данных из БД другой модели
      - M4 может потребоваться запросить из M1 данные.
      - Это можно сделать через событие, но это не удобно.
      - При прямом запросе, если M4 не будет в системе, будет error.

    4) Очистка pivot-таблицы в зависимом M-пакета
      - Сначала M1 и M4 могут присутствовать в системе.
      - В pivot-таблице их связи в M4 могут накапливаться данные.
      - Потом M4 может быть удалена вместе с БД.
      - А потом M4 может быть установлена заново, вместе с БД.
      - На этом этапе, данные в pivot в M4 уже являются неверными.
      - Их следует удалить.

  • Решение всех проблем

    1) Хранение межпакетных данных
      - Эти данные хранятся в базе зависящего M-пакета.
      - То есть того, кому нужны данные от связанного M-пакета.
      - Они хранятся в pivot-таблице с именем "/^md200[0-9]{1}$/"
      - В этом M-пакете, связанная таблица должна быть связана
        с этой pivot-таблицей как обычно, 1:n связью
      - Pivot-таблица должна находиться на жёлтой плашке "Foreign".
      - На плашке также должен присутствовать текстовый комментарий.
      - В description таблицы должна быть json-строка с информацией:

          {
            "mpackid":"M1",           // С каким M-пакетом связь
            "table":"MD2_packages",   // С какой таблицей в этом M-пакете связь
            "version":">=1.0"          // Требуемая версия М-пакета
          }

      - Эта инфа будет использована для авто-создания связей в моделях.
      - Доступ к этим данным можно осуществлять с помощью такого запроса:

          DB::select("SELECT table_comment FROM INFORMATION_SCHEMA.TABLES WHERE table_schema='m4' AND table_name='md2000'");

    2) Обеспечение наличия связей в моделях
      - При каждом afterupdate производится обновление моделей и связей.
      - За это отвечает специальная команда C36_workbench_sync.
      - Она вставляет межпакетные связи в обе связанные модели
        лишь в том случае, если оба пакета/базы, модели/таблицы в наличии.
      - Перед использованием, всегда надо проверять наличие
        метода-связи в классе-модели.

          method_exists("\M4\Models\MD1_routes", "m1_packages")

      - Межпакетная связь имеет префикс в виде id_inner того
        M-пакета, с которым связь. Например: "m1_packages".

    3) Безопасный запрос данных из БД другой модели

      • Безопасный запрос через r1_query
        - Осуществляется через хелпер r1_query.
        - Он принимает callback с запросом.
        - Применяет его через try .. catch.
        - С случае успеха возвращает коллекцию.
        - В случае неудачи возвращает NULL.
        - Пример:

            $packages = r1_query(function(){
              return \M1\Models\MD2_packages::whereHas('packtypes', function($query){
                $query->whereIn('name', ["D", "L", "W"]);
              })->get();
            });

      • Проверка наличия связи через r1_rel_exists
        - Проверить наличие связи можно хелпером r1_rel_exists.
        - Первый аргумент: название M-пакета, связь в котором надо проверить.
        - Второй аргумент: название таблицы в БД, связь для которой надо проверить.
        - Третий аргумент: название связи, существование которой надо проверить.
        - Пример:

            if(r1_rel_exists("M5", "MD3_privileges", "m1_packages")) {
              $privilege->m1_packages()->attach($package->id);
            }

    4) Очистка pivot-таблицы в зависимом M-пакете
      - Осуществляется отдельной командой C38_clear_interpack_rels.
      - Эта команда выполняется при каждом afterupdate.
      - Ищет md200* в существующих M-пакетах.
      - Проверяет присутствие M-пакетов/БД и моделей/таблиц,
        с которыми md200* должны быть связаны.
      - В случае отсутствия, делает truncate для этой md200*.

  • Кейсы

    1) Межпакетная связь между M4 и M1

      Описание
      --------
        - Роуты должны быть связаны с D,L,W-пакетами.
        - Иначе им не узнать адреса контроллеров, куда
          направлять соответствующие запросы.
        - Поэтому, в модели M4 создаётся новая foreign-связь.
        - Создаётся таблица md2000, с полями id_route и id_package.
        - Её связывают 1:n связью с таблицей роутов.
        - В её description прописывают метаданные для автосоздания связей.

      Связанные модели
      ----------------
        \M1\Models\MD2_packages
        \M4\Models\MD1_routes

      Использование r1_routes
      -----------------------
        - При создании роута пользователю надо дать выбор.
        - С каким D,L,W-пакетом требуется связать этот роут.
        - Для этого, надо запросить список id_inner всех их.
        - Это необходимо делать с помощью r1_routes.
        - Если r1_routes вернёт NULL, сообщить пользователю,
          что доступных для связи пакетов нет.
        - И пожаловаться по этому поводу в лог приложения.

      Сохранение/Извлечение данных из md2000
      --------------------------------------
        - При создании нового роута, он связывает с пакетом.
        - При удалении роута, все его связи с пакетами удаляются.
        - Перед Attach / Detach присутствие связи проверяется
          спомощью метода method_exists.
        - Если связи нет, то Attach / Detach не выполняются.
        - Всё равно это означает, что pivot-таблица уже очищена.
        - В случае отсутствия связей, пожаловаться в лог приложения.

      Очистка md2000 при удалении M1
      ------------------------------
        - Допустим, произошло удаление M1 правильным способом.
        - Выполняется afterupdate, и C38_clear_interpack_rels.
        - Таблица md2000 полностью очищается.

    2) Межпакетная связь между M5 и M1

      Описание
      --------
        - Права должны быть связаны с пакетами и командами.
        - Это позволит автоматически создавать права типов
          "access" и "exec".
        - Поэтому, в модели M5 создаются 2 новых foreign-связи.
        - Создаётся таблица md2000, с полями id_privilege и id_package.
        - Создаётся таблица md2001, с полями id_privilege и id_command.
        - Их связывают 1:n связями с таблицей прав.
        - В их description прописывают метаданные для автосоздания связей.

      Связанные модели
      ----------------
        \M1\Models\MD2_packages <---> \M5\Models\MD1_privileges
        \M1\Models\MD2_packages <---> \M5\Models\MD5_commands

      Использование r1_routes
      -----------------------
        - Применяется при создании автоматических прав.
        - Для этого требуется извлечь все D,L,W-пакеты и
          все команды.
        - Если r1_routes вернёт NULL, использовать пустую коллекцию.
        - И пожаловаться по этому поводу в лог приложения.

      Сохранение/Извлечение данных из md2000 и md2001
      -----------------------------------------------
        - Создание / Удаление права происходит лишь на основе
          данных, извлечённых r1_routes из M5.
        - Если r1_routes вернёт NULL, то создавать автоматические
          права будет не для кого.
        - И это означает, что pivot-таблица уже очищена.
        - В случае отсутствия связей, пожаловаться в лог приложения.

      Очистка md2000 при удалении M1
      ------------------------------
        - Допустим, произошло удаление M1 правильным способом.
        - Выполняется afterupdate, и C38_clear_interpack_rels.
        - Таблица md2000 полностью очищается.

# Подробнее о работе с конфигами пакетов

  • Конфиги публикуются для M,D,L,W-пакетов
    - У них есть в структуре файлы settings.php

  • Как публикуются конфиги
    - У каждого из этих пакетов есть сервис провайдер.
    - В нём прописана публикация конфигов в /config
    - Имя конфига каждого пакета равно имени его ID.
    - Например: D1.php, W1.php, M1.php, и т.д.
    - Публикация производится вместе со всеми остальными ресурсами.
    - Если режим development mode включен, то при каждом запросе и allrespublish.
    - Если выключен, то только при каждом allrespublish.

  • Как обновляются конфиги
    - Речь ниже пойдёт, разумеется, тольк о M,D,L,W-пакетах.
    - У каждого из них есть каталог файлами:

      /Cnfupds
        cfgupdate_1.php    // Это Laravel-команда
        cfgupdate_2.php    // Это Laravel-команда
        ...

    - Каждый файл содержит код для обновления конфига пакета.
    - И у каждого в конфиге есть массив "cnfupdshistory".
    - Также имеется команда С33_mdlw_cfgs_update и
      консольная команда T11_mdlw_cfgs_update.
    - Команда С33 выполняется при запуске к.команды m1:afterupdate.
    - Она извлекает содержимое cnfupdshistory.
    - cnfupdshistory может содержать возрастающую последовательность
      цифр типа ['1','2','3'] и так далее.
    - Далее, она извлекает массив цифр из имён файлов из Cnfupds.
    - Если в cnfupdshistory нет цифры для каких либо файлов,
      то с команда с помощью exec выполняет (в порядке возрастания)
      код из этих файлов. И записывает их цифры-имена в cnfupdshistory.

  • Примеры работы с конфигами

    Общие вводные
    -------------
      - В /Cnfupds уже 3 файла: cfgupdate_1.php, cfgupdate_2.php, cfgupdate_3.php
      - Массив cnfupdshistory: ['1','2','3'].

    Сценарий 1 - установка с нуля
    -----------------------------
      - В /config записывается новый конфиг пакета.
      - Никакие файлы из /cnfupds не устанавливаются.
      - Всё ОК.

    Сценарий 2 - установка на ['1']
    -------------------------------
      - Пакет был установлен ранее, конфиг уже опубликован.
      - Массив cnfupdshistory: ['1'].
      - Команда C33 выполняет сначала 2.php, затем 3.php.
      - И записывает cnfupdshistory: ['1','2','3'].

# Локализация пакетов

  • Общая информация о локализации пакетов
    - Лучше сразу делать приложение с возможностями локализациями.
    - Наверняка потребуется разрабатывать приложение для пользователей,
      разговаривающих на разных языках.
    - За основу следует взять 2 языка, RU и EN.
    - Всё приложение должно "из коробки" поддерживать эти языки.

  • Глобальная локализация
    - В конфиге /config/app.php есть опция "locale".
    - Это и есть параметр локализации всего приложения.
    - По умолчанию, все пакеты ориентируются именно на неё.

  • Локальная локализация
    - Доступна для M,D,L,W-пакетов.
    - В конфигах M,D,L,W-пакетов также есть опция locale.
    - По умолчанию, для неё доступны 2 значения:
      "RU", "EN".
    - По умолчанию, везде стоит значение "".
    - Это означает, что надо использовать глобальную локаль.

  • Локализация в M,D,L,W-пакетах

    ▪ Основная информация
      - Файлы локализации всего приложения лежат в /resources/lang/*
      - У каждого M,D,L,W-пакета есть каталог /Localization:

          /Localization
            /en
              localization.php
            /ru
              localization.php

      - Публикация файлов-локализаций производится в сервис-провайдерах
        этих пакетов.
      - Они публикуются в /resources/lang, в каталоге /ru, /en и т.д.
      - Файлы локализации переименовываются в ID D,L,W-пакета.
      - Допустим, при публикации файлов локализации пакета D1:

          /resources
            /lang
              /ru
                D1.php
              /en
                D1.php

    ▪ Как пользоваться
      - С помощью php-хелпера trans.
      - Например, в D1 есть фраза с ключём "welcome".
      - А пакет D1 использует глобальную локаль (она EN).
      - Тогда, извлечь фразу с ключём "welcome" можно
        так:
          trans('en.d1.welcome')        // где-нибудь в контроллере D1
          {{ trans('en.d1.welcome') }}  // где-нибудь в представлении D1

    ▪ Как получить локаль в клиенте
      - Локаль всегда передаётся контроллером пакета клиенту.
      - Это происходит при формировании ответа на get-запрос.
      - Локаль формируется хелпером r1_get_doc_locale по ID пакета.


# Подробнее о работе с базами данных M-пакетов

  • Суть работы с БД M-пакетов
    - У каждого M-пакета есть каталог Database.
    - В нём должны лежать файлы *.sql.
    - В качестве имён должны быть использованы цифры >= 1.
    - Нумерация должна начинаться с 1, с инкрементацие по 1.
    - Например: 1.sql, 2.sql, 3.sql.
    - Файл 1.sql содержит sql для установки начальной БД модуля.
    - Файлы с именем >= 2 - это sql для обновления БД модуля.
    - Также, в Database лежит .mwb файл с workbench-моделью модуля.
    - Вот как это всё выглядит (пример):

      /Database
        model.mwb
        1.sql
        2.sql
        3.sql

  • Когда происходит обновление БД M-пакета
    - Обновление производит скрипт из M1.
    - Который выполняется при каждом composer update.

  • Ведение истории обновление БД M-пакета в конфиге
    - Нельзя при каждом composer update выполнять все sql-файлы.
    - Так можно легко потерять важные данные.
    - Например, при таком раскладе, при каждом composer update
      все данные из таблицы m1.table будут теряться:
        1.sql - создать таблицу m1.table
        2.sql - удалить таблицу m1.table
        3.sql - создать таблицу m1.table
    - Чтобы этого не происходило, скрипту требуется знать,
      какие .sql файлы для модуля уже были ранее выполнены.
    - Эти данные записываются в файле настроек модуля в config/*
    - У каждого M-пакета в конфиге есть свойство "updateshistory".
    - Оно должна содержать массив цифр, обозначающих имена .sql файлов.
    - Это означает, что соотв. .sql-обновления уже были применены,
      и выполнять их повторно не требуется.

        'updateshistory' => [1,2,3],

# События Event и Broadcast

  • Общая информация об архитектуре событий приложения
    - Архитектура приложения подразумевает наличие лишь 2-х событий.
    - Это события Event (обычное) и Broadcast (трансляция).
    - Эти 2-ва события определены в пакете R2.

  • Событие Event
    - Принимает массив агрументов $data.
    - В нём можно передавать обработчику необходимые данные.
    - Один элемент - с ключём "keys" - является обязательным.
    - Он содержит массив строк-ключей.
    - Каждый обработчик реагирует только на определённые ключи.
    - Если в keys есть хотя бы 1 такой ключ, обработчик среагирует.

  • Событие Broadcast
    - Принимает массив агрументов $data.
    - В нём можно передавать обработчику необходимые данные.
    - Один элемент - с ключём "channels" - является обязательным.
    - Он содержит массив строк-каналов.
    - Клиенты-подписчики реагируют на сообщения лишь по определёным каналам.
    - По аналогии, как обработчики реагируют лишь на определнные ключи.

# Пространства имён пакетов

  • Общая информация о пространствах имён пакетов
    - Каждый пакет имеет своё пространство имён.
    - Имя пр.имён совпадает с ID пакета (напр.: M1, D1, L1, ...).

  • Пространство имён указывается в composer.json пакета
    - Например, есть у нас пакет M1.
    - В его composer.json указываем пр.имён:

      "autoload": {
        "psr-4": {"M5\\": ""}
      }

  • Пространство имён для разрабатываемых пакетов
    - Указывается в composer.json всего проекта.
    - Аналогичным образом, как и в composer.json пакета.

# Какие типы пакетов бывают у вендора 4gekkman

  • M-пакет
    - Имя M-пакета образуется по шаблону: M[целая цифра от 1 и выше]
    - Это пакеты с бэкенд-логикой.
    - Почти все M-пакеты имеют свою отдельную одноимённую базу данных.
    - Имеет строгую базовую структуру.

  • D-пакет
    - Это пакет, представляющий один фронтенд-blade-документ, и всё, что с ним связано.
    - Его контроллер, ресурсы, зависимости, локализация, и прочее.
    - Имеет строгую базовую структуру.
    - Имеет свой отдельный контроллер со своим URL для доступа к HTTP-API.

  • L-пакет
    - Это пакет, представляющий один фронтенд-blade-шаблон, и всё, что с ним связано.
    - Его контроллер, ресурсы, зависимости, локализация, и прочее.
    - Имеет строгую базовую структуру.
    - Имеет свой отдельный контроллер со своим URL для доступа к HTTP-API.

  • W-пакет
    - Это пакет, представляющий один фронтенд-blade-виджет, и всё, что с ним связано.
    - Его контроллер, ресурсы, зависимости, локализация, и прочее.
    - Имеет строгую базовую структуру.
    - Имеет свой отдельный контроллер со своим URL для доступа к HTTP-API.

  • R-пакет
    - Это пакет для различных ресурсов общего назначения.
    - Например, здесь могут быть хелперы для laravel.
    - Не имеет строгой базовой структуры.

# Возможные взаимные схемы зависимостей для пакетов разных типов

  • Пакеты разных типов могут зависеть друг от друга
    - Но не все схемы зависимостей разрешены приложением.

  • Бэкенд-зависимости прописываются в composer.json пакета
    - M,D,L,W-пакеты содержат файл composer.json.
    - Все бэкенд-зависимости прописываются в composer.json.
    - В стандартных для этого св-в require и прочих.

  • Фронтенд-зависимости прописываются в bower.json пакета
    - D,L,W-пакеты содержат bower.json.
    - Все внешние фронтенд-зависимости могут быть только от bower-пакетов.
    - Они прописываются в bower.json каждого пакета.
    - В стандартных для этого св-в dependencies и прочих.

  • Допустимые схемы зависимостей для пакетов разных типов

    ▪ M <--- R,M
      - M-пакаеты объективно могут зависеть друг от друга.
      - Ведь существуют межпакетные связи.
      - В их конфигах конкретно указано имя и версия пакета.
      - Поэтому M-пакеты не являются на 100% независимыми модулями.

    ▪ D <--- M,L,W
      - D-пакеты черпают логику своей работы от M-пакетов.
      - Также они могут наследовать от шаблонов L-пакетов.
      - И применять виджеты W-пакетов.

    ▪ L <--- M,W
      - L-пакеты могут черпать логику своей работы от M-пакетов.
      - Также они могут применять виджеты W-пакетов.

    ▪ W <--- M
      - W-пакеты могут черпать логику своей работы от M-пакетов.

    ▪ R <--- R
      - R-пакеты с ресурсами общего назначения могут зависеть друг от друга.

# Система управления фронтендом им. 4gekkman'а для laravel-приложения

  --------------------------------------------
  Подоглавление:

    А.  Теоретические основы СУФ

      А1. Аббревиатура СУФ
      А2. Термин "фронтенд"

        ▪ Состоит из 3-х составляющих
        ▪ Составляющая №1: CSS
        ▪ Составляющая №2: JS
        ▪ Составляющая №3: ASSETS

      А3. Типы пакетов в СУФ

        ▪ Тип №1: composer-DLW-пакеты вендора 4gekkman
        ▪ Тип №2: bower-пакеты

      А4. Зависимости между пакетами

        ▪ Зависимости между composer-DLW-пакетами
        ▪ Зависимости между bower-пакетами
        ▪ Зависимости composer-DLW-пакетов от bower-пакетов

      А5. Источники фронтенда для D-пакета в CУФ

        ▪ Фронтенд из папки public D-пакета
        ▪ Фронтенд из папок public LW-пакетов-зависимостей
        ▪ Фронтенд из bower-пакетов-зависимостей

      А6. Синхронизация зависимостей DLW-пакетов от bower-пакетов

        ▪ Плоский стек bower-зависимостей для всего проекта
        ▪ Главный файл bower.json проекта
        ▪ Файлы bower.json DLW-пакетов
        ▪ Набор команд в M1 для синхронизации зависимостей
        ▪ Файл-конфиг .bowerrc проекта

      А7. Куда и как публикуется фронтенд из источников

        ▪ Фронтенд из bower-пакетов
        ▪ Фронтенд из DLW-пакетов

      А8. Интеграция фронтенд-зависимостей в HTML D-пакета

        ▪ LW-пакеты не являются самостоятельными
        ▪ Интеграция актуальна только для D-пакетов
        ▪ Свойство main в bower.json bower-пакетов
        ▪ Если св-во main в bower.json пакета неправильное, подменить его
        ▪ Если в bower-пакете нет папочки dist
        ▪ Как определить порядок конкатенации js-файлов DLW-пакета
        ▪ Сбор списков и порядков интеграции для каждого D-пакета
        ▪ Осуществление интеграций фронтенд-ресурсов в HTML-документы D-пакетов

      А9. Отслеживание разрабатываемых пакетов для авто.пересборки

        ▪ Отслеживать требуется лишь разрабатываемые сейчас пакеты
        ▪ Отслеживание фронтенд-исходников DLW-пакетов и bower-пакетов
        ▪ Прямое указание ID DLW-пакетов и имён bower-пакетов для отслеживания
        ▪ Отслеживание фронтенд-конфига и перезагрузка watch при измемении

      А10. Применение browser-sync при вёрстке в D-пакетах

        ▪ Почему только в D-пакетах, а не в LW-пакетах?
        ▪ Отслеживание конечных файлов, интегрируемых в HTML D-пакетов
        ▪ Прямое указание ID D-пакетов для отслеживания
        ▪ Отслеживание фронтенд-конфига и перезагрузка watch при измемении


    Б.  Подробности реализации

      Б1. Файловая структура СУФ
      Б2. Механика СУФ
      Б3. Команды СУФ в M1


  --------------------------------------------

  > А1. Аббревиатура СУФ
    - Система управления фронтендом.
    - Будем называть её СУФ здесь и далее.

  > А2. Термин "фронтенд"

    • Состоит из 3-х составляющих
      - Термин "фронтенд" для нас будет состоять из 3-х составляющих.
      - Вот они:

        Фронтенд = CSS + JS + ASSETS.

    • Составляющая №1: CSS
      - Файлы .css, предназначенные для добавления в public проекта.
      - Компилируемые в .css файлы - .sass/.less/.styl/... -
        результирующие .css которых предназначены для добавления
        в public проекта.

    • Составляющая №2: JS
      - Файлы .js, предназначенные для добавления в public проекта.

    • Составляющая №3: ASSETS
      - Любые публичные ресурсы (шрифты, изображения, и прочие),
        предназначенные для добавления в public проекта.

  > А3. Типы пакетов в СУФ

    • Тип №1: composer-DLW-пакеты вендора 4gekkman
      - В СУФ используются composer-пакеты.
      - Применяются лишь composer-пакеты вендора 4gekkman.
      - И только так называемые DLW-пакеты (описаны выше).

    • Тип №2: bower-пакеты
      - В СУФ могут использоваться любые bower-пакеты.

  > А4. Зависимости между пакетами

    • Зависимости между composer-DLW-пакетами
      - DLW-пакеты могут зависеть друг от друга.
      - См.выше: "Допустимые схемы зависимостей для пакетов разных типов".

    • Зависимости между bower-пакетами
      - Любой bower-пакет может зависеть от любых других bower-пакетов.
      - Но лишь от одной версии конкретного bower-пакета.

    • Зависимости composer-DLW-пакетов от bower-пакетов
      - DLW-пакеты могут зависеть от любых bower-пакетов.

  > А5. Источники фронтенда для D-пакета в CУФ

    • Фронтенд из папки public D-пакета
      - Каждый D-пакет имеет свой собственный фронтенд.
      - Он находится в папке public в корне D-пакета.
      - Фронтенд в public строго структурирован.

    • Фронтенд из папок public LW-пакетов-зависимостей
      - Каждый LW-пакет имеет свой собственный фронтенд.
      - Он находится в папке public в корне LW-пакета.
      - Фронтенд в public строго структурирован.
      - D-пакет наследует фронтенд LW-пакетов, от которых зависит.

    • Фронтенд из bower-пакетов-зависимостей
      - Как упоминалось выше, DLW-пакеты могут зависеть от bower-пакетов.
      - И таким образом наследовать их фронтенд.
      - D-пакет наследует в т.ч. все bower-зависимости LW-пакетов, от которых зависит.

  > А6. Синхронизация зависимостей DLW-пакетов от bower-пакетов

    • Плоский стек bower-зависимостей для всего проекта
      - Каждый DLW-пакет может иметь bower-зависимости.
      - Мало того, разные DLW-пакеты могут иметь одни и те же bower-зависимости.
      - Но это не значит, что каждый из них получит свою копию bower-зависимости.
      - Вместо этого все bower-зависимости устанавливаются в единый каталог на уровне проекта.
      - Без повторов.

    • Главный файл bower.json проекта
      - У проекта есть главный, центральный файл bower.json.
      - Он должен содержать все зависимости проекта.

    • Файлы bower.json DLW-пакетов
      - У каждого DLW-пакета есть свой файл bower.json.
      - Он не предназначен, чтобы выполнять bower install в этом пакете.
      - А его задача лишь хранить список bower-зависимостей этого пакета.

    • Набор команд в M1 для синхронизации зависимостей
      - В M-пакете M1 есть список команд для реализации сабжа.
      - Одна из команд обходит все DLW-пакеты, и собирает все зависимости
        из их bower.json в главный bower.json проекта без повторов.
      - Вторая выполняет bower install / bower prune / bower update для главного
        bower.json проекта, синхронизируя установленные bower-пакеты проекта.

    • Файл-конфиг .bowerrc проекта
      - Рядом с главным bower.json проекта лежит файл .bowerrc.
      - Это конфиг для bower, срабатывающий при использовании CLI в папке с конфигом.
      - В первую очередь он полезен из-за возможности назначать хуки.

  > А7. Куда и как публикуется фронтенд из источников

    • Фронтенд из bower-пакетов
      - Ранее упоминалось о единой папке для всех bower-пакетов проекта.
      - Эта единая папка находится в public проекта.
      - Настроить путь к этой папке можно в файле .bowerrc проекта
      - То есть все скаченные bower-пакеты являются публично-доступными.
      - Они прямо целиком сразу и скачиваются в эту эту публичную папку.
      - Никакой дополнительной обработки этих ресурсов не проводится.

          <laravel>/public/public/bower/<имя пакета>

    • Фронтенд из DLW-пакетов
      - Фронтенд DLW-пакетов хранится в папках public в этих пакетах.
      - Там хранятся несжатые, необработанные исходники.
      - Специальная gulp-задача обходит все DLW-пакеты, и для каждого:

        ▪ Готовит специальную папку в public проекта для пакета.

          <laravel>/public/public/composer/<id пакета>

        ▪ Используя исходники, помещает фронтенд пакета в неё в опред.формате:
          ▪ Компилирует и обрабатывает все CSS-ресурсы, получая 1-ин .css-файл.
          ▪ Обрабатывает все js-ресурсы, получая 1-ин .js-файл.
          ▪ Копирует все assets.

  > А8. Интеграция фронтенд-зависимостей в HTML D-пакета

    • LW-пакеты не являются самостоятельными
      - LW-пакеты не могут быть использованы, как самостоятельные документы.
      - Их роль сводится лишь к бытию зависимостями D-пакетов.

    • Интеграция актуальна только для D-пакетов
      - Значит интегрировать фронтенд-зависимоси надо лишь в документы D-пакетов.
      - А в документы DL-пакетов ничего интегрировать не следует.
      - Потому что blade сливает док. D-пакета с док-ми LW-пакетов, от которых он зависит.
      - Поэтому, достаточно интегрировать необходимый фронтенд в документ D-пакета.

    • Свойство main в bower.json bower-пакетов

      ▪ Общая информация
        - В bower.json bower-пакетов может быть свойство main.
        - В нём содержится список путей, относительно корня пакета.
        - Каждый из путей может вести к какому-либо фронтенд-файлу.
        - Например, к файлам типа: .css, .sass, .js, и так далее.
        - По правилам там не м.б. >= 2 путей к файлам одного и того же типа.
        - То есть, к каждому из типов может вести лишь 1-ин путь.

      ▪ Как СУФ использует содержимое main
        - В большинстве случаев достаточно найти в main css/js файлы.
        - И всё, их можно спокойно подключать в HTML D-пакета.

    • Если св-во main в bower.json пакета неправильное, подменить его
      - Его можно подменить в главном фронтенд-конфиге проекта.
      - Для этого там есть специальное, по умолчанию пустое св-во.
      - В нём можно подменить main для любого bower-пакета.

    ▪ Если в bower-пакете нет папочки dist
      - То есть ресурсы не подготовлены для интеграции в HTML.
      - И, скажем, надо самому компилировать и обрабатывать SASS-файлы.
      - Тогда можно самому создать gulp-задачу с таким же как у пакета именем.
      - И в этой задаче выполнить все необходимые компиляции и обработки.
      - Результаты можно сохранить, скажем, в папочке пакета, в dist.
      - И эти же результаты можно прописать в main пакета в главном фронтенд-конфиге.

    ▪ Как определить порядок конкатенации js-файлов DLW-пакета
      - Надо обеспечить возможность использовать любой JS-фреймворк (knockout/angular).
      - Соотв.js-приложение может состоять из некоторого кол-ва js-файлов.
      - А для подключения к HTML D-пакета нам надо их сконкатенировать в 1-ин.
      - Чаще всего порядок конкатенации имеет значение. Но какой же он должен быть?
      - Этот порядок можно настроить в bower.json пакета, в спец.свойстве.
      - Если это свойство оставить пустым, порядок будет произвольным.

    • Сбор списков и порядков интеграции для каждого D-пакета
      - Эта информация собирается и записывается в главный фронтенд-конфиг проекта.
      - Сбор информации производится специальной командой из M-пакета M1.

    • Осуществление интеграций фронтенд-ресурсов в HTML-документы D-пакетов
      - В HTML-документах D-пакетов предусмотрены спец.места для авто.интеграций.
      - Эти места выделены т.н. начальным и конечным комментами.
      - В каждом документе предусмотрены 2 таких места: для css и для js.
      - Специальная команда на основе собранных данных осуществляет интеграцию
        для каждого D-пакета.
      - Примеры:

        <!-- css integration: start -->
        <!-- css integration: stop -->

        <!-- js integration: start -->
        <!-- js integration: stop -->

  > А9. Отслеживание разрабатываемых пакетов для авто.пересборки

    • Отслеживать требуется лишь разрабатываемые сейчас пакеты
      - Windows не работает с VirtualBox через NFS.
      - Значит gulp.watch должен применять usePolling.
      - Поэтому чем за бОльшим кол-вом файлов он наблюдает, тем всё медленнее.
      - Поэтому, оптимально наблюдать за MIN возможным кол-вом файлов.
      - Поэтому отслеживать ВСЕ исходники всех DLW-,bower-пакетов - не лучший вариант.

    • Отслеживание фронтенд-исходников DLW-пакетов и bower-пакетов
      - Отслеживать можно исходники как DLW-, так и bower-пакетов.
      - Рассмотрим оба этих случая:

      ▪ Отслеживание исходников DLW-пакетов
        - Какой пакет отслеживать задаётся по ID пакета.
        - Отслеживаются все файлы в папке public пакета.

      ▪ Отслеживание исходников bower-пакетов
        - Какой пакет отслеживать задаётся по имени пакета.
        - Отслеживаются все файлы в папке пакета.

    • Прямое указание ID DLW-пакетов и имён bower-пакетов для отслеживания
      - В главном фронтенд-конфиге имеется специальное свойство.
      - В нём можно прямо указать, исходники каких пакетов отслеживать.
      - Надо указывать или ID (для DLW-пакетов), или имя (для bower-пакетов).
      - По умолчанию это свойство является пустым, и ничего не отслеживается.
      - Во время разработки можно добавлять туда отслеживаемые пакеты.
      - На продакшн это свойство должно быть пустым.

    • Отслеживание фронтенд-конфига и перезагрузка watch при измемении
      - Требуется наличие задачи, отслеживающий фронтенд-конфиг.
      - И при его изменении перезагружающий watch по отслеживанию исходников.

  > А10. Применение browser-sync при вёрстке в D-пакетах

    • Почему только в D-пакетах, а не в LW-пакетах?
      - Потому что LW-пакеты не являются самостоятельными.
      - Они лишь могут служить зависимостями для D-пакетов.
      - И пользователь видит документ именно для D-пакета.
      - А отлаживать LW-пакеты можно, через D-пакет, сделав их его зависимостями.

    • Отслеживание конечных файлов, интегрируемых в HTML D-пакетов
      - Одна из команд из M1 вычисляет список и порядок фронтенд-ресурсов,
        которые должны быть вставлены в каждый из D-пакетов.
      - В главном gulpfile browser-sync watch должен следить за этими файлами.
      - Это могут быть фронтенд-ресурсы из всех 3-х типов источников.

    • Прямое указание ID D-пакетов для отслеживания
      - В главном фронтенд-конфиге можно в спец.св-ве указать ID D-пакетов.
      - Browser-sync будет следить за конечными фронтенд-ресурсами лишь этих пакетов.
      - По умолчанию это спец.свойство пустое, и в продакшн тоже д.б. пустое.
      - А во время разработки можно указывать ID D-пакета, чьи фронтенд-
        ресурсы сейчас разрабатываются.

    • Отслеживание фронтенд-конфига и перезагрузка watch при измемении
      - Требуется наличие задачи, отслеживающий фронтенд-конфиг.
      - И при его изменении перезагружающий watch по отслеживанию исходников.


  > Б1. Файловая структура СУФ

    <проект>                        | каталог проекта
                                    |
      /project                      | каталог с laravel в проекте

        bower.json                  | главный bower.json проекта
        .bowerrc                    | настройки bower, здесь указан путь для установки пакетов в /public/public/bower
        gulpfile.js                 | главный gulpfile проекта

        /vendor                     |
          /4gekkman                 |
            /M1                     | пакет M1, содержащий в т.ч. команды для СУФ
              /commands             |
                C<номер>_.php       | несколько команд для СУФ
            /D<номер>               |
              composer.json         | здесь зависимости DLW-пакетов друг от друга
              bower.json            | это bower-файл DLW-пакета
              /public               | исходники публичных ресурсов пакета
                /css                |
                  *.scss            | css-исходники в формате .scss
                /js                 |
                  *.js              | js-исходники
                /assets             |
            /L<номер>               |
              composer.json         |
              bower.json            |
              /public               |
                /css                |
                  *.scss            |
                /js                 |
                  *.js              |
                /assets             |
            /W<номер>               |
              composer.json         |
              bower.json            |
              /public               |
                /css                |
                  *.scss            |
                /js                 |
                  *.js              |
                /assets             |

        /public                     |
          /public                   |
            /bower                  | в эту папку устанавливаются все bower-пакеты
              <имя пакета>          |
              <имя пакета>          |
              <имя пакета>          |
                ...                 |
                ...                 |
                ...                 |
            /composer               | в эту папку с помощью gulp публикуются ресурсы DLW-пакетов
              <id пакета>           |
              <id пакета>           |
              <id пакета>           |
                /css                |
                  c.css             |
                  c.min.css         |
                /js                 |
                  j.js              |
                  j.min.js          |
                /assets             |

      /configs                      |
        /groups                     |
          /<имя группы>             | имя группы лежит в переменной среды CONFIGS_GROUP всех контейнеров проекта
            /frontend               | это папка для конфига для фронтенда
              /config.json          | это конфиг для СУФ

      /other                        |
        /gulptasks4bowerpacks       | // Иногда в bower-пакете есть лишь исходники, и отсутствуют
          <имя пакета>.js           | // обработанные и готовые к использованию css/js, тогда можно
          <имя пакета>.js           | // положить сюда задачу для gulp в файл с таким же именем, как
          <имя пакета>.js           | // у пакета, и в этой задаче создать готовые к использованию css/js.


  > Б2. Механика СУФ

    # Полная картина в мелком масштабе

      1. Что нам надо делать, в нескольких строчках
        - Собрать необходимую инфу в bower.json проекта.
        - Установить все необходимые bower-пакеты в public.
        - Установить public-ресурсы DLW-пакетов в public.
        - Интегрировать public-ресурсы в blade-документы D-пакетов.
        - Отслеживать gulp.watch'ем указанные в конфиге DLW-,bower-пакеты.
        - Отслеживать browser-sync'ом указанные в конфиге D-пакеты.

      2. Что является триггерами
        - Ручной запуск artisan-командой из M1.
        - Авто.запуск этой команды хуками для composer и bower.
          (установка, обновление, удаление).

    # Подробное описание каждой задачи в механике СУФ

      -----------------
        Задача №1: сбор всех dependencies bower.json проекта
        Задача №2: install/prune/update пакетов из главного bower.json проекта
        Задача №3: сбор всех main в главный bower.json проекта
        Задача №4: подмена main некоторых пакетов в главном bower.json проекта
        Задача №5: сбор всех конфигов компиляции/обработки/публикации всех DLW-пакетов
        Задача №6: подготовка задач gulptasks4bowerpacks в gulpfile.json
        Задача №7: подготовка задач dlw_prepearing_tasks
        Задача №8: сбор списков и порядков интеграции для каждого D-пакета
        Задача №9: интеграция ресурсов в blade-документы D-пакетов
        Задача №10: обновление списка ф-лов для gulp.watch в gulpfile.js проекта
        Задача №11: перезапуск gulp.watch при изменениях в gulpfile.js
        Задача №12: обновление списка ф-лов для browser-sync в gulpfile.js проекта
        Задача №13: перезапуск browser-sync при изменениях в gulpfile.js
        Задача №14: запуск всех задач из gulpfile.js в нужном порядке
      -----------------

      • Задача №1: сбор всех dependencies bower.json проекта

        ▪ Описание
          - Обход всех bower.json DLW-пакетов.
          - Сбор всех уникальных значений в dependencies главного bower.json

        ▪ Что на выходе
          - В главном bower.json проекта д.б. св-во "dependencies".
          - В него д.б. размещены все зависимости из всех DLW-пакетов.
          - Дубли должны исключаться.
          - Пример:

            {
              ...
              "dependencies": {
                "bootstrap": "^3.3.6"
              }
              ...
            }

      • Задача №2: install/prune/update пакетов из главного bower.json проекта

        ▪ Описание
          - На этом этапе в bower.json проекта у нас есть полный список
            всех bower-зависимостей проекта в св-ве dependencies.
          - Теперь надо обновить существующие, установить новые, и
            удалить отсутствующие в списке.

        ▪ Что на выходе
          - В public/public/bower проекта все пакеты синхронизируются
            со списком в bower.json проекта.
          - Отсутствующие в списки удаляются, отсутствующие в каталоге
            устанавливаются, присутствующие в каталоге обновляются.

      • Задача №3: сбор всех main в главный bower.json проекта

        ▪ Описание
          - Обход всех bower.json всех bower-пакетов в public/public/bower
          - Сбор всех main для каждого bower-пакета, имя пакета - массив main.
          - В свойстве extra -> mains.

        ▪ Что на выходе
          - В главном bower.json есть свойство "extra" -> "mains".
          - Этой свойство содержит подобный объект:

            "mains": {
              "<имя bower-пакета>" => [
                "public/public/bower/<имя bower-пакета>/c.scss",
                "public/public/bower/<имя bower-пакета>/c.min.css",
                "public/public/bower/<имя bower-пакета>/j.min.js",
              ],
              "<имя bower-пакета>" => [ ... ]
            }

          - Все пути в нём от корня каталога с laravel.

      • Задача №4: подмена main некоторых пакетов в главном bower.json проекта

        ▪ Описание
          - Заглядываем во фронтенд-конфиг (frontend/config.json).
          - Смотрим там свойство main_replaces.
          - Оно содержит пары: имя пакета - массив со строками main.
          - Пробегаемся по этому массиву, для каждого пакета подменяем
            его main из bower.json проекта (extra -> mains) на main
            из фронтенд-конфига.

        ▪ Что на выходе
          - В главном bower.json есть свойство "extra" -> "mains".
          - Результатом выполнения задачи №4 будет подмена для
            некоторых bower-пакетов их массива с путями в "mains".

      • Задача №5: сбор всех конфигов компиляции/обработки/публикации всех DLW-пакетов

        ▪ Описание
          - Обход всех bower.json всех bower-пакетов в public/public/bower
          - Сбор всех extra -> publish_options каждого bower-пакета.
          - В свойстве extra -> publich_options главного bower-пакета.
          - В нём объект с: ID DLW-пакета - опции публикации.

        ▪ Свойство "publish_options" в bower.json DLW-пакетов
          - Выглядит подобным образом:

            "publish_options": {
              "js": {
                "order": [
                  "f.js",
                  "m.js",
                  "j.js"
                ]
              },
              "css": {
                "preprocessor": "sass",
                "entrypoint": "main.scss"
              }
            }

          - При всём при этом, "publish_options" м.б. пустым.

        ▪ Что на выходе
          - В главном bower.json есть свойство "extra" -> "publish_options".
          - Этой свойство содержит подобный объект:

            "publish_options": {
              "D1": {
                "js": {
                  "order": [
                    "f.js",
                    "m.js",
                    "j.js"
                  ]
                },
                "css": {
                  "preprocessor": "sass",
                  "entrypoint": "main.scss"
                }
              },
              "L1": { ... }
            }

      • Задача №6: подготовка задач gulptasks4bowerpacks в gulpfile.json

        ▪ Описание
          - В gulpfile.js в специальный раздел вставляется ряд задач.
          - Просматривается папочка с задачами other/gulptasks4bowerpacks.
          - Вставляются лишь задачи, имя которых совпадает с 1-им из установленных
            bower-пакетов.
          - Для этих пакетов надо в обязательном порядке подменять main
            в frontend/config.json
          - При этом старые задачи оттуда удаляются.

        ▪ Что на выходе
          - В gulpfile.js проекта есть специальные метки.
          - Задачи из gulptasks4bowerpacks вставляются между этими метками.
          - После определения всех задач, определяется ещё одна доп.задача,
            которая с помощью gulp.parallel запускает все эти задачи. Имя
            этой задачи: spec_bower_frontend_preparing
          - Всё это выглядит примерно так:

            <!-- spec_bower_frontend_preparing: start -->
            gulp.task('taskname1', function(callback){
              // ...
            });
            gulp.task('taskname2', function(callback){
              // ...
            });
            gulp.task('taskname3', function(callback){
              // ...
            });
            gulp.task('spec_bower_frontend_preparing', gulp.parallel('build', gulp.parallel('taskname1', 'taskname2', 'taskname3')));
            <!-- spec_bower_frontend_preparing: stop -->

          - Имена задач образуются по шаблону:

              spec_bower_frontend_preparing_<имя bower-пакета>

      • Задача №7: подготовка задач dlw_prepearing_tasks

        ▪ Описание
          - В gulpfile.js в специальный раздел вставляется ряд задач.
          - По 1-й задаче для каждого установленного DLW-пакета.
          - При генерировании задач учитываются опции из главного bower.json проекта.
          - Эти задачи компилируют/конкатенируют/минифицируют css и js
            ресурсы для каждого DLW-пакета, и публикуют результаты в
            строго отформатированной форме в public/public/composer/<id DLW-пакета>.

        ▪ Что в итоге с gulpfile.js
          - В gulpfile.js проекта есть специальные метки.
          - Задачи вставляются между этими метками.
          - После определения всех задач, определяется ещё одна доп.задача,
            которая с помощью gulp.parallel запускает все эти задачи. Имя
            этой задачи: dlw_prepearing_tasks
          - Всё это выглядит примерно так:

            <!-- dlw_prepearing_tasks: start -->
            gulp.task('taskname1', function(callback){
              // ...
            });
            gulp.task('taskname2', function(callback){
              // ...
            });
            gulp.task('taskname3', function(callback){
              // ...
            });
            gulp.task('dlw_prepearing_tasks', gulp.parallel('build', gulp.parallel('taskname1', 'taskname2', 'taskname3')));
            <!-- dlw_prepearing_tasks: stop -->

          - Имена задач образуются по шаблону:

              dlw_prepearing_tasks_<id DLW-пакета>

        ▪ Что на выходе в public
          - Публ.ресурсы DLW-пакетов публикуются в public/public/composer/<id DLW-пакета>
          - Структура опубликованных публ.ресурсов DLW-пакетов всегда одинаковая:

            /css
              c.css
              c.min.css
            /js
              j.js
              j.min.js
            /assets
              ... здесь структура не регламентирована ...

      • Задача №8: сбор списков и порядков интеграции для каждого D-пакета

        ▪ Описание
          - Пробегаются все D-пакеты.
          - Составляются дерево DLW-, bower-зависимостей.
          - Для всех ресурсов указываются пути от корня каталога с laravel.
          - Затем дерево разбивается на 2 отдельных: по js и css.
          - Для каждой зависимости устанавливается индекс глубины.
          - В случае дублирования берётся лишь более глубокая зависимость.
          - Из деревьев извлекаются 2 плоских стека: css и js.
          - Всё это записывается в bower.json проекта (extra -> dpacks_res_stacks).
          - Ключ: id d-пакета, значения - 2 массива css и js со списками путей к ресурсам.

        ▪ Что на выходе
          - Итоговый массив данных записывается в bower.json проекта.
          - В bower.json есть св-во "extra" -> "integration_lists".
          - Итоговый объект с данными в нём выглядит примерно так:

            "integration_lists": {
              "D1": {
                "css": [
                  "public/public/bower/pack1/c.css",
                  "public/public/bower/pack2/c.css",
                  "public/public/composer/D1/css/c.min.css"
                ],
                "js": [
                  "public/public/bower/pack1/j.js",
                  "public/public/bower/pack2/j.js",
                  "public/public/composer/D1/js/j.min.js"
                ]
              },
              "D2": { ... }
            }

      • Задача №9: интеграция ресурсов в blade-документы D-пакетов

        ▪ Описание
          - Пробегаются все D-пакеты.
          - В каждом находится view.blade.php
          - Списки и порядок css и js ресурсов смотрится в bower.json проекта,
            в extra -> integration_lists.

        ▪ Что на выходе
          - Во view.blade.php есть специальные метки.
          - Для css- и js-ресурсов по отдельной паре меток.
          - Ресурсы из css и js списков вставляются между этими метками.
          - CSS-метки находятся в head blade-документа.
          - JS-метки находятся в конце blade-документа
          - Всё это выглядит примерно так:

            <!-- css integration: start -->
            <link rel="stylesheet" type="text/css" href="{{ asset('public/bower/pack1/c.min.css') }}">
            <link rel="stylesheet" type="text/css" href="{{ asset('public/bower/pack2/c.min.css') }}">
            <link rel="stylesheet" type="text/css" href="{{ asset('public/composer/D1/c.min.css') }}">
            <!-- css integration: stop -->

            <!-- js integration: start -->
            <script src="{{ asset('public/bower/pack1/j.min.js') }}"></script>
            <script src="{{ asset('public/bower/pack2/j.min.js') }}"></script>
            <script src="{{ asset('public/composer/D1/j.min.css') }}"></script>
            <!-- js integration: stop -->

      • Задача №10: обновление списка ф-лов для gulp.watch в gulpfile.js проекта

        ▪ Описание
          - Заглядываем в config.json и ищем св-во gulpwatch.
          - И него извлекаем списки ID DLW-пакетов, и имен bower-пакетов.
          - Создаём массив путей к корневым каталогам этих пакетов.
          - Идём в gulpwatch и ищем специальные метки.
          - Заменяем то, что между ними, на наш новый массив gulpwatchlist.

        ▪ Как выглядит св-во gulpwatch

          "gulpwatch": {
            "dlw": [
              "D1",
              "L1"
            ],
            "bower": [
              "bootstrap",
              "mypack1"
            ]
          }

        ▪ Что на выходе
          - Метки для gulpwatch находятся ближе к началу файла gulpfile.js проекта.
          - Вот так это выглядит:

            <!-- gulpwatchlist: start -->
            var gulpwatchlist = ["<path2pack>", "<path2pack>", ...];
            <!-- gulpwatchlist: stop -->

      • Задача №11: перезапуск gulp.watch при изменениях в gulpfile.js

        ▪ Описание
          - Одна из задач в gulpfile.js отслеживает файл gulpfile.js.
          - При любых изменениях в нём, она перезапускает gulp.watch.

        ▪ Что на выходе
          - Перезапущенный gulp.watch.
          - Который использует новый gulpwatchlist.

      • Задача №12: обновление списка ф-лов для browser-sync в gulpfile.js проекта

        ▪ Описание
          - Заглядываем в config.json и ищем св-во browsersync.
          - И него извлекаем список ID D-пакетов.
          - Идём в bower.json проекта, получаем св-во "extra" -> "integration_lists".
          - Извлекаем списки интеграции для всех указанных в config.json D-пакетов.
          - Идём в gulpwatch и ищем специальные метки.
          - Заменяем то, что между ними, на наш новый массив browsersynclist.

        ▪ Что на выходе
          - Метки для browsersync находятся ближе к началу файла gulpfile.js проекта.
          - Вот так это выглядит:

            <!-- browsersynclist: start -->
            var browsersynclist = ["<path>", "<path>", ...];
            <!-- browsersynclist: stop -->

      • Задача №13: перезапуск browser-sync при изменениях в gulpfile.js

        ▪ Описание
          - Одна из задач в gulpfile.js отслеживает файл gulpfile.js.
          - При любых изменениях в нём, она перезапускает browser-sync.

        ▪ Что на выходе
          - Перезапущенный browser-sync.
          - Который использует новый browsersynclist.

      • Задача №14: запуск всех задач из gulpfile.js в нужном порядке

        ▪ Описание
          - Эта задача называется run.
          - Она запускает все задачи из gulpfile.js в нужном порядке.






Как будет работать основная часть СУФ
--------------------------------------

  • Мы не полагаемся на "родной" mains bower-пакетов
    - Вмест

  • Для каждого bower-пакета указываем mains в bower.json DLW-пакета
  •





















```

## Функционал <a id="link4"></a>
```

  # Команды и к.команды общего назначения #
  #---------------------------------------#

    Команда                 К.Команда                   Описание
    ----------------------------------------------------------------------------------------------------------------------
    parseapp              | m1:parseapp               | Парсит приложение, возбуждает событие "m1:afterupdate"
    sp_regs_update        | m1:sp_regs_update         | Актуализирует регистрации сервис-провайдеров пакетов
    allrespublish         | m1:allrespublish          | Публикует ресурсы всех пакетов (имеющие соотв.теги)
    m_dbs_update          | m1:m_dbs_update           | Устанавливает / обновляет базы данных M-пакетов
    release               | m1:release                | Создаёт новый релиз на github указанного пакета
    mdlw_cfgs_update      | m1:mdlw_cfgs_update       | Актуализирует конфиги MDLW-пакетов
    m_schedules_update    | m1:m_schedules_update     | Актуализирует запланированные задачи на выполнение консольных команд M-пакетов
    workbench_sync        | m1:workbench_sync         | Для указанного M-пакета синхронизирует модели и связи в них с его БД
    workbench_sync_all    | m1:workbench_sync_all     | Для всех M-пакетов синхронизирует модели и связи в них с их БД
    clear_interpack_rels  | m1:clear_interpack_rels   | Подчищает pivot-таблицы уже неактуальных межпакетных связей

  # Команды и к.команды CLI-приложения для разработки по управлению ресурсами #
  #---------------------------------------------------------------------------#

    Команда           К.Команда               Описание
    ----------------------------------------------------------------------------------------------------------------------
    -               | m1:new                | Единая точка входа в CLI-приложение

    new_m           | -                     | Новый M-пакет
    new_m_c         | -                     | Новая M-команда
    new_m_t         | -                     | Новая M-к.команда
    new_m_h         | -                     | Новый M-обработчик
    new_m_ct        | -                     | Новая пара M-команда - M-к.команда
    new_m_m         | -                     | Новая M-модель
    del_m           | -                     | Удалить указанный M-пакет
    del_m_с         | -                     | Удалить указанную M-команду указанного M-пакета
    del_m_t         | -                     | Удалить указанную M-к.команду указанного M-пакета
    del_m_h         | -                     | Удалить указанный M-обработчик указанного M-пакета
    del_m_m         | -                     | Удалить указанную M-модель указанного M-пакета

    new_r           | -                     | Новый R-пакет
    del_r           | -                     | Удалить указанный R-пакет

  # Команды системы управления фронтендом #
  #---------------------------------------#

    Команда                 К.Команда                   Описание
    ----------------------------------------------------------------------------------------------------------------------
    -                       m1:suf                      Trigger for all processes of frontend control system
    suf_collect_deps        m1:suf_collect_deps         Collect all bower-dependencies from bower.json of DLW-packages to bower.json of the project
    suf_install_deps        m1:suf_install_deps         Install all bower-dependencies in bower.json of the project




  # Обработчики событий #
  #---------------------#

    -


```
## Схемы взаимодействий с другими пакетами <a id="link5"></a>
```

  # Pull-взаимодействия (по инициативе этого пакета) #
  #--------------------------------------------------#

    ---------------------------------------------------------------------------------------------
    Пакет     Команда     К.Команда     Обработчик      Событие           Комментарий
    ---------------------------------------------------------------------------------------------

      -

  # Push-взаимодействия (по инициативе других пакетов) #
  #----------------------------------------------------#

    ---------------------------------------------------------------------------------------------
    Пакет     Команда     К.Команда     Обработчик      Событие           Комментарий
    ---------------------------------------------------------------------------------------------

      -


```
## Установка, обновление, удаление <a id="link6"></a>
```

----------------------
Оглавление

  # Установка
  # Обновление
  # Удаление

----------------------

> Установка

  1. Добавить инфу о пакете в composer.json проекта
    - Добавить зависимость (укажите нужную вам версию):

        "require": {
            "4gekkman/m1": "1.0.*"
        }

    - Добавить адрес git-репозитория:

        "repositories": [
            {
                "type": "vcs",
                "url":  "git@github.com:4gekkman/m1.git"
            }
        ]

  2. Добавить к.команду "m1:afterupdate" в composer.json проекта
    - К.Команда m1:afterupdate добавляется в composer.json проекта,
      в массивы "post-install-cmd" и "post-update-cmd":

        php artisan m1:afterupdate

    - После этого она будет выполняться автоматически, после каждого
      composer update.

  3. Добавить сервис-провайдер пакета в config/app.php
    - Открыть конфиг config/app.php.
    - Найти там массив providers.
    - Добавить в него сервис-провайдер пакета M1:

        M1\ServiceProvider::class,

  4. Выполнить composer update

  5. Настроить модуль в его конфиге config/m1.php
    - И после этого выполнить composer update.

> Обновление

  1. Прописать в composer.json нужную версию пакета
    - Можно указать конкретную версию пакета.
    - А можно указать, чтобы при выполнении composer update
      автоматически устанавливалась свежая patch- / minor- / major-версия.
    - Примеры:

      "1.0.*"    // >=1.0.0 <1.1.0
      "~1.3"     // >=1.3.0 <2.0.0
      ">=2"      // >= 2.0.0

  2. Выполнить composer update
    - Сабж.

> Удаление

  1. Выполнить 1,2,3 из "Установка" наоборот.
  2. Выполнить composer update
  3. Вручную удалить базу данных M1 из СУБД.

```




## Заметки к релизам <a id="link100"></a>
```

  1.0.0
    - Первый релиз.

```










