# M5 - Package to manage users and privileges (master)
---
## Оглавление

  - [Ссылки](#link1)
  - [Введение](#link2)
	- [Общее описание работы пакета](#link3)
	- [Функционал](#link4)
	- [Схемы взаимодействий с другими пакетами](#link5)
	- [Транс-пакетные связи](#link6)
	- [Кэширование](#link7)
  - [Заметки к релизам](#link100)

---

## Ссылки <a id="link1"></a>
```

  > Адрес репозитория пакета M5 на github
      https://github.com/4gekkman/m5

	
			
```

## Введение <a id="link2"></a>
```

  ● Это М-пакет для управления пользователями, группами и правами.
  ● Права могут быть:
    - На доступ к документам D-пакетов.
    - На выполнение команд.
    - Кастомные права.


```
## Общее описание работы пакета <a id="link3"></a>
```

  --- Оглавление

    # Пользователи
    # Администраторы
    # Анонимный пользователь
    # Группы
    # Права
    # Принцип формирования итогового набора прав пользователей
    # Принцип формирования итогового набора прав групп
    # Теги
    # Автопометка автоматических прав тегами
    # Обновление состава формируемых автоматических прав
    # Выключатель системы проверки автоматических прав

    # Пароль: ограничение на min кол-во символов
    # Пароль: механизм восстановления пароля через email
    # Пароль: механизм восстановления пароля через sms
    # Пароль: защита механизма от брутфорса

    # Верификация: общие принципы
    # Верификация: процесс верификации email
    # Верификация: процесс верификации phone
    # Верификация: автоочистка таблиц вер.кодов по расписанию
    # Верификация: автоматическая верификация при входе через соц.сети
    # Верификация: автоматическое удаление пользователей с не вериф.email и phone через N часов
    # Верификация: попытка зарегистрироваться с присутствующим, но не вериф.email/phone

    # Аутентификация: варианты
    # Аутентификация: настройка времени жизни в зависимости от групп
    # Аутентификация: таблица аутентификаций, возможность множественных аутентификаций
    # Аутентификация: аутентификационный кэш в сессии
    # Аутентификация: описание процесса после ввода аутентиф.данных
    # Аутентификация: описание процесса распознавания аутентифицированных пользователей
    # Аутентификация: выход
    # Аутентификация: блокировка пользователя
    # Аутентификация: изменение "email" / "phone" / "пароля" пользователя
    # Аутентификация: где происходит распознавание, как данные передаются клиенту



    # Механизм восстановления пароля
    # Защита от брутфорса
    # Настройка времени жизни аутентификационной куки
    # Настройка переадресации после входа
    # Настройка столбцов, которые можно использовать в качестве логина
    # Настройка факторов и сценариев аутентификации
    # Настройка SMS-аутентификации
    # Настройка аутентификации через секретную фразу
    #

  ---

  # Пользователи
    - Эта сущность нужна для персонализации пользователей приложения.
    - Чтобы при каждом визите пользователя приложение его узнавало.
    - Пользователи м.б. связаны с группами / правами / тегами.

  # Администраторы
    - Администратором является пользователь в группе с флагом "администраторы".
    - В системе может быть только 1 группа с флагом "администраторы".
    - Если таковой группы нет, то значит в системе нет администраторов.

  # Анонимный пользователь
    - Анонимными называют не аутентифицированных пользователей.
    - В системе может быть лишь 1 пользователь с флагом "анонимный".
    - Если такового нет, то анонимные пользователи не имеют никаких прав.

  # Группы
    - Группы облегчают организацию воздействия на массы пользователей.
    - Группы м.б. связаны с пользователями / правами / тегами.

  # Права
    - Общий принцип такой: всё, что явно не разрешено, запрещено.
    - Права м.б. связаны с пользователями / группами / тегами.
    - Бывают 3 типа прав:

      1) access    | На доступ к интерфейсам D,L,W-пакетов.
        - Формируются системой автоматически.
        - Получают имя по шаблону: access_[ID D,L,W-пакета]
        - Реализуются в before middleware пакета M5.

      2) exec      | На выполнение команд.
        - Формируются системой автоматически.
        - Получают имя по шаблону: exec_[ID M-пакета]_[ID команды]
        - Реализуются в хелпере runcommand.

      3) custom    | Кастомные права.
        - Формируются пользователем вручную.
        - Получают имя по шаблону: custom_[любая строка]
        - Стандарты по реализации этих прав отсутствуют.

    - Инфу о пакетах и командах, необходимую для автоматического
      формирования соответствующих прав, пакет получает транс-пакетные
      связи с пакетами M1 и M4.

  # Принцип формирования итогового набора прав пользователей
    - Итоговый набор прав пользователя складывается так:

      1) Права, прямо связанные с пользователем.
      2) Права, связанные с группами, с которыми связан пользователь.
      3) Права, связанные с тегами, связанные с группами, с которыми связан пользователь.
      4) Права, связанные с тегами, с которыми связан пользователь.
      5) Если пользователь состоит в группе с флагом "Admin",
         ему присваиваются все имеющиеся права.

  # Принцип формирования итогового набора прав групп
    - Итоговый набор прав группы складывается так:

      1) Права, прямо связанные с группой.
      2) Права, связанные с тегами, которые связаны с группами.
      3) Если группа имеет флаг "Admin", она получает все имеющиеся права.

  # Теги
    - Правам, пользователям и группам могут присваиваться теги.
    - Один тег может быть присвоен и тем, и другим и третьим.
    - Теги помогают находить и воздействовать на наборы сущностей.
    - Кроме того, они задействованы в механизме автоприсвоения прав.

  # Автопометка автоматических прав тегами
    - Права типов exec и access автоматически помечаются тегами при создании.
    - А именно, тегами принадлежности к тому или ному пакету.
    - Примеры: 'm1', 'd5', 'l3'.

  # Обновление состава формируемых автоматических прав
    - Все права типов access и exec формируются исплючительно автоматически.
    - Первые формируются на основе данных из базы пакета M1.
    - Вторые формируются на основе данных из базы пакета M4.
    - Соответствующие данные приложение извлекает через транс-пакетные связи.
    - При любом обновлении баз M1/M4 необходимо обновлять все авто-права в M5.
    - Поэтому, в M5 обработчик ловит события "m1:afterupdate" и "m4:afterupdate".
    - Эти события являются уведомлениями от M1/M4 об очередном обновлении базы.
    - И запускает команду обновления C1_update.
    - В ней все существующие автоматические права мяго удаляются.
    - Затем данные извлекаются из M1/M4 через транс-пакетные связи.
    - И восстанавливается или создаётся полный набор access и exec прав.

  # Выключатель системы проверки автоматических прав
    - Присутствует выключатель системы проверки автоматических прав.
    - Он находится в параметре "privs_check_ison" конфига пакета.
    - Параметр принимает значения true / false.
    - Если выкл., состоянии права типов access и exec не проверяются.

  # Пароль: ограничение на min кол-во символов
    - Во время регистрации нового пользователя требуется указать пароль.
    - Можно установить ограничение на его минимальную длину в символах.
    - За это отвечает параметр "min_chars_in_pass" в конфиге.

  # Пароль: механизм восстановления пароля через email
    -

  # Пароль: механизм восстановления пароля через sms
    -

  # Пароль: защита механизма от брутфорса
    -

  # Верификация: общие принципы
    - При регистрации пользователя применяются 2 фактора аутентификации: email и phone.
    - Причём, email является обязательным, а phone - вспомогательным.
    - Однако, в некоторых сценариях регистрации, могут быть указаны не верные или чужие email/phone.
    - Чтобы этого избежать, требуется убедиться, что указанные email/phone действительно
      принадлежат этому пользователю.
    - Для этого и производится процесс верификации (подтверждения) email/phone.
    - В таблице пользователей есть отдельные колонки для хранения информации,
      верефицированы ли email и phone пользователя.

  # Верификация: процесс верификации email
    - В административном интерфейсе системы есть интерфейс для верификации email.
    - Он является составной частью интерфейса изменения свойств пользователя.
    - Однако, в каждом проекте можно на основе имеющихся команд организовать
      свой интерфейс верификации для пользователей.
    - Процесс верификации email проходит следующим образом:

      1) Формирование верификационного кода для пользователя
        - Формируется случайное число определённой длины.
        - Длина задаётся в конфиге параметром "verification_code_length" (4 по умолчанию).

      2) Запись кода в таблицу
        - В таблицу вер.кодов для email делается запись с этим числом.
        - Верификационные коды хранятся в таблице "md6_emailvercodes".

      3) Отправка кода пользователю по email
        - По email код пользователю отправляется
        - Действия 1,2,3 совершаются командой "C46_email_getcode".

      4) Введение пользователем кода из письма и нажатие кнопки "Верифицировать"
        - Пользователь делает сабж.
        - Система ищет соотв.вер.код для соотв.пользователя.
        - И проверяет, не истёк ли срок действия кода.
        - Срок действия задаётся в конфиге параметром "email_verify_code_lifetime_min" (15 мин. по умолчанию).

      5) Отметка в таблице пользователя о том, что email верифицирован
        - Если всё ОК, в поле "is_email_approved" соотв.пользователя вводится значение 1.
        - Действия 4,5 совершаются командой "C47_email_verify".

  # Верификация: процесс верификации phone
    - В административном интерфейсе системы есть интерфейс для верификации phone.
    - Он является составной частью интерфейса изменения свойств пользователя.
    - Однако, в каждом проекте можно на основе имеющихся команд организовать
      свой интерфейс верификации для пользователей.
    - Процесс верификации phone проходит следующим образом:

      1) Формирование верификационного кода для пользователя
        - Формируется случайное число определённой длины.
        - Длина задаётся в конфиге параметром "verification_code_length" (4 по умолчанию).

      2) Запись кода в таблицу
        - В таблицу вер.кодов для email делается запись с этим числом.
        - Верификационные коды хранятся в таблице "md7_phonevercodes".

      3) Отправка кода пользователю по SMS на phone
        - По SMS на phone код пользователю отправляется.
        - Действия 1,2,3 совершаются командой "C49_phone_getcode".

      4) Введение пользователем кода из SMS и нажатие кнопки "Верифицировать"
        - Пользователь делает сабж.
        - Система ищет соотв.вер.код для соотв.пользователя.
        - И проверяет, не истёк ли срок действия кода.
        - Срок действия задаётся в конфиге параметром "phone_verify_code_lifetime_min" (15 мин. по умолчанию).

      5) Отметка в таблице пользователя о том, что phone верифицирован
        - Если всё ОК, в поле "is_phone_approved" соотв.пользователя вводится значение 1.
        - Действия 4,5 совершаются командой "C50_phone_verify".

  # Верификация: автоочистка таблиц вер.кодов по расписанию
    - Если эти таблицы не очищать, то они рано или поздно сильно разрастутся.
    - Для их очистки предусмотрены команды "C52_email_cleartable" и "C53_phone_cleartable".
    - Они выполняются автоматически планировщиком Laravel каждый час.
    - Их задача: удалять устаревшие коды верификации из таблицы.
    - То есть те, разница "created_at" и "now" которых более
      "email_verify_code_lifetime_min" и "phone_verify_code_lifetime_min" из конфига.

  # Верификация: автоматическая верификация при входе через соц.сети
    - В топовых соц.сетях всегда производится верификация email/phone.
    - Поэтому, этим данным вполне можно доверять.
    - И на их основе ставить флаги верификации для email/phone пользователя.

  # Верификация: автоматическое удаление пользователей с не вериф.email и phone через N часов
    - К примеру, в нашем приложении разрешена свободная регистрация пользователей.
    - И пользователь может указать даже не принадлежащий ему email.
    - Это делается, чтобы он легко мог получить доступ к части фукнционала сайта,
      даже не проходя процедуру верификации.
    - Но что, если он займёт чей-то email, и законный владелец не сможет зарегистрироваться,
      потому что система будет ему писать, что такой email уже зарегистрирован?
    - Тогда можно в конфиге включить систему автоудаления пользователе с неверифицированным
      email через N часов.
    - Вкл/Выкл удаление можно в конфиге параметрами "del_users_with_not_ver_emails"
      и "del_users_with_not_ver_phones".
    - Указать, через сколько часов после создания удалять, можно в конфиге параметрами
      "del_users_with_not_ver_emails_in_hours" (по умолчанию 24 часа) и
      "del_users_with_not_ver_phones_in_hours" (по умолчанию 24 часа).
    - Команды "C54_delnotverifiedemail" и "C55_delnotverifiedphone" запускаются
      планировщиком Laravel каждый час.
    - Анонимный пользователь этими командами не удаляется.

  # Верификация: попытка зарегистрироваться с присутствующим, но не вериф.email/phone
    - Допустим, у нас уже есть пользователь с не верефицированным email.
    - И вдруг происходит попытка зарегистрировать нового польз-ля с таким email.
    - Сообщить о том, что этот email/phone уже занят.

  # Аутентификация: варианты
    - Каждый из вариантов аутентификации реализован в отдельной команде.
    - Какой вариант применять, на усмотрение разработчика соотв.проекта.
    - Варианты аутентификации:

      1) Аутентификация через email и пароль
        - Для аутентификации нужен email и пароль.

      2) Аутентификация через email и код
        - Для аутентификации нужен email и код.
        - Код аутентификации приходит по email по запросу.
        - Действие кода аутентификации ограничено значением из конфига в мин.

      3) Аутентификация через phone и пароль
        - Для аутентификации нужен phone и пароль.

      4) Аутентификация через phone и код
        - Для аутентификации нужен phone и код.
        - Код аутентификации приходит по sms по запросу.
        - Действие кода аутентификации ограничено значением из конфига в мин.

      5) Классическая двухэтапная аутентификация
        - Для аутентификации нужен email, пароль и код.
        - Код приходит по sms по запросу.

  # Аутентификация: настройка времени жизни в зависимости от групп
    - Пакет позволяет гибко настроить время жизни в минутах.
    - Глобальное значение можно указать в параметре "auth_cookie_lifetime_global".
    - Локальные значения (для групп) можно указать в "auth_cookie_lifetime_locals".
    - Пользователь может состоять 0, 1 или одновременно в нескольких группах.
    - В любом случае, используется MIN значение (глобальное тоже берётся в расчёт).
    - Как конкретно будет использовано итоговое значение времени жизни:

      1) Для задания времени жизни аутентификационных кук.
      2) Для поиска действующих аутентификаций в аутентификационной таблице.
        - Будет браться текущее время, время создания записи в таблице.
        - И вычисляться их разница путём вычитания первого из второго.
        - Если разница больше заданного времени жизни, запись считается не валидной,
          и подлежит удалению.
      3) Для задания времени жизни аутентификационного кэша
        - В течение оставшегося до конца времени жизни времени.

  # Аутентификация: таблица аутентификаций, возможность множественных аутентификаций

    • Про "плохие" решения и невозможность одновременной аутентификации в них
      - В "плохих" решениях отдельная таблица аутентификаций не используется.
      - Вместо этого в таблице пользователей под "код" выделяется отдельный столбец.
      - В итоге нельзя одновременно войти в аккаунт с двух разных устройств.
      - Последний вход будет приводить к выходу предыдущего входа.

    • Решение описанной проблемы: таблица аутентификаций
      - Для каждого акта аутентификации в этой таблице создаётся отдельная запись.
      - Эта запись через n:m связь связана с соотв.пользователем в таблице пользователей.
      - Для каждого пользователя таких записей м.б. от 0 и более.
      - В нашем решении в кач-ве таблицы аутентификаций используется "m5.md8_auth".

  # Аутентификация: аутентификационный кэш в сессии

    • Проблема и решение
      - Представим, что пользователь аутентифицировался, и имеет аутентиф.куку.
      - Пользуясь приложением, он снова и снова отправляет GET и POST запросы к нему.
      - Было бы накладно каждый раз дёргать базу и лезть в таблицу аутентификаций.
      - Поэтому, для каждой записи в табл.аутентификаций делается запись и в сессионный кэш.

    • Сколько живёт сессия
      - Сессия же живёт лишь до закрытия пользователем браузера.
      - Это задаётся в конфиге сессий Laravel.

    • Ключ и значение для сессионных аутинтификационных кук
      - Эти же данные присутствуют в зашифрованной аутентификационной куке.
      - Ключ строится по шаблону: "auth_cache".
      - В качестве значения записывается не зашифрованная аутентификационная json-строка.

  # Аутентификация: описание процесса после ввода аутентиф.данных

    1) Создание новой записи в таблице аутентификаций
      - Создаётся новая запись.
      - Эта запись связывается с соотв.пользователем из таблицы пользователей.

    2) Формирование json-строки и её шифровка
      - Этот json должен содержать 2 поля на верхнем уровне: "user" и "auth".
      - В поле "user" модель пользователя, в поле "auth" модель аутентиф.записи.
      - Эта json-строка шифруется стандартными средствами Laravel.

    3) Запись пользователю аутентификационной куки
      - Сформированная в 2 строка записывается в аутентиф.куку пользователю.
      - Имя аутентификационной куки: "auth".
      - Время жизни куки определяются соотв.настройками из конфига.

    4) Запись аутентификационного кэша для аутентиф.записи и пользователя
      - Описанным выше образом создаётся аутентификационный кэш.

  # Аутентификация: описание процесса распознавания аутентифицированных пользователей
    - Распознавание производится в BeforeMiddleware пакета M5, командой C56_meet.
    - Итог распознавания всегда один: кэш в сессии, кука и пропуск запроса дальше из middleware.
    - Вот схема этого процесса и работы C56_meet наглядно:

                                          |
                                          |
                                         \|/
                                    |------------|
                                    |  Ищем      | Если находится, то запрос пропускается дальше из middleware
                                    |  аутентиф. |------------------------------------------------------------->
                                    |  кэш       |
                                    |  в сессии  |
                                    |------------|
                                          |
                                          | Кэш не найден
                                         \|/
                                    |---------------|
                                    | Ищем валидную |
                                    | аутентиф.куку |
                                    |---------------|
                                          /   \
                              Не найдена /     \ Найдена
                                        /       \
                                       /         \
                                      /           \
                                     /             \
                                   \|/            \|/
                          |---------------|    |---------------|
                          | Ищем аноним.  |    | Ищем валидную |
                          | пользователя  |<---| аутентиф.     |
                          | в таблице     | Н  | запись в      |
                          | users         | Е  | таблице auth  |
                          |---------------| Т  |---------------|
                          /                                   \
                         /                                     \
                        /                                       \
                       /                                         \
                      /                                      |-----------------------------|
                     /                                       | Да?                         |
                    /                                        | Записывается кука.          |
              |-----------------------------|                | Записывается кэш в сессию.  |
              | Нет? Будешь мр.Инкогнито.   |                | Запрос пропускается дальше. |
              | Да? Будешь анонимом.        |                |-----------------------------|
              |                             |
              | Записывается кука.          |
              | Записывается кэш в сессию.  |
              | Запрос пропускается дальше. |
              |-----------------------------|


  # Аутентификация: через социальные сети
    ??? Предварительные данные

    - Надо регистрировать сайт в соотв.соц.сетях, и получить токены.
    - В конфиге нужно сделать для каждой соц.сети свой набор параметров.
    - С помощью get/post запроса к соц.сетям можно получать данные пользователя.
    - По этим данным можно:
      1) Зарегистрировать этого пользователя, если он ещё не зарегистрирован.
      2) Аутентифицировать его, если он уже зарегистрирован.
      3) Подтвердить его email и телефон, если они ещё не подтверждены.
    - Для работы через laravel можно использовать Laravel Socialite.

    ???

  # Аутентификация: выход
    - Что происходит при выходе пользователя:

      1) Удаляется весь аутентификационный кэш пользователя.
      2) Удаляются все его аутентификации из таблицы аутентификаций.

  # Аутентификация: блокировка пользователя
    - Что происходит с аутентификацией при блокировке пользователя?
    - Производится операция "выход".

  # Аутентификация: изменение "email" / "phone" / "пароля" пользователя
    - Что происходит с аутентификацией при изменении данных пользователя.
    - Производится операция "выход".

  # Аутентификация: где происходит распознавание, как данные передаются клиенту

    • Аутентификация реализуется в BeforeMiddleware пакета M5
    • Данные об аутентиф.пользователе сохраняются в сессии
      - Они сохраняются туда с ключём auth.
      - А сессия живёт до закрытия браузера.
      - Данными в сессии может быть одно из 3-ёх:

        1) Пользователь
          - В сессии сохраняется json с моделью этого пользователя.
          - В get-запросе данные из сессии передаются клиенту.
          - В post-запросах данные из сессии используются для авторизации.

        2) Анонимный пользователь
          - В сессии сохраняется json с моделью этого пользователя.
          - В get-запросе данные из сессии передаются клиенту.
          - В post-запросах данные из сессии используются для авторизации.
          - При этом пользователю показываем, что он не аутентифицирован.

        3) Отсутствие данных
          - В сессии сохраняется пустая строка.
          - В get-запросе пустые данные из сессии передаются клиенту.
          - В post-запросах пустые данные из сессии используются для обозначения
            отсутствия каких-либо прав.
          - При этом пользователю показываем, что он не аутентифицирован.








  # Механизм восстановления пароля
    - Восстановление пароля происходит по стандартной схеме.
    - Пользователь через интерфейс вводит email и запрашивает восстановление.
    - Генерируется секретный код, и записывается в спец.таблицу в БД.
    - В этой таблице есть datetime-стобец expire, где указано время истечения кода.
    - Время действия кода в минутах можно указать в параметре "common_pass_recovery_code_lifetime".
    - Система формирует URL с кодом в query string и посылает пользователю.
    - URL формируется на основе значения из параметра "common_url_auth_doc".
    - Если пользователь кликает поссылке до expire, ему формируется новый пароль.

  # Защита от брутфорса
    - Пакет имеет встроенную систему от брутфорса - взлома пароля перебором.
    - Её можно вкл./выкл. с помощью параметра "bruteforce_protection_ison".
    - Как работает:

        После "bruteforce_protection_threshold" неудачных попыток аутентификации
        за "bruteforce_protection_counter_lifetime" минут, с каждой последующей
        попыткой механизм аутентификации для этого пользователя блокируется
        на "bruteforce_protection_delay" * X, где X - кол-во неудачных попыток
        аутентификации за указанное время, минус "bruteforce_protection_threshold".

    - Механизм делает попытки взломать пароль брутфорсом бессмысленными.

  # Настройка времени жизни аутентификационной куки
    - Пакет позволяет гибко настроить время жизни в минутах.
    - Глобальное значение можно указать в параметре "auth_cookie_lifetime_global".
    - Локальные значения (для групп) можно указать в "auth_cookie_lifetime_locals".
    - Пользователь может состоять 0, 1 или одновременно в нескольких группах.
    - В любом случае, используется MIN значение (глобальное тоже берётся в расчёт).

  # Настройка переадресации после входа
    - То есть, настройка куда попадает пользователь после аутентификации.
    - Можно указать глобально url для переадресации в "redirect_global_url".
    - Но он не действует, если включить глобально механизм переадресации на ref-url.
    - Он включается / выключается в параметре "redirect_global_ref_ison".
    - Это такое общее правило, оно работает и на глобальном, и на локальных уровнях.
    - В "redirect_local_urls" можно локально указать url'ы для групп.
    - Если пользователь состоит в нескольких, берётся первое вхождение, начиная с глобального.
    - В "redirect_local_ref_ison" можно вкл./выкл. переадресацию на ref-url локально для базовых URL.

  # Настройка столбцов, которые можно использовать в качестве логина
    - В теории, в качестве логина можно использовать любой столбец.
    - Главное, чтобы у этого столбца был unique-индекс.
    - Пакет позволяет указать список таких столбцов.
    - Настроимть этот список можно в параметре "logins".

  # Настройка факторов и сценариев аутентификации
    - По умолчанию поддерживается 3 фактора аутентификации:
    - Их список находится в параметре "authfactors":

      1) password         // с помощью пароля
      2) sms              // через смс
      3) phrase           // вопрос - ответ (кодовая фраза)

    - Пакет позволяет настраивать сценарии аутентификации.
    - Глобальный сценарий можно указать в "authfactors_scenario_global".
    - Локальные сценарии для групп в "authfactors_scenarios_local".
    - Подробно сценарии аутентификации описаны в конфиге.

  # Настройка SMS-аутентификации
    - Длину пароля и набор символов можно указать в "smsauth_length" и "smsauth_charset".
    - Можно ограничить max кол-во смс в "smsauth_smslimit", отправляемых
      за время жизни счётчика "smsauth_counter_lifetime".
    - Последнее обновляется после каждой отправки смс.
    - Это ограничение позволит защититься от атак на наш счёт у смс-провайдера.

  # Настройка аутентификации через секретную фразу
    - Можно ограничить MIN длину ответа в символах параметром "phraseauth_length".


```
## Функционал <a id="link4"></a>
```

  # Команды и к.команды #
  #---------------------#

    Команда           К.Команда               Описание
    ----------------------------------------------------------------------------------------------------------------------
    update            m5:update               Fires m5:call4update event, gets data from M1/M4, updates DB of M5
    switch            m5:switch               Turn on / Turn off the system access restrictions
    checkanon         m5:checkanon            Check whether an anonymous user in the system
    checkadmins       m5:checkadmins          Check whether admins in the system
    getuserprivs      m5:getuserprivs         Get all user privileges, taking into account personal and privileges of groups, where user consists
    getgroupprivs     m5:getgroupprivs        Get all group privileges
    users             m5:users                Get users list (can use filters)
    groups            m5:groups               Get groups list (can use filters)
    privileges        m5:privileges           Get get privileges list (can use filters)
    tags              m5:tags                 Get tags list (can use filters)
    -                 m5:new                  Create a new user / group / privilege / tag
    newuser           -                       Create a new user
    newgroup          -                       Create a new group
    newprivilege      -                       Create a new privilege
    newtag            -                       Create a new tag
    -                 m5:del                  Delete a user / group / privilege / tag
    deluser           -                       Delete a user
    delgroup          -                       Delete a group
    delprivilege      -                       Delete a privilege
    deltag            -                       Delete a tag
    -                 m5:change               Change a user / group / privilege / tag
    changeuser        -                       Change a user
    changegroup       -                       Change a group
    changeprivilege   -                       Change a privilege
    changetag         -                       Change a tag
    -                 m5:restore              Restore a user / group / privilege / tag
    restoreuser       -                       Restore deleted user
    restoregroup      -                       Restore deleted group
    restoreprivilege  -                       Restore deleted privilege
    restoretag        -                       Restore deleted tag
    -                 m5:attach               Attach one entity to another
    attachuser        -                       Attach a user to a group
    attachprivilege   -                       Attach a privilege to a user / group
    attachtag         -                       Attach a tag to a user / group / privilege
    -                 m5:detach               Detach one entity from another
    detachuser        -                       Detach a user from a group
    detachprivilege   -                       Detach a privilege from a user / group
    detachtag         -                       Detach a tag from a user / group / privilege



  # Обработчики событий #
  #---------------------#

    Обработчик        Ключи                   Описание
    ----------------------------------------------------------------------------------------------------------------------
    H1_update         m1:afterupdate          Calls c.command m5:update, which invokes update of DB of M5
                      m4:afterupdate


```
## Схемы взаимодействий с другими пакетами <a id="link5"></a>
```

  # Pull-взаимодействия (по инициативе этого пакета) #
  #--------------------------------------------------#

    ---------------------------------------------------------------------------------------------
    Пакет     Команда     К.Команда     Обработчик      Событие           Комментарий
    ---------------------------------------------------------------------------------------------

      -

  # Push-взаимодействия (по инициативе других пакетов) #
  #----------------------------------------------------#

    ---------------------------------------------------------------------------------------------
    Пакет     Команда     К.Команда     Обработчик      Событие           Комментарий
    ---------------------------------------------------------------------------------------------

      -

```
## Кэширование <a id="link7"></a>
```





```
## Заметки к релизам <a id="link100"></a>
```

  1.0.0
    - Первый релиз.

```










