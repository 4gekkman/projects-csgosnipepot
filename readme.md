# M1 - Управление Приложением (master)
---
## Оглавление

  - [Ссылки](#link1)
  - [Введение](#link2)
  - [Система управления бэкендом: теория](#link3)
  - [Система управления фронтендом: теория](#link4)
  - [Прикладные инструкции по работе с СУБ и СУФ](#link5)
	- [Функционал](#link6)
	- [Схемы взаимодействий с другими пакетами](#link7)
	- [Установка, обновление, удаление](#link8)
  - [Заметки к релизам](#link100)

---

## Ссылки <a id="link1"></a>
```

  > Адрес репозитория пакета М1 на github
      https://github.com/4gekkman/M1

	
			
```

## Введение <a id="link2"></a>
```

  • Это М-пакет для управления приложением.
  • В нём сосредоточен весь соответствующий функционал.
  • Он является корневым для всего приложения.
  • Без него приложение не будет функционировать корректно.
  • Но это не значит, что остальные М-пакеты зависят от этого.
  • Они могут с успехом работать и без него.
  • Однако, это будет в 100 раз менее удобно, чем с этим М-пакетом.

 
```
## Система управления бэкендом: теория <a id="link3"></a>
```
---------------------------------------
Подоглавление:

  - Аббревиатура СУБ
  - Что умеет СУБ

    • Парсить приложение (C1_parseapp)
    • Синхронизировать регистрации сервис-провайдеров пакетов приложения (C2_sp_regs_update)
    • Публиковать ресурсы зарегистрированных пакетов приложения (C3_allrespublish)
    • Устанавливать / Обновлять базы данных M-пакетов приложения (C4_m_dbs_update)
    • Создавать новый релиз указанного пакета на github (C32_release)
    • Обновлять конфиги M,D,L,W-пакетов (C33_mdlw_cfgs_update)
    • Синхронизировать задания пакетов приложения для планировщика (C35_m_schedules_update)
    • Синхронизировать модели указанного пакета с его БД (C36_workbench_sync)
    • Осуществлять очистку pivot-таблиц оборванных межпакетных взаимодействий (C38_clear_interpack_rels)
    • Создавать и удалять все типы пакетов и их ресурсов

  - Межпакетные связи между базами данных M-пакетов

    • Введение в проблемы
    • Решение всех проблем
    • Кейсы

  - Подробнее о работе с конфигами пакетов

    • Конфиги публикуются для M,D,L,W-пакетов
    • Как публикуются конфиги
    • Как обновляются конфиги
    • Примеры работы с конфигами

  - Локализация пакетов

    • Общая информация о локализации пакетов
    • Глобальная локализация
    • Локальная локализация
    • Локализация в M,D,L,W-пакетах
      ▪ Основная информация
      ▪ Как пользоваться
    • Как получить локаль в клиенте

  - Подробнее о работе с базами данных M-пакетов

    • Суть работы с БД M-пакетов
    • Когда происходит обновление БД M-пакета
    • Ведение истории обновление БД M-пакета в конфиге

  - События Event и Broadcast

    • Общая информация об архитектуре событий приложения
    • Событие Event
    • Событие Broadcast

  - Пространства имён пакетов

    • Общая информация о пространствах имён пакетов
    • Пространство имён указывается в composer.json пакета
    • Пространство имён для разрабатываемых пакетов

  - Какие типы пакетов бывают у вендора 4gekkman

    • M-пакет
    • D-пакет
    • L-пакет
    • W-пакет
    • R-пакет

  - Возможные взаимные схемы зависимостей для пакетов разных типов

---------------------------------------

# Аббревиатура СУБ
  - Система управления бэкендом.
  - Будем называть её СУБ здесь и далее.

# Что умеет СУБ

  • Парсить приложение (C1_parseapp)
    - Команда парсит все пакеты приложения, их типы, ресурсы.
    - Как бы делает слепок текущего состояния приложения.
    - И сохраняет все эти результаты в базу данных пакета M1.

  • Синхронизировать регистрации сервис-провайдеров пакетов приложения (C2_sp_regs_update)
    - Обычно при установке пакетов надо добавлять их сервис-провайдеры в конфиг app.php.
    - При установке/удалении пакетов приложения, эта команда делает всё за тебя.
    - Это относится не ко всем пакетам, а лишь к пакетам вендора 4gekkman.

  • Публиковать ресурсы зарегистрированных пакетов приложения (C3_allrespublish)
    - У пакетов приложения есть различные ресурсы, которые требуется опубликовать.
    - Эта команда публикует все подобные ресурсы разом.

  • Устанавливать / Обновлять базы данных M-пакетов приложения (C4_m_dbs_update)
    - Большинство M-пакетов имеют свои базы данных.
    - При установке пакетов эти базы данных требуется устанавливать.
    - А при обновлении пакетов эти БД может потребоваться обновлять.
    - Всё это делает за тебя данная команда.
    - Это относится не ко всем пакетам, а лишь к пакетам вендора 4gekkman.

  • Создавать новый релиз указанного пакета на github (C32_release)
    - Эта команда позволяет создать новый релиз пакета на github.
    - Однако, она не закачивает туда свежую версию пакета.

  • Обновлять конфиги M,D,L,W-пакетов (C33_mdlw_cfgs_update)
    - Все пакеты имеют свои конфиги в configs.
    - Эти конфиги обычно не изменяются при обновлениях пакетов.
    - Однако, их всё же иногда при обновлениях требуется обновлять.
    - Эта команда автоматически это делает.
    - Это относится не ко всем пакетам, а лишь к пакетам вендора 4gekkman.

  • Синхронизировать задания пакетов приложения для планировщика (C35_m_schedules_update)
    - Laravel не позволяет определять задания для планировщиков в сервис-провайдерах пакетов.
    - Однако, с помощью данной команды, ты можешь это делать.
    - Она автоматически выполняет всю необходимую работу.

  • Синхронизировать модели указанного пакета с его БД (C36_workbench_sync)
    - Эта команда позволяет за секунды создать все необходимые модели для M-пакета.
    - Она парсит существующую структуру БД указанного M-пакета.
    - И на её основе создаёт необходимые модели.

  • Осуществлять очистку pivot-таблиц оборванных межпакетных взаимодействий (C38_clear_interpack_rels)
    - БД M-пакетов могут быть объединены межпакетными m:n связями.
    - В соответствующей pivot-таблице накапливаются данные.
    - В случае обрыва связи эти данные становятся не валидными.
    - Данная команда автоматически очищает pivot-таблицу в этом случае.

  • Создавать и удалять все типы пакетов и их ресурсов
    - Это CLI-приложение по управлению ресурсами приложения.
    - Оно позволяет через CLI-интерфейс создавать/удалять пакеты и их ресурсы.

# Межпакетные связи между базами данных M-пакетов

  • Введение в проблемы

    1) Хранение межпакетных данных
      - В M4 есть таблица MD1_routes.
      - В M1 есть таблица MD2_packages.
      - Приложению нужны связи между роутами и пакетами.
      - Оно хочет знать для каждого пакета, с какими роутами он связан.
      - Оно хочет знать для каждого роута, с какими пакетами он связан.
      - Для этой связи требуется наличие pivot-таблицы.
      - Но где её хранить?

    2) Обеспечение наличия связей в моделях
      - M1 и M4 полностью независимы друг от друга.
      - И могут как присутствовать в системе, так и отсутствовать.
      - Если оба присутствуют, связи в соотв.моделях должны быть.
      - Если оба отсутствуют, связей с воотв.моделях быть не должно.

    3) Безопасный запрос данных из БД другой модели
      - M4 может потребоваться запросить из M1 данные.
      - Это можно сделать через событие, но это не удобно.
      - При прямом запросе, если M4 не будет в системе, будет error.

    4) Очистка pivot-таблицы в зависимом M-пакета
      - Сначала M1 и M4 могут присутствовать в системе.
      - В pivot-таблице их связи в M4 могут накапливаться данные.
      - Потом M4 может быть удалена вместе с БД.
      - А потом M4 может быть установлена заново, вместе с БД.
      - На этом этапе, данные в pivot в M4 уже являются неверными.
      - Их следует удалить.

  • Решение всех проблем

    1) Хранение межпакетных данных
      - Эти данные хранятся в базе зависящего M-пакета.
      - То есть того, кому нужны данные от связанного M-пакета.
      - Они хранятся в pivot-таблице с именем "/^md200[0-9]{1}$/"
      - В этом M-пакете, связанная таблица должна быть связана
        с этой pivot-таблицей как обычно, 1:n связью
      - Pivot-таблица должна находиться на жёлтой плашке "Foreign".
      - На плашке также должен присутствовать текстовый комментарий.
      - В description таблицы должна быть json-строка с информацией:

          {
            "mpackid":"M1",           // С каким M-пакетом связь
            "table":"MD2_packages",   // С какой таблицей в этом M-пакете связь
            "version":">=1.0"          // Требуемая версия М-пакета
          }

      - Эта инфа будет использована для авто-создания связей в моделях.
      - Доступ к этим данным можно осуществлять с помощью такого запроса:

          DB::select("SELECT table_comment FROM INFORMATION_SCHEMA.TABLES WHERE table_schema='m4' AND table_name='md2000'");

    2) Обеспечение наличия связей в моделях
      - При каждом afterupdate производится обновление моделей и связей.
      - За это отвечает специальная команда C36_workbench_sync.
      - Она вставляет межпакетные связи в обе связанные модели
        лишь в том случае, если оба пакета/базы, модели/таблицы в наличии.
      - Перед использованием, всегда надо проверять наличие
        метода-связи в классе-модели.

          method_exists("\M4\Models\MD1_routes", "m1_packages")

      - Межпакетная связь имеет префикс в виде id_inner того
        M-пакета, с которым связь. Например: "m1_packages".

    3) Безопасный запрос данных из БД другой модели

      • Безопасный запрос через r1_query
        - Осуществляется через хелпер r1_query.
        - Он принимает callback с запросом.
        - Применяет его через try .. catch.
        - С случае успеха возвращает коллекцию.
        - В случае неудачи возвращает NULL.
        - Пример:

            $packages = r1_query(function(){
              return \M1\Models\MD2_packages::whereHas('packtypes', function($query){
                $query->whereIn('name', ["D", "L", "W"]);
              })->get();
            });

      • Проверка наличия связи через r1_rel_exists
        - Проверить наличие связи можно хелпером r1_rel_exists.
        - Первый аргумент: название M-пакета, связь в котором надо проверить.
        - Второй аргумент: название таблицы в БД, связь для которой надо проверить.
        - Третий аргумент: название связи, существование которой надо проверить.
        - Пример:

            if(r1_rel_exists("M5", "MD3_privileges", "m1_packages")) {
              $privilege->m1_packages()->attach($package->id);
            }

    4) Очистка pivot-таблицы в зависимом M-пакете
      - Осуществляется отдельной командой C38_clear_interpack_rels.
      - Эта команда выполняется при каждом afterupdate.
      - Ищет md200* в существующих M-пакетах.
      - Проверяет присутствие M-пакетов/БД и моделей/таблиц,
        с которыми md200* должны быть связаны.
      - В случае отсутствия, делает truncate для этой md200*.

  • Кейсы

    1) Межпакетная связь между M4 и M1

      Описание
      --------
        - Роуты должны быть связаны с D,L,W-пакетами.
        - Иначе им не узнать адреса контроллеров, куда
          направлять соответствующие запросы.
        - Поэтому, в модели M4 создаётся новая foreign-связь.
        - Создаётся таблица md2000, с полями id_route и id_package.
        - Её связывают 1:n связью с таблицей роутов.
        - В её description прописывают метаданные для автосоздания связей.

      Связанные модели
      ----------------
        \M1\Models\MD2_packages
        \M4\Models\MD1_routes

      Использование r1_routes
      -----------------------
        - При создании роута пользователю надо дать выбор.
        - С каким D,L,W-пакетом требуется связать этот роут.
        - Для этого, надо запросить список id_inner всех их.
        - Это необходимо делать с помощью r1_routes.
        - Если r1_routes вернёт NULL, сообщить пользователю,
          что доступных для связи пакетов нет.
        - И пожаловаться по этому поводу в лог приложения.

      Сохранение/Извлечение данных из md2000
      --------------------------------------
        - При создании нового роута, он связывает с пакетом.
        - При удалении роута, все его связи с пакетами удаляются.
        - Перед Attach / Detach присутствие связи проверяется
          спомощью метода method_exists.
        - Если связи нет, то Attach / Detach не выполняются.
        - Всё равно это означает, что pivot-таблица уже очищена.
        - В случае отсутствия связей, пожаловаться в лог приложения.

      Очистка md2000 при удалении M1
      ------------------------------
        - Допустим, произошло удаление M1 правильным способом.
        - Выполняется afterupdate, и C38_clear_interpack_rels.
        - Таблица md2000 полностью очищается.

    2) Межпакетная связь между M5 и M1

      Описание
      --------
        - Права должны быть связаны с пакетами и командами.
        - Это позволит автоматически создавать права типов
          "access" и "exec".
        - Поэтому, в модели M5 создаются 2 новых foreign-связи.
        - Создаётся таблица md2000, с полями id_privilege и id_package.
        - Создаётся таблица md2001, с полями id_privilege и id_command.
        - Их связывают 1:n связями с таблицей прав.
        - В их description прописывают метаданные для автосоздания связей.

      Связанные модели
      ----------------
        \M1\Models\MD2_packages <---> \M5\Models\MD1_privileges
        \M1\Models\MD2_packages <---> \M5\Models\MD5_commands

      Использование r1_routes
      -----------------------
        - Применяется при создании автоматических прав.
        - Для этого требуется извлечь все D,L,W-пакеты и
          все команды.
        - Если r1_routes вернёт NULL, использовать пустую коллекцию.
        - И пожаловаться по этому поводу в лог приложения.

      Сохранение/Извлечение данных из md2000 и md2001
      -----------------------------------------------
        - Создание / Удаление права происходит лишь на основе
          данных, извлечённых r1_routes из M5.
        - Если r1_routes вернёт NULL, то создавать автоматические
          права будет не для кого.
        - И это означает, что pivot-таблица уже очищена.
        - В случае отсутствия связей, пожаловаться в лог приложения.

      Очистка md2000 при удалении M1
      ------------------------------
        - Допустим, произошло удаление M1 правильным способом.
        - Выполняется afterupdate, и C38_clear_interpack_rels.
        - Таблица md2000 полностью очищается.

# Подробнее о работе с конфигами пакетов

  • Конфиги публикуются для M,D,L,W-пакетов
    - У них есть в структуре файлы settings.php

  • Как публикуются конфиги
    - У каждого из этих пакетов есть сервис провайдер.
    - В нём прописана публикация конфигов в /config
    - Имя конфига каждого пакета равно имени его ID.
    - Например: D1.php, W1.php, M1.php, и т.д.
    - Публикация производится вместе со всеми остальными ресурсами.
    - Если режим development mode включен, то при каждом запросе и allrespublish.
    - Если выключен, то только при каждом allrespublish.

  • Как обновляются конфиги
    - Речь ниже пойдёт, разумеется, тольк о M,D,L,W-пакетах.
    - У каждого из них есть каталог файлами:

      /Cnfupds
        cfgupdate_1.php    // Это Laravel-команда
        cfgupdate_2.php    // Это Laravel-команда
        ...

    - Каждый файл содержит код для обновления конфига пакета.
    - И у каждого в конфиге есть массив "cnfupdshistory".
    - Также имеется команда С33_mdlw_cfgs_update и
      консольная команда T11_mdlw_cfgs_update.
    - Команда С33 выполняется при запуске к.команды m1:afterupdate.
    - Она извлекает содержимое cnfupdshistory.
    - cnfupdshistory может содержать возрастающую последовательность
      цифр типа ['1','2','3'] и так далее.
    - Далее, она извлекает массив цифр из имён файлов из Cnfupds.
    - Если в cnfupdshistory нет цифры для каких либо файлов,
      то с команда с помощью exec выполняет (в порядке возрастания)
      код из этих файлов. И записывает их цифры-имена в cnfupdshistory.

  • Примеры работы с конфигами

    Общие вводные
    -------------
      - В /Cnfupds уже 3 файла: cfgupdate_1.php, cfgupdate_2.php, cfgupdate_3.php
      - Массив cnfupdshistory: ['1','2','3'].

    Сценарий 1 - установка с нуля
    -----------------------------
      - В /config записывается новый конфиг пакета.
      - Никакие файлы из /cnfupds не устанавливаются.
      - Всё ОК.

    Сценарий 2 - установка на ['1']
    -------------------------------
      - Пакет был установлен ранее, конфиг уже опубликован.
      - Массив cnfupdshistory: ['1'].
      - Команда C33 выполняет сначала 2.php, затем 3.php.
      - И записывает cnfupdshistory: ['1','2','3'].

# Локализация пакетов

  • Общая информация о локализации пакетов
    - Лучше сразу делать приложение с возможностями локализациями.
    - Наверняка потребуется разрабатывать приложение для пользователей,
      разговаривающих на разных языках.
    - За основу следует взять 2 языка, RU и EN.
    - Всё приложение должно "из коробки" поддерживать эти языки.

  • Глобальная локализация
    - В конфиге /config/app.php есть опция "locale".
    - Это и есть параметр локализации всего приложения.
    - По умолчанию, все пакеты ориентируются именно на неё.

  • Локальная локализация
    - Доступна для M,D,L,W-пакетов.
    - В конфигах M,D,L,W-пакетов также есть опция locale.
    - По умолчанию, для неё доступны 2 значения:
      "RU", "EN".
    - По умолчанию, везде стоит значение "".
    - Это означает, что надо использовать глобальную локаль.

  • Локализация в M,D,L,W-пакетах

    ▪ Основная информация
      - Файлы локализации всего приложения лежат в /resources/lang/*
      - У каждого M,D,L,W-пакета есть каталог /Localization:

          /Localization
            /en
              localization.php
            /ru
              localization.php

      - Публикация файлов-локализаций производится в сервис-провайдерах
        этих пакетов.
      - Они публикуются в /resources/lang, в каталоге /ru, /en и т.д.
      - Файлы локализации переименовываются в ID D,L,W-пакета.
      - Допустим, при публикации файлов локализации пакета D1:

          /resources
            /lang
              /ru
                D1.php
              /en
                D1.php

    ▪ Как пользоваться
      - С помощью php-хелпера trans.
      - Например, в D1 есть фраза с ключём "welcome".
      - А пакет D1 использует глобальную локаль (она EN).
      - Тогда, извлечь фразу с ключём "welcome" можно
        так:
          trans('en.d1.welcome')        // где-нибудь в контроллере D1
          {{ trans('en.d1.welcome') }}  // где-нибудь в представлении D1

    ▪ Как получить локаль в клиенте
      - Локаль всегда передаётся контроллером пакета клиенту.
      - Это происходит при формировании ответа на get-запрос.
      - Локаль формируется хелпером r1_get_doc_locale по ID пакета.


# Подробнее о работе с базами данных M-пакетов

  • Суть работы с БД M-пакетов
    - У каждого M-пакета есть каталог Database.
    - В нём должны лежать файлы *.sql.
    - В качестве имён должны быть использованы цифры >= 1.
    - Нумерация должна начинаться с 1, с инкрементацие по 1.
    - Например: 1.sql, 2.sql, 3.sql.
    - Файл 1.sql содержит sql для установки начальной БД модуля.
    - Файлы с именем >= 2 - это sql для обновления БД модуля.
    - Также, в Database лежит .mwb файл с workbench-моделью модуля.
    - Вот как это всё выглядит (пример):

      /Database
        model.mwb
        1.sql
        2.sql
        3.sql

  • Когда происходит обновление БД M-пакета
    - Обновление производит скрипт из M1.
    - Который выполняется при каждом composer update.

  • Ведение истории обновление БД M-пакета в конфиге
    - Нельзя при каждом composer update выполнять все sql-файлы.
    - Так можно легко потерять важные данные.
    - Например, при таком раскладе, при каждом composer update
      все данные из таблицы m1.table будут теряться:
        1.sql - создать таблицу m1.table
        2.sql - удалить таблицу m1.table
        3.sql - создать таблицу m1.table
    - Чтобы этого не происходило, скрипту требуется знать,
      какие .sql файлы для модуля уже были ранее выполнены.
    - Эти данные записываются в файле настроек модуля в config/*
    - У каждого M-пакета в конфиге есть свойство "updateshistory".
    - Оно должна содержать массив цифр, обозначающих имена .sql файлов.
    - Это означает, что соотв. .sql-обновления уже были применены,
      и выполнять их повторно не требуется.

        'updateshistory' => [1,2,3],

# События Event и Broadcast

  • Общая информация об архитектуре событий приложения
    - Архитектура приложения подразумевает наличие лишь 2-х событий.
    - Это события Event (обычное) и Broadcast (трансляция).
    - Эти 2-ва события определены в пакете R2.

  • Событие Event
    - Принимает массив агрументов $data.
    - В нём можно передавать обработчику необходимые данные.
    - Один элемент - с ключём "keys" - является обязательным.
    - Он содержит массив строк-ключей.
    - Каждый обработчик реагирует только на определённые ключи.
    - Если в keys есть хотя бы 1 такой ключ, обработчик среагирует.

  • Событие Broadcast
    - Принимает массив агрументов $data.
    - В нём можно передавать обработчику необходимые данные.
    - Один элемент - с ключём "channels" - является обязательным.
    - Он содержит массив строк-каналов.
    - Клиенты-подписчики реагируют на сообщения лишь по определёным каналам.
    - По аналогии, как обработчики реагируют лишь на определнные ключи.

# Пространства имён пакетов

  • Общая информация о пространствах имён пакетов
    - Каждый пакет имеет своё пространство имён.
    - Имя пр.имён совпадает с ID пакета (напр.: M1, D1, L1, ...).

  • Пространство имён указывается в composer.json пакета
    - Например, есть у нас пакет M1.
    - В его composer.json указываем пр.имён:

      "autoload": {
        "psr-4": {"M5\\": ""}
      }

  • Пространство имён для разрабатываемых пакетов
    - Указывается в composer.json всего проекта.
    - Аналогичным образом, как и в composer.json пакета.

# Какие типы пакетов бывают у вендора 4gekkman

  • M-пакет
    - Имя M-пакета образуется по шаблону: M[целая цифра от 1 и выше]
    - Это пакеты с бэкенд-логикой.
    - Почти все M-пакеты имеют свою отдельную одноимённую базу данных.
    - Имеет строгую базовую структуру.

  • D-пакет
    - Это пакет, представляющий один фронтенд-blade-документ, и всё, что с ним связано.
    - Его контроллер, ресурсы, зависимости, локализация, и прочее.
    - Имеет строгую базовую структуру.
    - Имеет свой отдельный контроллер со своим URL для доступа к HTTP-API.

  • L-пакет
    - Это пакет, представляющий один фронтенд-blade-шаблон, и всё, что с ним связано.
    - Его контроллер, ресурсы, зависимости, локализация, и прочее.
    - Имеет строгую базовую структуру.
    - Имеет свой отдельный контроллер со своим URL для доступа к HTTP-API.

  • W-пакет
    - Это пакет, представляющий один фронтенд-blade-виджет, и всё, что с ним связано.
    - Его контроллер, ресурсы, зависимости, локализация, и прочее.
    - Имеет строгую базовую структуру.
    - Имеет свой отдельный контроллер со своим URL для доступа к HTTP-API.

  • R-пакет
    - Это пакет для различных ресурсов общего назначения.
    - Например, здесь могут быть хелперы для laravel.
    - Не имеет строгой базовой структуры.

# Возможные взаимные схемы зависимостей для пакетов разных типов

  • Пакеты разных типов могут зависеть друг от друга
    - Но не все схемы зависимостей разрешены приложением.

  • Бэкенд-зависимости прописываются в composer.json пакета
    - M,D,L,W-пакеты содержат файл composer.json.
    - Все бэкенд-зависимости прописываются в composer.json.
    - В стандартных для этого св-в require и прочих.

  • Фронтенд-зависимости прописываются в bower.json пакета
    - D,L,W-пакеты содержат bower.json.
    - Все внешние фронтенд-зависимости могут быть только от bower-пакетов.
    - Они прописываются в bower.json каждого пакета.
    - В стандартных для этого св-в dependencies и прочих.

  • Допустимые схемы зависимостей для пакетов разных типов

    ▪ M <--- R,M
      - M-пакаеты объективно могут зависеть друг от друга.
      - Ведь существуют межпакетные связи.
      - В их конфигах конкретно указано имя и версия пакета.
      - Поэтому M-пакеты не являются на 100% независимыми модулями.

    ▪ D <--- M,L,W
      - D-пакеты черпают логику своей работы от M-пакетов.
      - Также они могут наследовать от шаблонов L-пакетов.
      - И применять виджеты W-пакетов.

    ▪ L <--- M,W
      - L-пакеты могут черпать логику своей работы от M-пакетов.
      - Также они могут применять виджеты W-пакетов.

    ▪ W <--- M
      - W-пакеты могут черпать логику своей работы от M-пакетов.

    ▪ R <--- R
      - R-пакеты с ресурсами общего назначения могут зависеть друг от друга.

```
## Система управления фронтендом: теория <a id="link4"></a>
```
---------------------------------------
Подоглавление:

  - Аббревиатура СУФ
  - Что умеет СУФ

    • Собирать bower-зависимости DLW-пакетов (C39_suf_collect_deps)
    • Устанавливать все bower-зависимости (C40_suf_install_deps)
    • Проверять наличие драйверов для bower-зависимостей в R5 (C41_suf_check_deps)
    • Применять gulp-задачи из драйверов в R5 ко всем bower-зависимостям (C42_suf_bower_process)
    • Применять gulp-задачи из оных ко всем DLW-пакетам (C43_suf_dlw_process)
    • Получать полный, упорядоченный, плоский стек css/js зависимсотей для D-пакетов (C44_suf_get_deptrees)
    • Автоматически извлекать и записывать инфу о mains bower-пакетов (C45_suf_bower_automain)
    • Интегрировать плоский стек css/js-зависимостей в blade-документы D-пакетов (C46_suf_blade_integrate)
    • Собирать и интегрировать массивы путей для watch и browsersync, интегрировать в gulpfile.js D-пакетов

---------------------------------------

# Аббревиатура СУФ
  - Система управления фронтендом.
  - Будем называть её СУФ здесь и далее.

# Что умеет СУФ

  • Собирать bower-зависимости DLW-пакетов (C39_suf_collect_deps)
    - Каждый DLW-пакет может иметь bower-зависимости.
    - Они прописываются в файле bower.json пакета, в поле dependencies.
    - Команда собирает все dependencies со всех DLW-пакетов.
    - И сохраняет их в bower.json приложения, который лежит в пакете R5.

  • Устанавливать все bower-зависимости (C40_suf_install_deps)
    - Команда считывает dependencies из bower.json приложения из пакета R5.
    - И посылает команды bower install и bower prune контейнеру node.
    - Тот их получает и выполняет установку/удаление bower-пакетов.
    - Все bower-пакеты приложения устанавливаются в папку public/public/bower

  • Проверять наличие драйверов для bower-зависимостей в R5 (C41_suf_check_deps)

    ▪ Про mains
      - В bower.json bower-пакета должно быть поле main со списком путей относ.корня пакета.
      - По задумке создателей, там должны быть пути ко "входным" точкам пакета.
      - То есть именно эти файлы и следует подключать в html-документы для работы с пакетом.

    ▪ Про проблемы с mains
      - Однако, это "соглашение" соблюдают далеко не все разработчики bower-пакетов.
      - Зачастую в main проставлены неверные пути, либо main вообще отсутствует.
      - Мало того, бывает, что для использования пакета надо сначала провести компиляцию.
      - Скажем, преобразовать SASS-файлы в CSS-файлы определённым оразом.

    ▪ Драйвера для bower-пакетов
      - Как следствие, нельзя автоматизировать работу с bower-пакетами без драйверов.
      - Драйвера для каждого bower-пакета представляют из себя:

        ▪ Папочку с именем bower-пакета в R5/data4bower
        ▪ Файл mains.json в этой папочке
        ▪ Файл gulpfile.js в этой папочке

    ▪ Про mains.json
      - Это json-файл с единственным полем "mains".
      - Если там не пусто, оно будет подменять оригинальный "main" пакета.

    ▪ Про gulpfile.js
      - Это набор задач для gulp, описывающих, что сделать с этим пакетом.
      - По умолчанию, там пусто. Требуется применять довольно редко.

    ▪ Что делает команда
      - Для каждого bower-пакета проверяет наличие папочек с драйверами.
      - И в случае отсутствия таковых, просто сообщает в лог приложения.

  • Применять gulp-задачи из драйверов в R5 ко всем bower-зависимостям (C42_suf_bower_process)
    - Команда обходит драйвера всех bower-пакетов, для которых оные имеются.
    - И для каждого драйвера шлёт в контейнер node gulp'у команду выполнить gulpfile.js.

  • Применять gulp-задачи из оных ко всем DLW-пакетам (C43_suf_dlw_process)
    - Команда обходит все DLW-пакеты.
    - И для каждого шлёт в контейнер node gulp'у команду выполнить gulpfile.js DLW-пакета.

  • Получать полный, упорядоченный, плоский стек css/js зависимсотей для D-пакетов (C44_suf_get_deptrees)

    ▪ DLW-пакеты могут зависеть друг от друга
      - Это подробно описано выше в разделе про СУБ.
      - См.главу "Возможные взаимные схемы зависимостей для пакетов разных типов".
      - При этом, у каждого DLW-пакета есть папка Public с его фронтенд ресурсами.
      - И если, скажем, пакет D1 зависиот от пакета L1, то D1 наследует эти ресурсы.
      - В итоге, мы имеем некое дерево фронтенд-зависимостей DLW-пакетов.

    ▪ Bower-пакеты могут зависеть друг от друга
      - У каждого bower-пакета есть файл bower.json с полем dependencies.
      - И в этом поле могут быть прописаны bower-пакеты-зависимости.
      - В итоге, мы имеем некое дерево фронтенд-зависимостей bower-пакетов.

    ▪ DLW-пакеты могут зависеть от bower-пакетов
      - У каждого DLW-пакета есть файл bower.json с полем dependencies.
      - И в этом поле могут быть прописаны bower-пакеты-зависимости.
      - В итоге, деревья DLW- и bower-фронтенд-зависимостей переплетается.

    ▪ Что здесь имеем в виду под "фронтенд-зависимостями"
      - Пути к css/js файлам.

    ▪ Про плоские стеки css/js зависимостей
      - В конечном счёте, все эти зависимости надо будет подключить к документу.
      - Для этого надо получить 2 списка: с css, и с js зависимостями.
      - Эти списки и будем называть плоскими стеками зависимосетй.
      - Плоские стеки получаются путём "разбора" соотв.деревьев зависимостей.
      - Более глубокие элементы деревьев идут всегда выше менее глубоких.
      - А взаимный порядок элементов с одного уровня глубины не имеет значения.

    ▪ Порядок имеет значение
      - Порядок зависимостей в плоских стеках имеет значение.
      - Отдельно для bower- и dlw-зависимостей порядок получаем вышеописанным способом.
      - В стеке всегда сначала идут bower-зависимости, и уже потом dlw-зависимости.

    ▪ Подключение плоских стеков всегда происходит лишь для D-документов
      - То есть к LW-документам никаких ресурсов никогда не подключается.
      - Поскольку шаблоны и виджеты не являются самостоятельными документами.
      - И они всегда являются частью того или иного D-документа.
      - Поэтому, этот D-документ и наследует весь фронтенд от LW-документов, от которых зависит.

    ▪ Что делает команда
      - Для всех D-документов получает и возвращает их плоские css/js стеки.

  • Автоматически извлекать и записывать инфу о mains bower-пакетов (C45_suf_bower_automain)

    ▪ Автосоздание папочек с драйверами
      - С помощью C41_suf_check_deps команда получает список bower-пакетов без драйверов.
      - Затем создаёт для них драйвера из шаблона.

    ▪ Автозаполнение пустых mains.json
      - Команда обходит драйвера и ищет пустые mains.json
      - И получает таким образом список bower-пакетов с пустыми mains.
      - Затем обходит их, и изслекает "main" из их bower.json.
      - А затем вставляет эти данные в mains.json в драйверах.

  • Интегрировать плоский стек css/js-зависимостей в blade-документы D-пакетов (C46_suf_blade_integrate)
    - Команда с помощью C44_suf_get_deptrees получает css/js стеки.
    - Затем обходит все файлы view.blade.php D-пакетов.
    - В этих файлах есть специальные метки, отдельно для css и js.
    - Команда вставляет список <link...> для css-стека между css-метками.
    - Команда вставляет список <script...> для js-стека между js-метками.

  • Собирать и интегрировать массивы путей для watch и browsersync, интегрировать в gulpfile.js D-пакетов

    ▪ Как работает browsersync (bs)
      - Он запускает proxy на nodejs, оборачивающий указанный тобой домен.
      - Открыть верстаемый документ ты можешь через этот самый proxy.
      - Также bs запускает демона, отслеживающего изменения в списке указанных файлов.
      - И в случае наличия изменений через websocket посылает открытому документу команду перезагружиться.

    ▪ Для чего при работе с browsersync нужен gulp.watch
      - Это ещё один демон, отслеживающий уже список других файлов.
      - Перед использованием в документе часто фронтенд надо "готовить".
      - Скажем, преобразовывать .scss в .css, конкатенировать js, и т.д.
      - Все подобные задачи описаны в gulpfile.js у каждого D-пакета.
      - И если bs должен отслеживать уже "готовые" финальные файлы.
      - То gulp.watch должен отслеживать "исходники" типа .scss файлов.
      - Если watch видит, что исходник изменился, он запускает задачи по обработке.
      - В итоге, "готовые" файлы тоже меняются, bs это видит, и перезагружает документ.

    ▪ Подробнее про массивы путей

      ▪ Массивы с путями
        - Для bs и watch в gulpfile.js каждого D-пакета нужны массивы с путями для отслеживания.

      ▪ Массив с путями для watch
        - Это должны быть пути к папкам Public и blade-документам.
        - D-пакет, как упоминалось, может иметь LW-зависимости.
        - Это должны быть пути со всего этого дерева DLW-зависимостей.

      ▪ Массив с путями для bs
        - Это должны быть пути к папкам public/public/<имя DLW-пакета>.
        - D-пакет, как упоминалось, может иметь LW-зависимости.
        - Это должны быть пути со всего этого дерева DLW-зависимостей.

    ▪ Что делает команда
      - Она обходит все файлы gulpfile.js всех D-пакетов.
      - Для каждого, собирает массив путей для watch, и массив путей для bs.
      - А в gulpfile.js есть спец.метки, между которыми эти массивы можно вставить.
      - Что и делает команда.


```
## Прикладные инструкции по работе с СУБ и СУФ <a id="link5"></a>
```
---------------------------------------
Подоглавление:

  Общие инструкции и советы
  -------------------------

    # Советы

      • Когда использовать виджеты, а когда knockout-компоненты
      • Можно ли использовать один и тот же L-пакет в разных проектах?
      • MR-пакеты должны иметь UID глобально, а DLW-пакеты - лишь в проекте.
      • Общая концепция работы с DLW-пакетами и MR-пакетами между проектами
      • Постоянные ID для DLW-пакетов начинаются от 10000

    # Инструкции

      • Запуск / Остановка Docker-приложения
      • Автоматизация сохраниния MDLWR-пакета на github
      • Как скопировать папку с проектом

  Инструкции и советы по СУБ
  --------------------------

    # Советы

      • Команда m1:afterupdate выполняется при каждом composer install/update

    # Инструкции

      • Cоздать/удалить MDLWR-пакет: команды m1:new / m1:del
      • Добавить artisan-команду M-пакета в планировщик laravel можно в его сервис-провайдере
      • Автоматически создать модели для M-пакета: команда m1:workbench_sync_all
      • Отлаживать команды с помощью realtime-лога: m2:listener
      • Просматривать и очищать очередь: m2:queue_show и m2:queue_clear

  Инструкции и советы по СУФ
  --------------------------

    # Советы

      • В проекте используй bower-зависимости одинаковых, конкретных версий
      • Имей в виду, что m1:run_light выполняется каждые 10 минут (в режиме разработки)

    # Инструкции

      • Добавить DLW-пакету bower-зависимость
      • Добавить DLW-пакету DLW-зависимость
      • Вёрстка докумнтов DLW-пакетов
      • Создание нового bower-пакета, добавление в репозиторий, автосохр. на github

---------------------------------------

//-----------------------------//
//  Общие инструкции и советы  //
//-----------------------------//

# Когда использовать виджеты, а когда knockout-компоненты

  • Когда использовать виджеты
    - Когда требуется связь с M-пакетами.
    - Виджет работает с собственным API.

  • Когда использовать knockout-компоненты
    - Когда не требуется связь с M-пакетами.
    - Компонент должен либо не работать с API вообще.
    - Либо компонент должен работать лишь с API родительского документа.

# Можно ли использовать один и тот же L-пакет в разных проектах?
  - Некоторые да, но в основном нет.
  - Например, пустой шаблон L1 можно использовать в нескольких проектах.
  - А вот не пустые шаблоны рекомендуется использовать лишь каждый в своём проекте.

# MR-пакеты должны иметь UID глобально, а DLW-пакеты - лишь в проекте.

  • MR-пакеты должны иметь UID глобально
    - Для каждого MR-пакета должен быть отдельный репозиторий на github.
    - Во всех проектах используются одни и те же MR-пакеты, с теми же UID.

  • DLW-пакеты НЕ обязаны иметь UID глобально
    - Проблема заключается в том, что на github приватные репозитории платные.
    - А основную массу всех MDLWR-пакетов составляют как раз-таки DLW-пакеты.
    - Поэтому, разумнее было бы не создавать под каждый DLW-пакет репчик на github.
    - Вместо этого, в целях сохранения данных, создать репчик для целого проекта.
      Исключив, разумеется, с помощью .gitignore все тяжёлые файлы.

# Общая концепция работы с DLW-пакетами и MR-пакетами между проектами

  • Разработка MR-пакетов ведётся всегда в одном месте, в проекте devapp
    - То есть, их разработка ведётся централизованным путём.
    - Как упоминалось выше, каждый MR-пакет имеет уникальный ID глобально.
    - А доставка в другие проекты путём composer update через github.

  • Разработка DLW-пакетов ведётся чаще всего непосредственно в их проекте
    - То есть, их чаще всего разрабатывают не в devapp, а в том проекте, где будут применять.
    - Как упоминалось выше, DLW-пакеты имеют уникальный ID лишь в пределах проекта.
      И DLW-пакеты не имеют собственных репозиториев на github.
    - Доставка между проектами DLW-пакетов производится путём простого копирования.

# Постоянные ID для DLW-пакетов начинаются от 10000

  • На каждый проект выделяется пул - от 1 до 9999 - непостоянных ID
    - Потому что в каждом проекте DLW-пакеты надо подстраивать под проект.
    - И очень малый % документов можно использовать без изменений в N проектах.
    - Поэтому все DLW-пакеты с ID из указанного пула являются проект-специфичными.
    - Они не имеют собственных репозиториев на github.
    - И не могут быть обновлены с помощью composer update.

  • Существует пул постоянных id - >= 10000
    - Но что, если мы хотим сделать некоторые документы проекта обновляемыми через github?
    - Тогда можно присвоить этим документам постоянные ID из указанного пула.
    - Такие документы имеют репозитории на github, и м.б. обновлены через composer.

# Запуск / Остановка Docker-приложения

  • Запуск

    1. Заходим в корень docker-приложения
      - Не путать с корнем laravel проекта.
      - Корень docker-приложения находится на 1 уровень выше.

    2. Выполняем там команду: . app up
      - Это создаёт соответствующие docker-контейнеры.
      - И применяет к ним соответствующие docker-конфиги.
      - По умолчанию применяется группа конфигов с именем dev.
      - Если требуется применить другую группу:

        . app up -c <имя группы>
        . app up -c production    // пример

      - Имя группы должно совпадать с именем папки с конфигами в configs/groups.

  • Остановка

    1. Заходим в корень docker-приложения
      - Не путать с корнем laravel проекта.
      - Корень docker-приложения находится на 1 уровень выше.

    2. Выполняем там команду: . app down
      - Это останавливает соответствующие docker-контейнеры.


# Автоматизация сохраниния MDLWR-пакета на github

  1. Создать локальный git-репозиторий - выполнить git init
    - Кликнуть правой кнопкой мыши по папке с пакетом.
    - Нажать git init.

  2. Создать удалённый git-репозиторий на github
    - Зайти на github.
    - Создать новый репозиторий.
    - Имя его должно совпадать с ID пакета.

  3. Связать локальный репозиторий с удалённым
    - Для этого перейти в каталог локального репозитория.
    - И выполнить команду:

      git remote add [имя удал.репо.] [адрес удал.репо]

    - Например:

      git remote add M1 git@github.com:4gekkman/M1.git

    - Внимание! Регистр 'm1' или 'M1' имеет значение!

  4. Добавить в GitAutoPushScript.ps1 запись для авто-push
    - Этот скрипт каждый 3 часа автоматически делат push.
    - Следует добавить туда новый локальный репозиторий.
    - И вручную выполнить push одноимённой командой.

  5. Создать первый релиз пакета (версия 1.0.0)
    - Зайти на github, в репозиторий пакета.
    - Нажать на ссылку releases.
    - Создать там новый релиз.

# Как скопировать папку с проектом
  - Это сделать не так то просто, как кажется.
  - Через windows это сделать затруднительно, поскольку в проекте
    присутствуют символьные ссылки, на которых копирование проекта
    через windows зависает.
  - Если игнорировать символьные ссылки, данные могут быть повреждены.
    Например, таблицы MySQL.
  - Поэтому, оптимальный вариант, через rsync.
  - Для этого в папке projects выполнить следующую команду,
    заменив source и dest на соотв.имена проектов:

      rsync -av --exclude='.git' --exclude='.idea' source/ dest
      rsync -av --exclude='.git' --exclude='.idea' devapp/ demosite       // пример

# Как скопировать папку с проектом через ssh
  - Из каталога projects:

      rsync -zavP --exclude='demosite/.git' --exclude='demosite/.idea' demosite  gekkman@192.168.1.49:/c/WebDev/projects



//------------------------------//
//  Инструкции и советы по СУБ  //
//------------------------------//

# Команда m1:afterupdate выполняется при каждом composer install/update
  - В composer.json пакета команда добавлена в соответствующие хуки.

# Cоздать/удалить MDLWR-пакет: команды m1:new / m1:del

  • Создать MDLWR-пакет или его ресурсы

    1. Выполни команду m1:new, следуй инструкциям.
    2. При создании пакета, автоматизируй его сохранение на github.
      - См.выше "Автоматизация сохраниния MDLWR-пакета на github".

  • Удалить MDLWR-пакет или его ресурсы

    1. Выполни команду m1:del, следуй инструкциям.
    2. При удалении пакета, отмени его автосохранение на github
      - См.выше "Автоматизация сохраниния MDLWR-пакета на github".

# Добавить artisan-команду M-пакета в планировщик laravel можно в его сервис-провайдере

  1. Открываем ServiceProvider.php в каталоге с M-пакетом (он лежит в vendor/4gekkman).
  2. Добавляем там соответствующую запись в массив $add2schedule.
  3. Выполняем команду: m1:afterupdate

# Автоматически создать модели для M-пакета: команда m1:workbench_sync_all

  1. Отрисовываем с помощью workbench модель M-пакета.
  2. Проводим синхроанизации с MySQL.
  3. Выполняем команду m1:workbench_sync_all
    - Модели появятся в каталоге M-пакета, в Models.

# Отлаживать команды с помощью realtime-лога: m2:listener

  • Раздели окошко терминала на 2-ве части
    - Слева (40%) пусть будет окошко с консолью-логом.
    - Справа (60%) пусть будет окошко с интерактивной консолью.

  • Как запустить лог
    - Перейди в корень laravel-приложения.
    - Введи: m2:listener
    - Это запустит демона, публикующего новые сообщение каждые 5 секунд.
    - В скриптах добавить сообщение в лог можно командой: write2log("сообщение", []);

  • Как проводить отладку команд
    - Как правило, команды создаются парами: обычная + artisan команда.
    - Запуск artisan-команды приводит к запуску обычной команды.
    - В коде artisan-команды и обычной команды применяй хелпер write2log.
    - В правой консоли запускай artisan-команду.
    - В левой консоли смотри в режиме реального времени вывод данных в лог.

  • Как очистить лог
    - Команда m2:listener также проводит и очистку лога.
    - То есть, все старые сообщения при её запуске удаляются.
    - Также, очистить лог можно отдельной командой m2:clear.

# Просматривать и очищать очередь: m2:queue_show и m2:queue_clear

  • Очередь через redis в laravel
    - В нашем laravel-проекте очереди работают через redis.
    - Иногда хочется посмотреть, а какие задачи стоят в очереди.
    - Иногда даже необходимо очистить очередь от задач.

  • Как просмотреть текущее содержимое очереди
    - Введи команду: m2:queue_show
    - Содержимое очереди будет выведено в лог (m2:listener).
    - Правда, там будут обрезанные данные.
    - То есть длинные строки, описывающие задачу, обрезаются справа.
    - Чтобы увидеть полные данные:

        php artisan tinker
        Queue::getRedis()->command('LRANGE',['queues:default', '0', '-1']);

  • Как очистить очередь
    - Введи команду: m2:queue_clear

//------------------------------//
//  Инструкции и советы по СУФ  //
//------------------------------//

# В проекте используй bower-зависимости одинаковых, конкретных версий

  • Советы для проекта для разработки devapp
    - Здесь используй версии latest для всех bower-зависимостей.

  • Советы для прочих проектов

    ▪ Конкретность
      - Не надо использовать bower-зависимости версий latest.
      - Или расплывчатые semver-ограничения, вроде ">=1.0".
      - Вместо этого всегда указывай конкретные версии, вроде "1.0.0".
      - Это позволит избежать "поломки" проекта после очередного обновления.

    ▪ Одинаковость
      - В разных местах в кач-ве зависимости м.б. указан 1-ин и тот же bower-пакет.
      - Так вот, везде надо применять одну и ту же конкретную версию зависимости.
      - Поскольку в bower-инфраструктуре не должно быть 2 одинаковых пакетов разных версий.

# Имей в виду, что m1:run_light выполняется каждые 10 минут (в режиме разработки)
  - Команда m1:run выполняет команды m1:afterupdate и m1:suf.
  - А команда m1:run_light делает тоже самое, но с урезанной m1:afterupdate.
  - Конкретно, урезано пересоздание всех моделей всёх M-пакетов.
  - Команда m1:run_light добавлена в планировщик laravel, и выполняется каждые 10 минут.
  - Но это происходит лишь если включён режим разработки.
  - Вкл / Выкл режим разработки можно в конфиге пакета M1.

# Добавить DLW-пакету bower-зависимость

  1. Открываем bower.json соответствующего DLW-пакета.
  2. Вписываем bower-зависимость в поле dependencies.
  3. Идём в github-репчик пакета и смотрим его bower.json
    - Правильно ли там указаны пути в поле main, есть ли оно вообще?
    - Если всё правильно, то переходим к след.шагу.
    - Если нет, идём в R5/data4bower и создаём драйвер для пакета.
  4. Далее 2 варианта:

    - Либо ждём 10 минут, и оно само всё установится.
    - Либо выполняем artisan-команду "m1:suf" и ждём ~5-10 минут.

  5. Что в итоге?
    - Пакет устанавливается и интегрируется в css/js стеки.
    - Зависимости автоматически появляются в соотв. blade-документах.
    - Теперь их можно применять в коде.

# Добавить DLW-пакету DLW-зависимость

  1. Открываешь composer.json DLW-пакета.
  2. Добавляешь ему в поле require DLW-заввисимости.
  3. Далее 2 варианта:

    - Либо ждём 10 минут, и оно само всё установится.
    - Либо выполняем artisan-команды "m1:afterupdate", затем "m1:suf".

  4. Что в итоге?
    - Установки не происходит, поскольку речь идёт о проекте devapp.
    - Это проект для разработки, тут по умолчанию присутствуют ВСЕ пакеты.
    - Информация о зависимости всасывается в базу пакета M1.
    - Фронтенд-зависимости автоматически появляются в соотв. blade-документах.

# Вёрстка докумнтов DLW-пакетов

  1. Заходишь в каталог D-пакета
    - Он находится в vendor/4gekkman.

  2. Выполняешь там gulp-задачу dev

    • Работай чере свою ОСНОВНУЮ машину
      - Допустим, у тебя основная машина на Windows.
      - На ней ты запускаешь ВМ с Linux через Vagrant.
      - И на этом Linux у тебя работают docker-контейнеры с приложением.
      - Так вот, запускай описанную gulp-задачу через gulp у себя на Windows.
      - Иначе, не будет работать.

    • Тебе нужна gulp-задача dev
      - Выполни команду: gulp dev
      - Если говорит, что нет локального gulp, то сначала
        выполняешь: npm link gulp, а затем: gulp dev
      - Либо можешь выполнить: gulpdev
        Это функция, прописанная у меня в profile powershell'а.
        Она выполняет: npm link gulp, и затем gulp dev.

  3. У тебя автоматически в браузере откроется документ
    - С ним и работай.

  4. Как работать с этим

    • Раздели экран
      - В левой части пусть у тебя будет браузер с документом.
      - В правой части пусть будет редактор с кодом.

    • Редактируй файлы в Public и blade-документв DLW-пакетов
      - D-пакет, чей документ открыт, может зависеть от LW-пакетов.
      - Образуя соотв.дерево зависимостей и стеки css/js ресурсов.
      - Ты можешь редактировать ресурсы любого DLW-пакета из этого дерева.
      - При этом любые изменения будут автоматически применяться к документу в браузере.

# Создание нового bower-пакета, добавление в репозиторий, автосохр. на github

  1. Перейти в каталог C:\WebDev\bower
  2. Сделать копию "4gekkman-bower-sample".
    - Имя сформировать по шаблону: "4gekkman-bower-" + <имя>
  3. Наполнить новый каталог содержимым.
    - А также отредактировать bower.json, composer.json.
  4. Зайти на github.com и создать для нового bower-пакета репозиторий
    - Имя репозитория должно совпадать с именем bower-пакета.
  5. Сделать из каталога с новым bower-пакетом локальный git-репозиторий
    - Открыть терминал с консолью, и перейти в каталог нового bower-пакета.
    - Ввести (заменив <имя> на имя bower-пакета):

        git init
        git remote add <имя> git@github.com:4gekkman/<имя>.git

  6. Организовать автосохранение на github
    - Открыть файл GitAutoPushScript.ps1.
    - Сделать там соотв.запись. в раздел "Сохранение моих bower-пакетов на github".
  7. Выполнить push
    - Открыть терминал с консолью, и ввести команду push.
  8. Создать релиз 1.0.0 нового bower-пакета на github.
  9. Зарегистрировать новый bower-пакет в bower-репозитории
    - Для этого ввести (заменив <name> на имя пакета, а <url> на путь к github-репозиторию пакета):

        bower register <name> <url>
        bower register 4gekkman-bower-prefixfree https://github.com/4gekkman/4gekkman-bower-prefixfree    // пример


```
## Функционал <a id="link6"></a>
```

  # Команды и к.команды общего назначения #
  #---------------------------------------#

    Команда                 К.Команда                   Описание
    ----------------------------------------------------------------------------------------------------------------------
    parseapp              | m1:parseapp               | Парсит приложение, возбуждает событие "m1:afterupdate"
    sp_regs_update        | m1:sp_regs_update         | Актуализирует регистрации сервис-провайдеров пакетов
    allrespublish         | m1:allrespublish          | Публикует ресурсы всех пакетов (имеющие соотв.теги)
    m_dbs_update          | m1:m_dbs_update           | Устанавливает / обновляет базы данных M-пакетов
    release               | m1:release                | Создаёт новый релиз на github указанного пакета
    mdlw_cfgs_update      | m1:mdlw_cfgs_update       | Актуализирует конфиги MDLW-пакетов
    m_schedules_update    | m1:m_schedules_update     | Актуализирует запланированные задачи на выполнение консольных команд M-пакетов
    workbench_sync        | m1:workbench_sync         | Для указанного M-пакета синхронизирует модели и связи в них с его БД
    workbench_sync_all    | m1:workbench_sync_all     | Для всех M-пакетов синхронизирует модели и связи в них с их БД
    clear_interpack_rels  | m1:clear_interpack_rels   | Подчищает pivot-таблицы уже неактуальных межпакетных связей
    run                   | m1:run                    | Запускает к.команды afterupdate и suf, если включен режим разработки (в конфиге M1)

  # Команды для работы с очередью #
  #-------------------------------#

    queue_show            | m1:queue_show             | Вывести в лог содержимое очереди
    queue_clear           | m1:queue_clear            | Очистить очередь

  # Команды для организации автосохранения на github для MDLWR-пакетов #
  #--------------------------------------------------------------------#

    github_check          | m1:github_check           | Checks if 4gekkman acc is accessible for the app

    github_new            | m1:github_new             | Organize autosave to github for specified MDLWR-pack
    github_new_local      | -                         | Create new local repo for specified MDLWR-pack, and bind local and remote reps
    github_new_remote     | -                         | Create new remote repo in github for MDLWR-pack
    github_new_autopush   | -                         | Add note about the new MDLWR-pack in GitAutoPushScripts

    github_del            | m1:github_del             | Cancels autosave to github for the MDLWR-pack, which must be removed
    github_del_remote     | -                         | Delete the remote repo in github of the specified MDLWR-pack
    github_del_autopush   | -                         | Remove note about the MDLWR-pack in GitAutoPushScripts, which must be removed

  # Команды и к.команды CLI-приложения для разработки по управлению ресурсами #
  #---------------------------------------------------------------------------#

    Команда           К.Команда               Описание
    ----------------------------------------------------------------------------------------------------------------------
    -               | m1:new                | Единая точка входа в CLI-приложение

    new_m           | -                     | Новый M-пакет
    new_m_c         | -                     | Новая M-команда
    new_m_t         | -                     | Новая M-к.команда
    new_m_h         | -                     | Новый M-обработчик
    new_m_ct        | -                     | Новая пара M-команда - M-к.команда
    new_m_m         | -                     | Новая M-модель
    del_m           | -                     | Удалить указанный M-пакет
    del_m_с         | -                     | Удалить указанную M-команду указанного M-пакета
    del_m_t         | -                     | Удалить указанную M-к.команду указанного M-пакета
    del_m_h         | -                     | Удалить указанный M-обработчик указанного M-пакета
    del_m_m         | -                     | Удалить указанную M-модель указанного M-пакета

    new_r           | -                     | Новый R-пакет
    del_r           | -                     | Удалить указанный R-пакет

  # Команды системы управления фронтендом #
  #---------------------------------------#

    Команда                 К.Команда                   Описание
    ----------------------------------------------------------------------------------------------------------------------
    -                       m1:suf                      Trigger for all processes of frontend control system
    suf_collect_deps        m1:suf_collect_deps         Collect all bower-dependencies from bower.json of DLW-packages to bower.json of the project
    suf_install_deps        m1:suf_install_deps         Install all bower-dependencies in bower.json of the project
    suf_check_deps          m1:suf_check_deps           Every used bower-pack in app must have corresponding data in R5, this command looks for bower-packs that does not.
    suf_bower_process       m1:suf_bower_process        Walk thru all bower packages, invoke gulp task for each from R5
    suf_dlw_process         m1:suf_dlw_process          Walk thru all DLW-packages, invoke it's gulp task for each
    suf_get_deptrees        m1:suf_get_deptrees         This command forms dependencies trees for suf_blade_integrate and suf_watch_setting
    suf_bower_automain      m1:suf_bower_automain       Auto fill mains.json of bower packs by data from main from bower.json of pack, if mains of pack is totally empty
    suf_blade_integrate     m1:suf_blade_integrate      Integrate css/js paths from suf_get_deptrees to blade-docs of D-packs between corresponding marks
    suf_watch_setting       m1:suf_watch_setting        Setting gulpfile.js of D-packs - past between marks sources and dests to watch

  # Обработчики событий #
  #---------------------#

    -


```
## Схемы взаимодействий с другими пакетами <a id="link7"></a>
```

  # Pull-взаимодействия (по инициативе этого пакета) #
  #--------------------------------------------------#

    ---------------------------------------------------------------------------------------------
    Пакет     Команда     К.Команда     Обработчик      Событие           Комментарий
    ---------------------------------------------------------------------------------------------

      -

  # Push-взаимодействия (по инициативе других пакетов) #
  #----------------------------------------------------#

    ---------------------------------------------------------------------------------------------
    Пакет     Команда     К.Команда     Обработчик      Событие           Комментарий
    ---------------------------------------------------------------------------------------------

      -


```
## Установка, обновление, удаление <a id="link8"></a>
```

----------------------
Оглавление

  # Установка
  # Обновление
  # Удаление

----------------------

> Установка

  1. Добавить инфу о пакете в composer.json проекта
    - Добавить зависимость (укажите нужную вам версию):

        "require": {
            "4gekkman/m1": "1.0.*"
        }

    - Добавить адрес git-репозитория:

        "repositories": [
            {
                "type": "vcs",
                "url":  "git@github.com:4gekkman/m1.git"
            }
        ]

  2. Добавить к.команду "m1:afterupdate" в composer.json проекта
    - К.Команда m1:afterupdate добавляется в composer.json проекта,
      в массивы "post-install-cmd" и "post-update-cmd":

        php artisan m1:afterupdate

    - После этого она будет выполняться автоматически, после каждого
      composer update.

  3. Добавить сервис-провайдер пакета в config/app.php
    - Открыть конфиг config/app.php.
    - Найти там массив providers.
    - Добавить в него сервис-провайдер пакета M1:

        M1\ServiceProvider::class,

  4. Выполнить composer update

  5. Настроить модуль в его конфиге config/m1.php
    - И после этого выполнить composer update.

> Обновление

  1. Прописать в composer.json нужную версию пакета
    - Можно указать конкретную версию пакета.
    - А можно указать, чтобы при выполнении composer update
      автоматически устанавливалась свежая patch- / minor- / major-версия.
    - Примеры:

      "1.0.*"    // >=1.0.0 <1.1.0
      "~1.3"     // >=1.3.0 <2.0.0
      ">=2"      // >= 2.0.0

  2. Выполнить composer update
    - Сабж.

> Удаление

  1. Выполнить 1,2,3 из "Установка" наоборот.
  2. Выполнить composer update
  3. Вручную удалить базу данных M1 из СУБД.

```




## Заметки к релизам <a id="link100"></a>
```

  1.0.0
    - Первый релиз.

```










