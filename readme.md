# M1 - Управление Приложением (master)
---
## Оглавление

  - [Ссылки](#link1)
  - [Введение](#link2)
  - [Общее описание работы пакета](#link3)
	- [Функционал](#link4)
	- [Схемы взаимодействий с другими пакетами](#link5)
	- [Установка, обновление, удаление](#link6)
  - [Заметки к релизам](#link100)

---

## Ссылки <a id="link1"></a>
```

  > Адрес репозитория пакета М1 на github
      https://github.com/4gekkman/M1

	
			
```

## Введение <a id="link2"></a>
```

  • Это М-пакет для управления приложением.
  • В нём сосредоточен весь соответствующий функционал.
  • Он является корневым для всего приложения.
  • Без него приложение не будет функционировать корректно.
  • Но это не значит, что остальные М-пакеты зависят от этого.
  • Они могут с успехом работать и без него.
  • Однако, это будет в 100 раз менее удобно, чем с этим М-пакетом.

 
```
## Общее описание работы пакета <a id="link3"></a>
```
---------------------------------------
Подоглавление:

  - Что умеет делать пакет

    • Парсить приложение (C1_parseapp)
    • Синхронизировать регистрации сервис-провайдеров пакетов приложения (C2_sp_regs_update)
    • Публиковать ресурсы зарегистрированных пакетов приложения (C3_allrespublish)
    • Устанавливать / Обновлять базы данных M-пакетов приложения (C4_m_dbs_update)
    • Создавать новый релиз указанного пакета на github (C32_release)
    • Обновлять конфиги M,D,L,W-пакетов (C33_mdlw_cfgs_update)
    • Синхронизировать задания пакетов приложения для планировщика (C35_m_schedules_update)
    • Синхронизировать модели указанного пакета с его БД (C36_workbench_sync)
    • Осуществлять очистку pivot-таблиц оборванных межпакетных взаимодействий (C38_clear_interpack_rels)
    • Создавать и удалять все типы пакетов и их ресурсов

  - Межпакетные связи между базами данных M-пакетов

    • Введение в проблемы
    • Решение всех проблем
    • Кейсы

  - Подробнее о работе с конфигами пакетов

    • Конфиги публикуются для M,D,L,W-пакетов
    • Как публикуются конфиги
    • Как обновляются конфиги
    • Примеры работы с конфигами

  - Локализация пакетов

    • Общая информация о локализации пакетов
    • Глобальная локализация
    • Локальная локализация
    • Локализация в M,D,L,W-пакетах
      ▪ Основная информация
      ▪ Как пользоваться
    • Как получить локаль в клиенте

  - Подробнее о работе с базами данных M-пакетов

    • Суть работы с БД M-пакетов
    • Когда происходит обновление БД M-пакета
    • Ведение истории обновление БД M-пакета в конфиге

  - События Event и Broadcast

    • Общая информация об архитектуре событий приложения
    • Событие Event
    • Событие Broadcast

  - Пространства имён пакетов

    • Общая информация о пространствах имён пакетов
    • Пространство имён указывается в composer.json пакета
    • Пространство имён для разрабатываемых пакетов

  - Какие типы пакетов бывают у вендора 4gekkman

    • M-пакет
    • D-пакет
    • L-пакет
    • W-пакет
    • R-пакет

  - Возможные взаимные схемы зависимостей для пакетов разных типов
  - Фронтенд-функционал приложения

    • Про Систему Управления Фронтендом, в мелком масштабе
    • Теперь не надо выполнять к.команду m1:allrespublish при каждом запросе
    • Файловая структура СУФ
    • СУФ в динамике
    • Процесс вёрстки blade-документов D-пакетов с помощью СУФ

---------------------------------------

# Что умеет делать пакет

  • Парсить приложение (C1_parseapp)
    - Команда парсит все пакеты приложения, их типы, ресурсы.
    - Как бы делает слепок текущего состояния приложения.
    - И сохраняет все эти результаты в базу данных пакета M1.

  • Синхронизировать регистрации сервис-провайдеров пакетов приложения (C2_sp_regs_update)
    - Обычно при установке пакетов надо добавлять их сервис-провайдеры в конфиг app.php.
    - При установке/удалении пакетов приложения, эта команда делает всё за тебя.
    - Это относится не ко всем пакетам, а лишь к пакетам вендора 4gekkman.

  • Публиковать ресурсы зарегистрированных пакетов приложения (C3_allrespublish)
    - У пакетов приложения есть различные ресурсы, которые требуется опубликовать.
    - Эта команда публикует все подобные ресурсы разом.

  • Устанавливать / Обновлять базы данных M-пакетов приложения (C4_m_dbs_update)
    - Большинство M-пакетов имеют свои базы данных.
    - При установке пакетов эти базы данных требуется устанавливать.
    - А при обновлении пакетов эти БД может потребоваться обновлять.
    - Всё это делает за тебя данная команда.
    - Это относится не ко всем пакетам, а лишь к пакетам вендора 4gekkman.

  • Создавать новый релиз указанного пакета на github (C32_release)
    - Эта команда позволяет создать новый релиз пакета на github.
    - Однако, она не закачивает туда свежую версию пакета.

  • Обновлять конфиги M,D,L,W-пакетов (C33_mdlw_cfgs_update)
    - Все пакеты имеют свои конфиги в configs.
    - Эти конфиги обычно не изменяются при обновлениях пакетов.
    - Однако, их всё же иногда при обновлениях требуется обновлять.
    - Эта команда автоматически это делает.
    - Это относится не ко всем пакетам, а лишь к пакетам вендора 4gekkman.

  • Синхронизировать задания пакетов приложения для планировщика (C35_m_schedules_update)
    - Laravel не позволяет определять задания для планировщиков в сервис-провайдерах пакетов.
    - Однако, с помощью данной команды, ты можешь это делать.
    - Она автоматически выполняет всю необходимую работу.

  • Синхронизировать модели указанного пакета с его БД (C36_workbench_sync)
    - Эта команда позволяет за секунды создать все необходимые модели для M-пакета.
    - Она парсит существующую структуру БД указанного M-пакета.
    - И на её основе создаёт необходимые модели.

  • Осуществлять очистку pivot-таблиц оборванных межпакетных взаимодействий (C38_clear_interpack_rels)
    - БД M-пакетов могут быть объединены межпакетными m:n связями.
    - В соответствующей pivot-таблице накапливаются данные.
    - В случае обрыва связи эти данные становятся не валидными.
    - Данная команда автоматически очищает pivot-таблицу в этом случае.

  • Создавать и удалять все типы пакетов и их ресурсов
    - Это CLI-приложение по управлению ресурсами приложения.
    - Оно позволяет через CLI-интерфейс создавать/удалять пакеты и их ресурсы.

# Межпакетные связи между базами данных M-пакетов

  • Введение в проблемы

    1) Хранение межпакетных данных
      - В M4 есть таблица MD1_routes.
      - В M1 есть таблица MD2_packages.
      - Приложению нужны связи между роутами и пакетами.
      - Оно хочет знать для каждого пакета, с какими роутами он связан.
      - Оно хочет знать для каждого роута, с какими пакетами он связан.
      - Для этой связи требуется наличие pivot-таблицы.
      - Но где её хранить?

    2) Обеспечение наличия связей в моделях
      - M1 и M4 полностью независимы друг от друга.
      - И могут как присутствовать в системе, так и отсутствовать.
      - Если оба присутствуют, связи в соотв.моделях должны быть.
      - Если оба отсутствуют, связей с воотв.моделях быть не должно.

    3) Безопасный запрос данных из БД другой модели
      - M4 может потребоваться запросить из M1 данные.
      - Это можно сделать через событие, но это не удобно.
      - При прямом запросе, если M4 не будет в системе, будет error.

    4) Очистка pivot-таблицы в зависимом M-пакета
      - Сначала M1 и M4 могут присутствовать в системе.
      - В pivot-таблице их связи в M4 могут накапливаться данные.
      - Потом M4 может быть удалена вместе с БД.
      - А потом M4 может быть установлена заново, вместе с БД.
      - На этом этапе, данные в pivot в M4 уже являются неверными.
      - Их следует удалить.

  • Решение всех проблем

    1) Хранение межпакетных данных
      - Эти данные хранятся в базе зависящего M-пакета.
      - То есть того, кому нужны данные от связанного M-пакета.
      - Они хранятся в pivot-таблице с именем "/^md200[0-9]{1}$/"
      - В этом M-пакете, связанная таблица должна быть связана
        с этой pivot-таблицей как обычно, 1:n связью
      - Pivot-таблица должна находиться на жёлтой плашке "Foreign".
      - На плашке также должен присутствовать текстовый комментарий.
      - В description таблицы должна быть json-строка с информацией:

          {
            "mpackid":"M1",           // С каким M-пакетом связь
            "table":"MD2_packages",   // С какой таблицей в этом M-пакете связь
            "version":">=1.0"          // Требуемая версия М-пакета
          }

      - Эта инфа будет использована для авто-создания связей в моделях.
      - Доступ к этим данным можно осуществлять с помощью такого запроса:

          DB::select("SELECT table_comment FROM INFORMATION_SCHEMA.TABLES WHERE table_schema='m4' AND table_name='md2000'");

    2) Обеспечение наличия связей в моделях
      - При каждом afterupdate производится обновление моделей и связей.
      - За это отвечает специальная команда C36_workbench_sync.
      - Она вставляет межпакетные связи в обе связанные модели
        лишь в том случае, если оба пакета/базы, модели/таблицы в наличии.
      - Перед использованием, всегда надо проверять наличие
        метода-связи в классе-модели.

          method_exists("\M4\Models\MD1_routes", "m1_packages")

      - Межпакетная связь имеет префикс в виде id_inner того
        M-пакета, с которым связь. Например: "m1_packages".

    3) Безопасный запрос данных из БД другой модели

      • Безопасный запрос через r1_query
        - Осуществляется через хелпер r1_query.
        - Он принимает callback с запросом.
        - Применяет его через try .. catch.
        - С случае успеха возвращает коллекцию.
        - В случае неудачи возвращает NULL.
        - Пример:

            $packages = r1_query(function(){
              return \M1\Models\MD2_packages::whereHas('packtypes', function($query){
                $query->whereIn('name', ["D", "L", "W"]);
              })->get();
            });

      • Проверка наличия связи через r1_rel_exists
        - Проверить наличие связи можно хелпером r1_rel_exists.
        - Первый аргумент: название M-пакета, связь в котором надо проверить.
        - Второй аргумент: название таблицы в БД, связь для которой надо проверить.
        - Третий аргумент: название связи, существование которой надо проверить.
        - Пример:

            if(r1_rel_exists("M5", "MD3_privileges", "m1_packages")) {
              $privilege->m1_packages()->attach($package->id);
            }

    4) Очистка pivot-таблицы в зависимом M-пакете
      - Осуществляется отдельной командой C38_clear_interpack_rels.
      - Эта команда выполняется при каждом afterupdate.
      - Ищет md200* в существующих M-пакетах.
      - Проверяет присутствие M-пакетов/БД и моделей/таблиц,
        с которыми md200* должны быть связаны.
      - В случае отсутствия, делает truncate для этой md200*.

  • Кейсы

    1) Межпакетная связь между M4 и M1

      Описание
      --------
        - Роуты должны быть связаны с D,L,W-пакетами.
        - Иначе им не узнать адреса контроллеров, куда
          направлять соответствующие запросы.
        - Поэтому, в модели M4 создаётся новая foreign-связь.
        - Создаётся таблица md2000, с полями id_route и id_package.
        - Её связывают 1:n связью с таблицей роутов.
        - В её description прописывают метаданные для автосоздания связей.

      Связанные модели
      ----------------
        \M1\Models\MD2_packages
        \M4\Models\MD1_routes

      Использование r1_routes
      -----------------------
        - При создании роута пользователю надо дать выбор.
        - С каким D,L,W-пакетом требуется связать этот роут.
        - Для этого, надо запросить список id_inner всех их.
        - Это необходимо делать с помощью r1_routes.
        - Если r1_routes вернёт NULL, сообщить пользователю,
          что доступных для связи пакетов нет.
        - И пожаловаться по этому поводу в лог приложения.

      Сохранение/Извлечение данных из md2000
      --------------------------------------
        - При создании нового роута, он связывает с пакетом.
        - При удалении роута, все его связи с пакетами удаляются.
        - Перед Attach / Detach присутствие связи проверяется
          спомощью метода method_exists.
        - Если связи нет, то Attach / Detach не выполняются.
        - Всё равно это означает, что pivot-таблица уже очищена.
        - В случае отсутствия связей, пожаловаться в лог приложения.

      Очистка md2000 при удалении M1
      ------------------------------
        - Допустим, произошло удаление M1 правильным способом.
        - Выполняется afterupdate, и C38_clear_interpack_rels.
        - Таблица md2000 полностью очищается.

    2) Межпакетная связь между M5 и M1

      Описание
      --------
        - Права должны быть связаны с пакетами и командами.
        - Это позволит автоматически создавать права типов
          "access" и "exec".
        - Поэтому, в модели M5 создаются 2 новых foreign-связи.
        - Создаётся таблица md2000, с полями id_privilege и id_package.
        - Создаётся таблица md2001, с полями id_privilege и id_command.
        - Их связывают 1:n связями с таблицей прав.
        - В их description прописывают метаданные для автосоздания связей.

      Связанные модели
      ----------------
        \M1\Models\MD2_packages <---> \M5\Models\MD1_privileges
        \M1\Models\MD2_packages <---> \M5\Models\MD5_commands

      Использование r1_routes
      -----------------------
        - Применяется при создании автоматических прав.
        - Для этого требуется извлечь все D,L,W-пакеты и
          все команды.
        - Если r1_routes вернёт NULL, использовать пустую коллекцию.
        - И пожаловаться по этому поводу в лог приложения.

      Сохранение/Извлечение данных из md2000 и md2001
      -----------------------------------------------
        - Создание / Удаление права происходит лишь на основе
          данных, извлечённых r1_routes из M5.
        - Если r1_routes вернёт NULL, то создавать автоматические
          права будет не для кого.
        - И это означает, что pivot-таблица уже очищена.
        - В случае отсутствия связей, пожаловаться в лог приложения.

      Очистка md2000 при удалении M1
      ------------------------------
        - Допустим, произошло удаление M1 правильным способом.
        - Выполняется afterupdate, и C38_clear_interpack_rels.
        - Таблица md2000 полностью очищается.

# Подробнее о работе с конфигами пакетов

  • Конфиги публикуются для M,D,L,W-пакетов
    - У них есть в структуре файлы settings.php

  • Как публикуются конфиги
    - У каждого из этих пакетов есть сервис провайдер.
    - В нём прописана публикация конфигов в /config
    - Имя конфига каждого пакета равно имени его ID.
    - Например: D1.php, W1.php, M1.php, и т.д.
    - Публикация производится вместе со всеми остальными ресурсами.
    - Если режим development mode включен, то при каждом запросе и allrespublish.
    - Если выключен, то только при каждом allrespublish.

  • Как обновляются конфиги
    - Речь ниже пойдёт, разумеется, тольк о M,D,L,W-пакетах.
    - У каждого из них есть каталог файлами:

      /Cnfupds
        cfgupdate_1.php    // Это Laravel-команда
        cfgupdate_2.php    // Это Laravel-команда
        ...

    - Каждый файл содержит код для обновления конфига пакета.
    - И у каждого в конфиге есть массив "cnfupdshistory".
    - Также имеется команда С33_mdlw_cfgs_update и
      консольная команда T11_mdlw_cfgs_update.
    - Команда С33 выполняется при запуске к.команды m1:afterupdate.
    - Она извлекает содержимое cnfupdshistory.
    - cnfupdshistory может содержать возрастающую последовательность
      цифр типа ['1','2','3'] и так далее.
    - Далее, она извлекает массив цифр из имён файлов из Cnfupds.
    - Если в cnfupdshistory нет цифры для каких либо файлов,
      то с команда с помощью exec выполняет (в порядке возрастания)
      код из этих файлов. И записывает их цифры-имена в cnfupdshistory.

  • Примеры работы с конфигами

    Общие вводные
    -------------
      - В /Cnfupds уже 3 файла: cfgupdate_1.php, cfgupdate_2.php, cfgupdate_3.php
      - Массив cnfupdshistory: ['1','2','3'].

    Сценарий 1 - установка с нуля
    -----------------------------
      - В /config записывается новый конфиг пакета.
      - Никакие файлы из /cnfupds не устанавливаются.
      - Всё ОК.

    Сценарий 2 - установка на ['1']
    -------------------------------
      - Пакет был установлен ранее, конфиг уже опубликован.
      - Массив cnfupdshistory: ['1'].
      - Команда C33 выполняет сначала 2.php, затем 3.php.
      - И записывает cnfupdshistory: ['1','2','3'].

# Локализация пакетов

  • Общая информация о локализации пакетов
    - Лучше сразу делать приложение с возможностями локализациями.
    - Наверняка потребуется разрабатывать приложение для пользователей,
      разговаривающих на разных языках.
    - За основу следует взять 2 языка, RU и EN.
    - Всё приложение должно "из коробки" поддерживать эти языки.

  • Глобальная локализация
    - В конфиге /config/app.php есть опция "locale".
    - Это и есть параметр локализации всего приложения.
    - По умолчанию, все пакеты ориентируются именно на неё.

  • Локальная локализация
    - Доступна для M,D,L,W-пакетов.
    - В конфигах M,D,L,W-пакетов также есть опция locale.
    - По умолчанию, для неё доступны 2 значения:
      "RU", "EN".
    - По умолчанию, везде стоит значение "".
    - Это означает, что надо использовать глобальную локаль.

  • Локализация в M,D,L,W-пакетах

    ▪ Основная информация
      - Файлы локализации всего приложения лежат в /resources/lang/*
      - У каждого M,D,L,W-пакета есть каталог /Localization:

          /Localization
            /en
              localization.php
            /ru
              localization.php

      - Публикация файлов-локализаций производится в сервис-провайдерах
        этих пакетов.
      - Они публикуются в /resources/lang, в каталоге /ru, /en и т.д.
      - Файлы локализации переименовываются в ID D,L,W-пакета.
      - Допустим, при публикации файлов локализации пакета D1:

          /resources
            /lang
              /ru
                D1.php
              /en
                D1.php

    ▪ Как пользоваться
      - С помощью php-хелпера trans.
      - Например, в D1 есть фраза с ключём "welcome".
      - А пакет D1 использует глобальную локаль (она EN).
      - Тогда, извлечь фразу с ключём "welcome" можно
        так:
          trans('en.d1.welcome')        // где-нибудь в контроллере D1
          {{ trans('en.d1.welcome') }}  // где-нибудь в представлении D1

    ▪ Как получить локаль в клиенте
      - Локаль всегда передаётся контроллером пакета клиенту.
      - Это происходит при формировании ответа на get-запрос.
      - Локаль формируется хелпером r1_get_doc_locale по ID пакета.


# Подробнее о работе с базами данных M-пакетов

  • Суть работы с БД M-пакетов
    - У каждого M-пакета есть каталог Database.
    - В нём должны лежать файлы *.sql.
    - В качестве имён должны быть использованы цифры >= 1.
    - Нумерация должна начинаться с 1, с инкрементацие по 1.
    - Например: 1.sql, 2.sql, 3.sql.
    - Файл 1.sql содержит sql для установки начальной БД модуля.
    - Файлы с именем >= 2 - это sql для обновления БД модуля.
    - Также, в Database лежит .mwb файл с workbench-моделью модуля.
    - Вот как это всё выглядит (пример):

      /Database
        model.mwb
        1.sql
        2.sql
        3.sql

  • Когда происходит обновление БД M-пакета
    - Обновление производит скрипт из M1.
    - Который выполняется при каждом composer update.

  • Ведение истории обновление БД M-пакета в конфиге
    - Нельзя при каждом composer update выполнять все sql-файлы.
    - Так можно легко потерять важные данные.
    - Например, при таком раскладе, при каждом composer update
      все данные из таблицы m1.table будут теряться:
        1.sql - создать таблицу m1.table
        2.sql - удалить таблицу m1.table
        3.sql - создать таблицу m1.table
    - Чтобы этого не происходило, скрипту требуется знать,
      какие .sql файлы для модуля уже были ранее выполнены.
    - Эти данные записываются в файле настроек модуля в config/*
    - У каждого M-пакета в конфиге есть свойство "updateshistory".
    - Оно должна содержать массив цифр, обозначающих имена .sql файлов.
    - Это означает, что соотв. .sql-обновления уже были применены,
      и выполнять их повторно не требуется.

        'updateshistory' => [1,2,3],

# События Event и Broadcast

  • Общая информация об архитектуре событий приложения
    - Архитектура приложения подразумевает наличие лишь 2-х событий.
    - Это события Event (обычное) и Broadcast (трансляция).
    - Эти 2-ва события определены в пакете R2.

  • Событие Event
    - Принимает массив агрументов $data.
    - В нём можно передавать обработчику необходимые данные.
    - Один элемент - с ключём "keys" - является обязательным.
    - Он содержит массив строк-ключей.
    - Каждый обработчик реагирует только на определённые ключи.
    - Если в keys есть хотя бы 1 такой ключ, обработчик среагирует.

  • Событие Broadcast
    - Принимает массив агрументов $data.
    - В нём можно передавать обработчику необходимые данные.
    - Один элемент - с ключём "channels" - является обязательным.
    - Он содержит массив строк-каналов.
    - Клиенты-подписчики реагируют на сообщения лишь по определёным каналам.
    - По аналогии, как обработчики реагируют лишь на определнные ключи.

# Пространства имён пакетов

  • Общая информация о пространствах имён пакетов
    - Каждый пакет имеет своё пространство имён.
    - Имя пр.имён совпадает с ID пакета (напр.: M1, D1, L1, ...).

  • Пространство имён указывается в composer.json пакета
    - Например, есть у нас пакет M1.
    - В его composer.json указываем пр.имён:

      "autoload": {
        "psr-4": {"M5\\": ""}
      }

  • Пространство имён для разрабатываемых пакетов
    - Указывается в composer.json всего проекта.
    - Аналогичным образом, как и в composer.json пакета.

# Какие типы пакетов бывают у вендора 4gekkman

  • M-пакет
    - Имя M-пакета образуется по шаблону: M[целая цифра от 1 и выше]
    - Это пакеты с бэкенд-логикой.
    - Почти все M-пакеты имеют свою отдельную одноимённую базу данных.
    - Имеет строгую базовую структуру.

  • D-пакет
    - Это пакет, представляющий один фронтенд-blade-документ, и всё, что с ним связано.
    - Его контроллер, ресурсы, зависимости, локализация, и прочее.
    - Имеет строгую базовую структуру.
    - Имеет свой отдельный контроллер со своим URL для доступа к HTTP-API.

  • L-пакет
    - Это пакет, представляющий один фронтенд-blade-шаблон, и всё, что с ним связано.
    - Его контроллер, ресурсы, зависимости, локализация, и прочее.
    - Имеет строгую базовую структуру.
    - Имеет свой отдельный контроллер со своим URL для доступа к HTTP-API.

  • W-пакет
    - Это пакет, представляющий один фронтенд-blade-виджет, и всё, что с ним связано.
    - Его контроллер, ресурсы, зависимости, локализация, и прочее.
    - Имеет строгую базовую структуру.
    - Имеет свой отдельный контроллер со своим URL для доступа к HTTP-API.

  • R-пакет
    - Это пакет для различных ресурсов общего назначения.
    - Например, здесь могут быть хелперы для laravel.
    - Не имеет строгой базовой структуры.

# Возможные взаимные схемы зависимостей для пакетов разных типов

  • Пакеты разных типов могут зависеть друг от друга
    - Но не все схемы зависимостей разрешены приложением.

  • Бэкенд-зависимости прописываются в composer.json пакета
    - M,D,L,W-пакеты содержат файл composer.json.
    - Все бэкенд-зависимости прописываются в composer.json.
    - В стандартных для этого св-в require и прочих.

  • Фронтенд-зависимости прописываются в bower.json пакета
    - D,L,W-пакеты содержат bower.json.
    - Все внешние фронтенд-зависимости могут быть только от bower-пакетов.
    - Они прописываются в bower.json каждого пакета.
    - В стандартных для этого св-в dependencies и прочих.
    - Доп.информация про пакеты-зависимости может писаться в extra.
    - Ну, типа, какие файлы каких типов где искать, и считать entry-поинтами, и т.д.

  • Допустимые схемы зависимостей для пакетов разных типов

    ▪ M <--- R,M
      - M-пакаеты объективно могут зависеть друг от друга.
      - Ведь существуют межпакетные связи.
      - В их конфигах конкретно указано имя и версия пакета.
      - Поэтому M-пакеты не являются на 100% независимыми модулями.

    ▪ D <--- M,L,W
      - D-пакеты черпают логику своей работы от M-пакетов.
      - Также они могут наследовать от шаблонов L-пакетов.
      - И применять виджеты W-пакетов.

    ▪ L <--- M,W
      - L-пакеты могут черпать логику своей работы от M-пакетов.
      - Также они могут применять виджеты W-пакетов.

    ▪ W <--- M
      - W-пакеты могут черпать логику своей работы от M-пакетов.

    ▪ R <--- R
      - R-пакеты с ресурсами общего назначения могут зависеть друг от друга.

# Система управления фронтендом им. 4gekkman'а для laravel-приложения

  • Про Систему Управления Фронтендом, в мелком масштабе

    ▪ Аббревиатура СУФ
      - Будем здесь и далее, для краткости, называть Систему Управления Фронтендом просто - СУФ.

    ▪ Из чего состоит СУФ

      ▪ Несколько команд в M1
      ▪ Папка frontend с файлами СУФ на уровне проекта (на уровень выше папки project с laravel)
      ▪ Демоны gulp.watch и browsersync в контейнере сервиса node

    ▪ СУФ без пакета 4gekkman/M1 не работает
      - Это следует из предыдущего пункта.
      - Ведь несколько команд из M1 являются частью СУФ.

    ▪ Основные задачи, которая призвана решать СУФ

      ▪ Загрузка, структурирование, обработка, публикация bower-фронтенд-зависимостей всех D,L,W-пакетов
      ▪ Автоматическое подключение в правильном порядке css,js-ресурсов в blade-документы всех D-пакетов
      ▪ Автоматическая пересборка проекта при любых изменениях в файлах-фронтенд-исходниках
      ▪ Отслеживание всех итоговых-dist-файлов и обеспечение удобной вёрстки через browsersync

  • Теперь не надо выполнять к.команду m1:allrespublish при каждом запросе
    - Напомню, что эта команда публиковала public-ресурсы D,L,W-пакетов в public проекта.
    - С появлением СУФ команда allrespublish потеряла свою актуальность.
    - Теперь СУФ отвечает за публикацию и обновление ресурсов пакетов.
    - И делает это СУФ намного эффективнее, а не при каждом HTTP-запросе, что было не эффективно даже при разработке.

  • Файловая структура СУФ

    <проект>                                | Каталог всего docker-проекта (не путать с каталогом project с laravel-проектом)

      /frontend                             | Каталог с основной частью файлов для СУФ (за исключением команд из M1)
        .bowerrc                            | Конфиг для bower
        bower.json                          | Главный bower.json СУФ
        gulpfile.js                         | Это главный gulpfile проекта, здесь и wathc + browsersync, сюда же подключаются всe gulptasks
        paths4gulpwatch.json                | Это JSON, содержащий массив с путями, которые должен отслеживать демон gulp.watch
        paths4browsersync.json              | Это JSON, содержащий массив с путями, которые должен отслеживать демон browsersync

        /gulptasks                          | Gulp-задачи СУФ, все они запускаются через главный gulpfile.js
          <имя1>.js                         |
          <имя2>.js                         |
          /bower                            | Gulp-задачи СУФ, относящиеся к bower-пакетам
            component1.js                   |
            component2.js                   |

        /bower_components                   | В этот каталог устанавливаются bower-пакеты из главного bower.json
          /component1                       |
          /component2                       |

      /project                              | Это каталог с laravel-проектом
                                            |
        /vendor                             |
          /4gekkman                         |
            /M1                             |
              /commands                     |
                make_main_bowerjson.php     | Собрать bower-зависимости всех D,L,W-пакетов проекта в <проект>/frontend/bower.json
                install_bowerjson.php       | Установить присутствующие / Удалить отсутствующие bower-зависимости по файлу <проект>/frontend/bower.json
                make_paths4gulpwatch.php    | Собрать все пути для отслеживания демоном gulp.watch в <проект>/frontend/paths4gulpwatch.json
                make_paths4browsersync.php  | Собрать все пути для отслеживания демоном browsersync в <проект>/frontend/paths4browsersync.json
              /console                      |
                invoke_suf_commands         | К.команда, выполняющая все СУФовские команды разом
                make_main_bowerjson.php     | К.команда для запуска основной команды
                install_bowerjson.php.php   | К.команда для запуска основной команды
                make_paths4gulpwatch.php    | К.команда для запуска основной команды
                make_paths4browsersync.php  | К.команда для запуска основной команды

            /[DLW]<id>                      | D, L или W пакет
              bower.json                    | Все D,L,W-пакеты обладают файлом bower.json с фронтенд зависимостями соотв.пакета. Из них то и собирается итоговый файл <проект>/frontend/bower.json
              /public                       | Каталог для публичных ресурсов пакета
                /src                        | Исходники публичных ресурсов
                  /css                      |
                  /js                       |
                /dist                       | Здесь хранятся обработанные, готовые к подключению JS/CSS пакета
                  /css                      |
                    c.css                   |
                    c.min.css               |
                  /js                       |
                    j.js                    |
                    j.min.js                | Всякие прочие ресурсы пакета (шрифты, картинки и т.д.)
                /assets

        /public                             | Это каталог с публичными ресурсами проекта

          /public                           | Это создаёт URI-сегмент для публ.ресурсов: http://site.ru/public/...

            /bower                          | Здесь публичные ресурсы bower-пакетов (dist)
              /component1                   |
              /component2                   |
                /dist                       |
                  /css                      |
                    c.css                   |
                    c.min.css               |
                  /js                       |
                    j.js                    |
                    j.min.js                |
                  /assets                   |

            /docs                           | Здесь публичные ресурсы D-пакетов (dist)
              /D<id1 пакета>                |
              /D<id2 пакета>                |
                /dist                       |
                  /css                      |
                    c.css                   |
                    c.min.css               |
                  /js                       |
                    j.js                    |
                    j.min.js                |
                  /assets                   |

  • СУФ в динамике

    ▪ Исходные условия
      - Имеем работающие демоны gulp.watch и browsersync.
      - Файл "paths4browsersync.json" имеет 0 путей для отслеживания.
      - Файл "paths4gulpwatch.json" имеет 0 не встроенных, и 4 встроенных путей для отслеживания:

         ▪ gulpfile.js
         ▪ paths4gulpwatch.json
         ▪ paths4browsersync.json

      - При любом изменении в этих файлах gulp перезагружает gulpfile с новыми путями.
      - Установлено 0-оль D,L,W-пакетов.
      - Демон gulp.watch следит за следующими файлами.

    ▪ Хуки для фронтенда, к.команда invoke_suf_commands
      - В M1 есть такая к.команда - afterupdate.
      - При установке/удалении composer/bower пакетов эта команда запускается.
      - Она сама по себе ничего не делает, а лишь запускает набор других команд.
      - Эти команды выполняют всякую нужную при установке/удалении пакетов работу.
      - Одной из таких команд и является команда invoke_suf_commands.
      - Эта команда выполняет все СУФовские команды из M1.
      - В итоге мы получаем следующие файлы наполненными и готовыми к работе:

        ▪ gulpfile.js
        ▪ paths4gulpwatch.json
        ▪ paths4browsersync.json

      - Итак, при каких обстоятельствах исполняется команда invoke_suf_commands:

        ▪ Если её вызвать вручную через artisan.
        ▪ Автоматически gulp'ом при любом изменении в вышеуказанных файлах.

      - Gulp также автоматически перезагрузит gulpfile с новыми путями.
      - А где же указываются, собственно, хуки?

        ▪ В <проект>/project/composer.json, в св-ве scripts, для composer-пакетов.
        ▪ В <проект>/.bowerrc, в св-ве scripts, для bower-пакетов.

    ▪ Выполнение gulp-задач из gulpfile.js и <gulptasks>
      - Точкой входа для выполнения всех gulp-задач является gulpfile.js.
      - Все gulp-задачи из <gulptasks> подключены к gulpfile.js.
      - Демоны gulp.watch и browsersync следят за указанными в их path-файлах путями.
      - И каждый из них выполняет соотв.набор gulp-задач при любых изменениях в этих путях.
      - После выполнения invoke_suf_commands следующие файлы изменятся:

         ▪ paths4gulpwatch.json
         ▪ paths4browsersync.json

      - В результате gulp.watch выполнит полагающиеся ему задачи.
      - В результате все фронтенд ресурсы будут размещены туда, куда надо.
      - Соответствующие ресурсы будут подключены в blade-файлы всех D-пакетов.
      - А gulp перезапустится с новыми путями для демонов gulp.watch и browsersync.

  • Процесс вёрстки blade-документов D-пакетов с помощью СУФ
    - Надо открыть документ через proxy-сервер browsersync.
    - Для этого вместо localhost:80 надо открыть localhost:3000.
    - Разумеется, перейти на разрабатываемый документ по его URI.
    - При любых изменениях его исходных ресурсов, об будет автоматом перезагружаться.




  • Мозговой штурм

    Скачка и установка
      - В bower.json DLW-пакетов указываются их bower-зависимости.
      - Консольная команда из M1 обходит все bower.json всех DLW-пакетов.
      - И собариат итоговый bower.json всего приложения.
      - И скачивает все эти bower пакеты, и удаляеет лишние.

    Запоминание main пакетов
      - Во время обхода командой M1 bower-файлов она делает ещё кое-что.
      - Для каждого пакета она запоминает содержимое св-ва main.
      - И записывает итоговый набор информации в отдельный JSON-файл.

    









  > Задачи

    Задача №1: сбор и структурирование всех bower-фронтенд-зависимостей

      • Собрать со всех DLW-пакетов список bower-зависимостей без повторений.
      • Сформировать из этого списка файл /bower/bower.json
      • Выполнить задачу bower install на уровне проекта.
        Причём, если пакет отсутствует в bower.json, он удаляется.
      • На bower install повесить хук-after, выполняющий все gulp-задачи из
        bower_gulp_tasks. На каждый bower-пакет должна приходиться
        одна одноимённая gulp-задача.
      • Gulp-задачи для каждого bower-пакета должны вычленить из
        него все ресурсы, которые потребуется добавить в public,
        структурировать их жёстко заданным образом, и разместить
        в каталог /bower/data4public/<имя bower пакета>. Также
        в каталоге dist размещаются готовые к дистрибьюции css
        и js файлы.

      Кто и когда всё это делает
      • Во время разработки это должно происходить при каждом запросе.
      • Во время продакшн это должно происходить после composer update.
      • Всем этим делом должна заниматься отдельная команда из M1.
      • Также потребуется по gulp-задаче для каждого bower-пакета.
      • Команда будет управлять запусками и результатами этих gulp-задач.

    Задача №2: публикация dist-версий и assets bower-пакетов в public

      • Для каждого пакета файлы публикуются в /public/bower/<имя пакета>
      • Формат этой публикации жёстко задан, и для всех пакетов одинаков:

        /c.min.css
        /j.min.js
        /assets

      • Кроме содержимого каталога assets, оно может быть любым.

      Кто и когда всё это делает
      • Это всё происходит в рамках gulp-задач пакетов.

    Задача №3: публикация собственных ресурсов D-пакетов в public

      • Собственные ресурсы публикуются в public только для D-пакетов.
      • Потому что L,W-пакеты никогда не используются без D-пакетов.
      • Поэтому собственные ресурсы D-пакетов включают и собственные
        ресурсы L,W-пакетов, от которых зависят D-пакеты.
      • Вычисляется вся цепочка L,W-пакетов, от которых зависит D-пакет.
      • Каждый из D,L,W-пакетов имеет строго структурированную папку public.
      • Каждый из них имеет папку public/dist с готовыми к дистрибуции ресурсами.
      • Папка dist также строго структурирована, как и для bower-пакетов.
      • Ресурсы из папок dist всей цепочки объединяются в одну итоговую папку dist.
      • И эта папка размещается в /public/<id D-пакета>.

      Кто и когда всё это делает
      • Gulp-задача

    Задача №4: подключение css- и js-ресурсов в blade-документам D-пакетов

      • В каждом D-пакете есть зоны для авто-подключения css- и js-зависимостей.
      • В них подключаются bower-зависимости D-пакета из /public/bower/<имя bower пакета>
        Разумеется, в строго определённом порядке.
      • В них подключаются собственные ресурсы D-пакета из /public/<id D-пакета>
        Они подключатся самыми последними, после всех bower-зависимостей.

      Кто и когда всё это делает
      • Gulp-задача в самом конце.

  > Gulp.watch в отдельном контейнере, и вёрстка с browsersync
    - Он следит за всеми файлами laravel-проекта, за которыми должен следить.
    - И выполняет все gulp-задачи по сборки проекта, которые должен выполнять, если файлы меняются.
    - Для browsersync можно указать домен для проксирования, порт.
    - В итоге любой документ laravel-проекта можно открыть через этот прокси, и верстать с онлайн-обновлением.

  > Ключевые понятия

    - Один центральный файл bower.json всего проекта.
    - Файлы bower.json у DLW-пакетов.
    - Команда в M1, собирающая центральный bower.json из оных в DLW-пакетах.
    - Команда в M1, собирающая список путей для демона gulp.watch, за которыми надо следить.
      Файл sources.watch, в котором и сохраняется результаты работы команды.
    - Команда в M1, собирающая список итоговых dist-файлов для browsersync.
      Файл dists.watch, в котором сохраняются результаты работы команды.
    - Папка с gulp-задачами для сборки фронтенда проекта.
    - Один центральный gulp-файл (entrypoint) для сборки проекта.
    - Демоны gulp.watch и browsersync в контейнере node, использующие собранные списки

  > Идея выноса управления фронтендом из каталога laravel-проекта

    • Почему нельзя разместить управление в composer-пакете
      - Потому что многие файлы в управлении со временем меняются.
      - А при обновлении composer-пакета изменения будут утеряны.

    • Почему нежелательно размеращть управление в каталоге laravel
      - Потому что в нём д.б. лишь laravel да пакеты к нему.
      - Если мы начнём хранить там какие-то доп.папки можно запутаться.
      - И в конце концов забыть, что нам туда надо добавить, чтобы всё работало.
      - А так всё ясно, есть laravel, есть composer-пакеты вендора 4gekkman.

    • Лучший вариант для размещения управления, в каталоге над laravel
      - То есть там, где хранятся файлы по управлению docker-проектом.
      - Создать отдельную папочку frontend, и разместить туда всё необходимое.

          /<проект>
            /frontend
              bower.json
              gulpfile.js
              paths4gulpwatch
              paths4browsersync
              /gulptasks
              /bower_components
              /bower_components_structured
















  • Структура

    /bower
      bower.json
      /bower_components
        /package1
        /package2
        /...
      /bower_gulp_tasks
    /public
      /bower
        /package1
          /css
            c.min.css
          /js
            j.min.js
          /assets
        /package2
      /D1
        /css
          c.min.css
        /js
          j.min.js
        /assets
          /fonts
          /images
          /other
    /vendor
      /4gekkman
        /D1
          composer.json
          bower.json
          /public
            /css
            /js
            /assets


  • Свойство main в bower.json
    - У большинства пакетов в bower.json есть свойство main.
    - Оно может содержать как строку, так и массив строк.
    - Каждая строка представляет входную точку одного типа в проект.
    - Под входной точкой подразумевается путь к файлу относ.корня пакета.
    - Для каждого типа может быть лишь одна входная точка.
    - Например, одна для scss, одна для js, и т.д.

  • На main полагаться нельзя
    - Разные разработчики чего только в main не кладут.
    - Иногда main может вообще отсутствовать в bower.json.
    - Какой из этого вывод? На инфу в main нельзя полагаться.

  • Нужно ли выкладывать всё содержимое bower в открытый доступ?
    - На мой взгляд, это было бы неправильно.
    - Выкладывать в public надо только лишь то, что действительно нужно из пакета.

  • Какие css-ресурсы добавляются в blade-документ?
    - Вычисляются все L,W-пакеты, от которых зависит этот D-пакет.
    - Вычисляются все bower-пакеты-зависимости этого D-пакета.
    - Включая зависимости тех L,W-пакетов, от которых зависит этот D-пакет.
    - Все c.min.css из

    - Лишь 1 файл c.min.css

  • Какие js-ресурсы добляются в blade-документ, и откуда?
    - Файлы
    - В самом конце файл j.min.js из каталога /public/D1/js

  •


  • Источники фронтенда

    ▪ Сами DLW-пакеты
    ▪ bower-пакеты

  • Типы фронтенда

    ▪ css
    ▪ scss
    ▪ less
    ▪ styl
    ▪ js
    ▪ assets
      ▪ fonts
      ▪ images
      ▪ other

  • Стратегия работы с bower-пакетами
    ▪ Смотрим свойство main файла bower.json
    ▪
    ▪
    ▪



  • Что мы хотим получать для DLW-пакетов в итоге для CSS

    ▪ 1-ин итоговый css-файл.
    ▪ Автоподключение этого css в blade-документ DLW-пакета.

  • Что мы хотим получать для DLW-пакетов в итоге для js

    ▪ Порядок подключения всех JS-зависимостей DLW-пакета.
    ▪ Автоподключение этих зависимостей в верном порядке
      в blade-документ DLW-пакета

  • Автоскачивание bower-пакетов для всех зависимостей

    ▪ Управление bower-пакетами на уровне всего приложения.
    ▪ Сбор зависимостей по bower-файлам всех DLWP-пакетов.
    ▪ Использование инфы из dependencies и extra.
    ▪ За всем этим должен следить какой-то функционал.
    ▪ Entry-файлы должны им также копироваться в public.

  • Стратегия по работе с CSS-зависимостями

    ▪ CSS-файлы просто конкатенировать.
    ▪ LESS/SASS/STYLUS-файлы обрабатывать отдельно друг от друга.
      Получается такие 3 отдельные ветки обработки.
      В конце каждой ветки должен находиться css-файл (м.б.пустой).
      И эти css-файлы в итоге надо слить в один.
    ▪ Стратегия обработки по каждой из вышеуказанных веток такова.
      Надо сначала объединить все файлы в один.
      Причём порядок объединения имеет значение.
      И лишь потом скомпилировать этот файл в css.
    ▪ А скомпилированный вариант ещё и минифицировать.
    ▪ И разместить это в public для соотв.пакета.
    ▪ И в документ пакета разместить подключение этого css.

  • Стратегия по работе с JS-зависимостями

    ▪ Надо построить дерево всех js-зависимостей пакета.
    ▪ Далее составить список и порядок подключений.
    ▪ И в документе пакета осуществить подключение этих JS в правильном порядке.


```

## Функционал <a id="link4"></a>
```

  # Команды и к.команды общего назначения #
  #---------------------------------------#

    Команда                 К.Команда                   Описание
    ----------------------------------------------------------------------------------------------------------------------
    parseapp              | m1:parseapp               | Парсит приложение, возбуждает событие "m1:afterupdate"
    sp_regs_update        | m1:sp_regs_update         | Актуализирует регистрации сервис-провайдеров пакетов
    allrespublish         | m1:allrespublish          | Публикует ресурсы всех пакетов (имеющие соотв.теги)
    m_dbs_update          | m1:m_dbs_update           | Устанавливает / обновляет базы данных M-пакетов
    release               | m1:release                | Создаёт новый релиз на github указанного пакета
    mdlw_cfgs_update      | m1:mdlw_cfgs_update       | Актуализирует конфиги MDLW-пакетов
    m_schedules_update    | m1:m_schedules_update     | Актуализирует запланированные задачи на выполнение консольных команд M-пакетов
    workbench_sync        | m1:workbench_sync         | Для указанного M-пакета синхронизирует модели и связи в них с его БД
    workbench_sync_all    | m1:workbench_sync_all     | Для всех M-пакетов синхронизирует модели и связи в них с их БД
    clear_interpack_rels  | m1:clear_interpack_rels   | Подчищает pivot-таблицы уже неактуальных межпакетных связей

  # Команды и к.команды CLI-приложения для разработки по управлению ресурсами #
  #---------------------------------------------------------------------------#

    Команда           К.Команда               Описание
    ----------------------------------------------------------------------------------------------------------------------
    -               | m1:new                | Единая точка входа в CLI-приложение

    new_m           | -                     | Новый M-пакет
    new_m_c         | -                     | Новая M-команда
    new_m_t         | -                     | Новая M-к.команда
    new_m_h         | -                     | Новый M-обработчик
    new_m_ct        | -                     | Новая пара M-команда - M-к.команда
    new_m_m         | -                     | Новая M-модель
    del_m           | -                     | Удалить указанный M-пакет
    del_m_с         | -                     | Удалить указанную M-команду указанного M-пакета
    del_m_t         | -                     | Удалить указанную M-к.команду указанного M-пакета
    del_m_h         | -                     | Удалить указанный M-обработчик указанного M-пакета
    del_m_m         | -                     | Удалить указанную M-модель указанного M-пакета

    new_r           | -                     | Новый R-пакет
    del_r           | -                     | Удалить указанный R-пакет


  # Обработчики событий #
  #---------------------#

    -


```
## Схемы взаимодействий с другими пакетами <a id="link5"></a>
```

  # Pull-взаимодействия (по инициативе этого пакета) #
  #--------------------------------------------------#

    ---------------------------------------------------------------------------------------------
    Пакет     Команда     К.Команда     Обработчик      Событие           Комментарий
    ---------------------------------------------------------------------------------------------

      -

  # Push-взаимодействия (по инициативе других пакетов) #
  #----------------------------------------------------#

    ---------------------------------------------------------------------------------------------
    Пакет     Команда     К.Команда     Обработчик      Событие           Комментарий
    ---------------------------------------------------------------------------------------------

      -


```
## Установка, обновление, удаление <a id="link6"></a>
```

----------------------
Оглавление

  # Установка
  # Обновление
  # Удаление

----------------------

> Установка

  1. Добавить инфу о пакете в composer.json проекта
    - Добавить зависимость (укажите нужную вам версию):

        "require": {
            "4gekkman/m1": "1.0.*"
        }

    - Добавить адрес git-репозитория:

        "repositories": [
            {
                "type": "vcs",
                "url":  "git@github.com:4gekkman/m1.git"
            }
        ]

  2. Добавить к.команду "m1:afterupdate" в composer.json проекта
    - К.Команда m1:afterupdate добавляется в composer.json проекта,
      в массивы "post-install-cmd" и "post-update-cmd":

        php artisan m1:afterupdate

    - После этого она будет выполняться автоматически, после каждого
      composer update.

  3. Добавить сервис-провайдер пакета в config/app.php
    - Открыть конфиг config/app.php.
    - Найти там массив providers.
    - Добавить в него сервис-провайдер пакета M1:

        M1\ServiceProvider::class,

  4. Выполнить composer update

  5. Настроить модуль в его конфиге config/m1.php
    - И после этого выполнить composer update.

> Обновление

  1. Прописать в composer.json нужную версию пакета
    - Можно указать конкретную версию пакета.
    - А можно указать, чтобы при выполнении composer update
      автоматически устанавливалась свежая patch- / minor- / major-версия.
    - Примеры:

      "1.0.*"    // >=1.0.0 <1.1.0
      "~1.3"     // >=1.3.0 <2.0.0
      ">=2"      // >= 2.0.0

  2. Выполнить composer update
    - Сабж.

> Удаление

  1. Выполнить 1,2,3 из "Установка" наоборот.
  2. Выполнить composer update
  3. Вручную удалить базу данных M1 из СУБД.

```




## Заметки к релизам <a id="link100"></a>
```

  1.0.0
    - Первый релиз.

```










