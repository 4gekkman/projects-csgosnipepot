/*//================================================////
////																							  ////
////   j.js - функционал модели шаблона документа		////
////																								////
////================================================////
//// 			        		 	    	   ////
//// 			    Оглавление  			 ////
//// 			         				       ////
////=============================//*/
/**
 *
 *  s0. Функционал, доступный всему остальному функционалу
 *
 *		f.s0.sm_func									| s0.1. Показывает модальное окно с text, заголовком "ошибка" и кнопкой "закрыть"
 *		f.s0.txt_delay_save           | s0.2. Функционал "механизма отложенного сохранения для текстовых полей"
 *    f.s0.logout                   | s0.3. Выйти из своей учётной записи
 *    f.s0.update_messages          | s0.4. Обновить модель чата данными с сервера
 *
 *  s1. Функционал модели управления поддокументами приложения
 *
 *		f.s1.choose_subdoc            | s1.1. Выбрать subdoc с указанным URI
 *
 *  s2. Функционал модели механики левого сайдбара (с главным меню)
 *
 *    f.s2.switch 									| s2.1. Изменить состояние раскрытости левого меню
 *
 *  s3. Функционал модели механики правого сайдбара (с чатом)
 *
 *    f.s3.switch 									| s3.1. Изменить состояние раскрытости правого сайдбара
 *
 *  s4. Функционал модель по управлению звуком
 *
 *    f.s4.switch                   | s4.1. Изменить состояние раскрытости левого меню
 *
 *
 */


//========================//
// 			        		 	    //
// 			 Функционал  			//
// 			         			    //
//====================----//
var LayoutModelFunctions = { constructor: function(self) { var f = this;


	//--------------------------------------------------------------------//
	// 			        		 			                                            //
	// 			 s0. Функционал, доступный всему остальному функционалу 			//
	// 			         					                                            //
	//--------------------------------------------------------------------//
	f.s0 = {};

		//----------------------------------------------------------------------------------//
		// s0.1. Показывает модальное окно с text, заголовком "ошибка" и кнопкой "закрыть"  //
		//----------------------------------------------------------------------------------//
		// - Применяется обычно при ajax-запросах, для при обработке серверных ошибок
		f.s0.sm_func = function(text) {
			return showModal({
				header: 'Ошибка',
				ok_name: 'Закрыть',
				cancel_name: '',
				width: 350,
				standard_css: '1',
				target: document.body,
				html: text,
				params: {},
				callback: function(arg, params){
					if(arg !== null) {}
					else {}
				}
			});
		};

		//-------------------------------------------------------------------------//
		// s0.2. Функционал "механизма отложенного сохранения для текстовых полей" //
		//-------------------------------------------------------------------------//
		f.s0.txt_delay_save = {};

			//----------------------------------------------------------------------//
			// 1] Применить "механизм отложенного сохранения для текстовых полей"   //
			//----------------------------------------------------------------------//
			// - Он особенно актуален для текстовых полей.
			// - Делает так, что функция сохранения срабатывает не при каждом нажатии.
			// - А лишь спустя заданные N секунд после последнего изменения.
			f.s0.txt_delay_save.use = function(savefunc){

				// 2.1. Остановить ранее запланированный setTimeout
				if(self.m.s0.txt_delay_save.settimeoutid())
					clearTimeout(self.m.s0.txt_delay_save.settimeoutid());

				// 2.2] Если время для сохранения не пришло
				if(+Date.now() - +self.m.s0.txt_delay_save.lastupdate() < +self.m.s0.txt_delay_save.gap) {

					// Поставить выполнение на таймер
					var timerId = setTimeout(savefunc, self.m.s0.txt_delay_save.gap);

					// Сохранить timerId в модель
					self.m.s0.txt_delay_save.settimeoutid(timerId);

					// Сохранить текущий timestamp в модель
					self.m.s0.txt_delay_save.lastupdate(Date.now());

					// Указать, что имееются не сохранённые данные
					self.m.s0.txt_delay_save.is_unsaved_data(1);

					// Завершить
					return 1;

				}

				// 2.3] Если время для сохранения пришло
				else {

					// Сохранить текущий timestamp в модель
					self.m.s0.txt_delay_save.lastupdate(Date.now());

				}

			};

			//-------------------------------------//
			// 2] Заблокировать закрытие документа //
			//-------------------------------------//
			// - Иными словами указать, что есть несохранённые данные.
			// - Попытка закрыть страницу в итоге приведёт к вызову модального confirm.
			f.s0.txt_delay_save.block = function(){
				self.m.s0.txt_delay_save.is_unsaved_data(1);
			};

			//--------------------------------------//
			// 3] Разблокировать закрытие документа //
			//--------------------------------------//
			// - Иными словами указать, что нет несохранённых данных.
			// - Попытка закрыть страницу в итоге уже не приведёт к вызову модального confirm.
			f.s0.txt_delay_save.unblock = function(){
				self.m.s0.txt_delay_save.is_unsaved_data(0);
			};

		//-------------------------------------//
		// s0.3. Выйти из своей учётной записи //
		//-------------------------------------//
		f.s0.logout = function(data, event){

			// 1] Отправить запрос
			ajaxko(self, {
				url:          window.location.protocol + '//' + window.location.host + "/layouts/l10003",
				key: 	    		"L10003:1",
				from: 		    "ajaxko",
				data: 		    {},
				prejob:       function(config, data, event){

					// 1] Сообщить, что идёт сохранение нового trade url
					toastr.info("Подожди немного...", "Произвожу выход из твоего аккаунта", {
						timeOut: 					"9999999999999",
						extendedTimeOut: 	"9999999999999"
					});

				},
				postjob:      function(data, params){},
				ok_0:         function(data, params){

					// 1] Сообщить, что пользователи успешно отвязаны
					toastr.info("Перезагружаю документ...", "Успешный выход из аккаунта!", {
						timeOut: 					"9999999999999",
						extendedTimeOut: 	"9999999999999"
					});

					// 2] Перезагрузить страницу
          window.location.reload(true);

				}
			});

		};

		//----------------------------------------------//
		// s0.4. Обновить модель чата данными с сервера //
		//----------------------------------------------//
		f.s0.update_messages = function(data) {

			// 1. Обновить m.s5.messages

				// 1.1. Очистить
				self.m.s5.messages.removeAll();

				// 1.2. Наполнить
				for(var i=0; i<data.messages.length; i++) {

					// 1.2.1. Сформировать объект для добавления
					var obj = {};
					for(var key in data.messages[i]) {

						// 1] Если свойство не своё, пропускаем
						if(!data.messages[i].hasOwnProperty(key)) continue;

						// 2] Добавим в obj свойство key
						obj[key] = ko.observable(data.messages[i][key]);

					}

					// 1.2.2. Добавить этот объект в подготовленный массив
					self.m.s5.messages.push(ko.observable(obj))

				}

			// 2. Прокрутить чат до конца вниз
			setTimeout(function(){

				// 2.1. Получить контейнер чата
				var container = document.getElementsByClassName('chat-messages')[0];

				// 2.2. Получить вертикальный размер прокрутки контейнера
				var scrollHeight = container.scrollHeight;

				// 2.3. Прокретить container в конец
				container.scrollTop = scrollHeight;
				Ps.update(container);

			}, 100);

		};


	//------------------------------------------------------------------------//
	// 			        		 			                                                //
	// 			 s1. Функционал модели управления поддокументами приложения 			//
	// 			         					                                                //
	//------------------------------------------------------------------------//
	f.s1 = {};

		//--------------------------------------//
		// s1.1. Выбрать subdoc с указанным URI //
		//--------------------------------------//
		f.s1.choose_subdoc = function(parameters, data, event) {

			// 1] Сформировать целевой URI из parameters
			var uri = (function(){

				// 1.1] Если uri передан в параметрах, выбрать его
				if(parameters.uri)
					var result = parameters.uri;

				// 1.2] В противном случае
				else {
					result = '/';
					for(var i=0; i<parameters.parameters.length; i++) {
						result = result + parameters.parameters[i];
						if(i != parameters.parameters.length-1)
							result = result + '/';
					}
				}

				// 1.3] Вернуть результат
				return result;

			})();

			// 2] Получить по uri поддокумент из m.s1.subdocs
			// - Если там такого uri нет, взять первый из subdocs
			var subdoc = (function(){

				// 2.1] Попробовать найти поддокумент
				var subdoc = self.m.s1.indexes.subdocs[uri];

				// 2.2] Если subdoc не найден, взять первый из m.s1.subdocs
				if(!subdoc)
					subdoc = self.m.s1.subdocs()[0];

				// 2.n] Вернуть результат
				return subdoc;

			})();

			// 3] Если subdoc не найден, вернуть ошибку
			if(!subdoc) {

				// 3.1] Сообщить об ошибке
				console.log('Ошибка! Наблюдаемый массив с поддокументами пуст.');

				// 3.2] Завершить
				return;

			}

			// 4] Выбрать поддокумент subdoc
			self.m.s1.selected_subdoc(subdoc);

			// 5] Прокрутить документ в самый верх
			// window.scrollTo(0, 0);

			// 6] Если это первый вызов subdoc
			if(parameters.first) {

				// Подменить текущее состояние, а не добавлять новое
				History.replaceState({state:subdoc.uri()}, document.title, layout_data.data.request.baseuri + ((subdoc.uri() != '/') ? subdoc.uri() : ''));  // document.getElementsByTagName("title")[0].innerHTML

			}

			// 7] Если это не первый вход в документ
			else {

				// Добавить в историю новое состояние
				History.pushState({state:subdoc.uri()}, document.title, layout_data.data.request.baseuri + ((subdoc.uri() != '/') ? subdoc.uri() : ''));

			}

		};


	//----------------------------------------------------------------------------//
	// 			        		 			                                                    //
	// 			 s2. Функционал модели механики левого сайдбара (с главным меню) 			//
	// 			         					                                                    //
	//----------------------------------------------------------------------------//
	f.s2 = {};

		//--------------------------------------------------//
		// s2.1. Изменить состояние раскрытости левого меню //
		//--------------------------------------------------//
		f.s2.switch = function(data, event) {

			// 1] Изменить состояние раскрытости на противоположное
			self.m.s2.expanded(!self.m.s2.expanded());

			// 2] При ширине экрана от 1280 до 1456 включительно
			// - Скрыть правый сайдбар с чатом.
			if(self.m.s0.cur_browser_width() >= 1280 && self.m.s0.cur_browser_width() <= 1456) {
				self.m.s3.expanded(false);
			}

		};


	//----------------------------------------------------------------------//
	// 			        		 			                                              //
	// 			 s3. Функционал модели механики правого сайдбара (с чатом) 			//
	// 			         					                                              //
	//----------------------------------------------------------------------//
	f.s3 = {};

		//--------------------------------------------------//
		// s3.1. Изменить состояние раскрытости левого меню //
		//--------------------------------------------------//
		f.s3.switch = function(data, event) {

			// 1] Изменить состояние раскрытости на противоположное
			self.m.s3.expanded(!self.m.s3.expanded());

			// 2] При ширине экрана от 1280 до 1456 включительно
			// - Скрыть левый сайдбар с главным меню.
			if(self.m.s0.cur_browser_width() >= 1280 && self.m.s0.cur_browser_width() <= 1456) {
				self.m.s2.expanded(false);
			}

		};


	//--------------------------------------------------------//
	// 			        		 			                                //
	// 			 s4. Функционал модель по управлению звуком 			//
	// 			         					                                //
	//--------------------------------------------------------//
	f.s4 = {};

		//--------------------------------------------------//
		// s4.1. Изменить состояние раскрытости левого меню //
		//--------------------------------------------------//
		f.s4.switch = function(data, event) {

			// 1] Изменить состояние раскрытости на противоположное
			self.m.s4.is_global_volume_on(!self.m.s4.is_global_volume_on());

		};




return f; }};




























