/*//==================================================================================////
////																		                                              ////
////   Модель игры Jackpot, предназначенная для подключения в основной m.js	документа	////
////																				                                          ////
////==================================================================================////
//// 			        		 	    	   ////
//// 			    Оглавление  			 ////
//// 			         				       ////
////=============================//*/
/**
 *
 *
 * 	s1. Модель игры Jackpot
 *
 * 		s1.1. Свойство
 * 		s1.2.
 *    s1.n. Индексы и вычисляемые значения
 *
 * 	X. Подготовка к завершению
 *
 *    X1. Вернуть ссылку self на объект-модель
 *
 *
 */


//====================//
// 			        		 	//
// 			 Модель  			//
// 			         			//
//====================//
var ModelJackpot = { constructor: function(self, m) { m.s1 = this;

	//---------------------------//
	// 			        		 	       //
	// 	s1. Модель игры Jackpot  //
	// 			         			       //
	//---------------------------//

	//---------------------------------------------------------------------------//
	// s1.1. Модель комнат, раундов, статусов, ставок, поставивших пользователей //
	//---------------------------------------------------------------------------//
	// Комнаты                      				   Комната
	// - Раунды                     				    /   \
	//   - Статусы                  				Раунд   Раунд
	//   - Ставки                         /   \       /   \
	//     - Пользователи            Статус Ставки  Ставки Статус
  //                                        /       \
  //                                 Пользователи Пользователи
  //
	self.m.s1.game = {};

		// 1] Наблюдаемый массив с комнатами //
		//-----------------------------------//
		self.m.s1.game.rooms = ko.observableArray([]);

		// 2] Наблюдаемый массив со списком возможных игровых статусов //
		//-------------------------------------------------------------//
		self.m.s1.game.statuses = ko.observableArray([]);

		// 3] Выбранная комната //
		//----------------------//
		self.m.s1.game.choosen_room = ko.observable("");

		// 4] Раскрыт ли список комнат //
		//-----------------------------//
		self.m.s1.game.is_room_list_expanded = ko.observable(false);

		// 5] Модель текущего и предудыщего раундов для выбранной комнаты //
		//----------------------------------------------------------------//
		self.m.s1.game.curprev = ko.observable({
			current: ko.observable(''),
			previous: ko.observable('')
		});

		// 6] Текущий джекпот текущего раунда //
		//------------------------------------//
		self.m.s1.game.curjackpot = ko.observable(0);

		// 7] Оставшееся до конца текущего раунда время, для choosen_room //
		//----------------------------------------------------------------//
		self.m.s1.game.timeleft = {};

			// 7.1] В секундах //
			//-----------------//
			self.m.s1.game.timeleft.sec = ko.observable("");

			// 7.2] В человеко-понятном формате //
			//----------------------------------//
			// - Например: "00:08:20"
			self.m.s1.game.timeleft.human = ko.observable("");

			// 7.3] В секундах, на момент старта Lottery для этого клиента //
			//-------------------------------------------------------------//
			self.m.s1.game.timeleft.client_start_sec = ko.observable("");

		// 8] Состояние текущего раунда //
		//------------------------------//
		self.m.s1.game.choosen_status = ko.observable("");

		// 9] Палитра цветов для игроков текущего раунда //
		//-----------------------------------------------//
		// - Загружается с сервера.
		self.m.s1.game.palette = ko.observableArray([]);

		// 10] Работа с кривой Безье и вращением колеса //
		//----------------------------------------------//
		self.m.s1.game.bezier = {};

			// 10.1] Параметры кривой Безье //
			//------------------------------//
			self.m.s1.game.bezier.params = [.17, .01, 0, 1];

			// 10.2] Параметры кривой Безье //
			//------------------------------//
			// - Примеры:
			// 		self.m.s1.game.bezier.get(.2);
			// 		self.m.s1.game.bezier.get(.6);
			// 		self.m.s1.game.bezier.get(.9);
			self.m.s1.game.bezier.get = function(time){
				return self.f.s1.bezier.cubicBezier(
						self.m.s1.game.bezier.params[0],
						self.m.s1.game.bezier.params[1],
						self.m.s1.game.bezier.params[2],
						self.m.s1.game.bezier.params[3],
						time,
						self.m.s1.game.choosen_room().lottery_duration_ms()
				);
			};

		// 11] Игрок-победитель текущего раунда в выбранной комнате //
		//----------------------------------------------------------//
		self.m.s1.game.choosen_room_curround_winner = ko.observable("");

		// 12] Оставшееся до конца состояния Pending время, для choosen_room //
		//-------------------------------------------------------------------//
		self.m.s1.game.timeleft_pending = {};

			// 12.1] В секундах //
			//------------------//
			self.m.s1.game.timeleft_pending.sec = ko.observable("");

			// 12.2] В человеко-понятном формате //
			//-----------------------------------//
			// - Например: "00:08:20"
			self.m.s1.game.timeleft_pending.human = ko.observable("");

		// 13] Оставшееся до конца состояния Winner время, для choosen_room //
		//------------------------------------------------------------------//
		self.m.s1.game.timeleft_winner = {};

			// 13.1] В секундах //
			//------------------//
			self.m.s1.game.timeleft_winner.sec = ko.observable("");

			// 13.2] В человеко-понятном формате //
			//-----------------------------------//
			// - Например: "00:08:20"
			self.m.s1.game.timeleft_winner.human = ko.observable("");


	//--------------------------------------//
	// s1.n. Индексы и вычисляемые значения //
	//--------------------------------------//
	ko.computed(function(){

		//---------------------------------------//
		// s1.n.1. Объект-контейнер для индексов //
		//---------------------------------------//
		self.m.s1.indexes = {};

		//-----------------------//
		// s1.n.2. Индекс комнат //
		//-----------------------//
		// - По ID комнаты можно получить ссылку на соотв. объект в self.m.s1.game.rooms
		self.m.s1.indexes.rooms = (function(){

			// 1. Подготовить объект для результатов
			var results = {};

			// 2. Заполнить results
			for(var i=0; i<self.m.s1.game.rooms().length; i++) {
				results[self.m.s1.game.rooms()[i].id()] = self.m.s1.game.rooms()[i];
			}

			// 3. Вернуть results
			return results;

		}());
		
		//---------------------------------------------//
		// s1.n.3. Если комната не выбрана, выбрать её //
		//---------------------------------------------//
		(function(){

			if(!self.m.s1.game.choosen_room()) {
				if(server.data.choosen_room_id != 0)
					self.m.s1.game.choosen_room(self.m.s1.indexes.rooms[server.data.choosen_room_id]);
			}

		})();
		
		//-------------------------------------------------------------------//
		// s1.n.4. Индекс состояний игры модели для отладки игровой механики //
		//-------------------------------------------------------------------//
		// - По ID состояния игры можно получить ссылку на соотв. объект в self.m.s1.game.statuses
		self.m.s1.indexes.statuses = (function(){

			// 1. Подготовить объект для результатов
			var results = {};

			// 2. Заполнить results
			for(var i=0; i<self.m.s1.game.statuses().length; i++) {
				results[self.m.s1.game.statuses()[i]().id()] = self.m.s1.game.statuses()[i]();
			}

			// 3. Вернуть results
			return results;

		}());		

		//-----------------------------------------------------------------------------------------------//
		// s1.n.5. Индекс позиций состояний игры модели для отладки игровой механики в массиве состояний //
		//-----------------------------------------------------------------------------------------------//
		// - По status состояния игры можно получить индекс состояния в массиве self.m.s6.game.statuses
		self.m.s1.indexes.positions = (function(){

			// 1. Подготовить объект для результатов
			var results = {};

			// 2. Заполнить results
			for(var i=0; i<self.m.s1.game.statuses().length; i++) {
				results[self.m.s1.game.statuses()[i]().status()] = i;
			}

			// 3. Вернуть results
			return results;

		}());

		//-------------------------------------------------------------------------//
		// s1.n.6. Наполнить модель текущего/предыдущего раундов выбранной комнаты //
		//-------------------------------------------------------------------------//
		(function(){

			// 1] Обновить ссылку на объект текущего раунда выбранной комнаты
			if(self.m.s1.game.choosen_room() && self.m.s1.game.choosen_room().rounds()[0])
				self.m.s1.game.curprev().current(self.m.s1.game.choosen_room().rounds()[0]);

			// 2] Обновить ссылку на объект предыдущего раунда выбранной комнаты
			if(self.m.s1.game.choosen_room() && self.m.s1.game.choosen_room().rounds()[1])
				self.m.s1.game.curprev().previous(self.m.s1.game.choosen_room().rounds()[1]);

		})();
	
		//-----------------------------------------------------------//
		// s1.n.7. Ссылки на текущий и предыдущий раунды всех комнат //
		//-----------------------------------------------------------//
		// - По имени комнаты мы можем получить ссылку на объект.
		// - В этом объекте лишь 2 свойства, current и previous.
		// - Current всегда ссылается на текущий раунд данной комнаты.
		// - Previous всегда ссылается на предыдущий раунд данной комнаты.
		self.m.s1.indexes.curprev = (function(){

			// 1. Подготовить объект для результатов
			var results = {};

			// 2. Наполнить results
			for(var i=0; i<self.m.s1.game.rooms().length; i++) {

				results[self.m.s1.game.rooms()[i].name()] = {
					current: self.m.s1.game.rooms()[i].rounds()[0] ? self.m.s1.game.rooms()[i].rounds()[0] : {},
					previous: self.m.s1.game.rooms()[i].rounds()[1] ? self.m.s1.game.rooms()[i].rounds()[1] : {}
				};

			}

			// 3. Вернуть results
			return results;

		}());
		
		//----------------------------------------------------//
		// s1.n.8. Рассчитать текущий джекпот текущего раунда //
		//----------------------------------------------------//
		(function(){

			// 1. Если необходимые наблюдаемые отсутствуют, завершить
			if(!self.m.s1.game.choosen_room()) return;

			// 2. Получить короткую ссылку на bets текущего раунда выбранной комнаты
			var bets = self.m.s1.game.choosen_room().rounds()[0].bets();

			// 3. Подсчитать общую суммарную стоимость вещей на кону
			var bank_sum = (function(){
				var result = 0;
				for(var i=0; i<bets.length; i++) {
					for(var j=0; j<bets[i]['m8_items']().length; j++) {
						result = +result + Math.round(+bets[i]['m8_items']()[j].price()*100);
					}
				}
				return result;
			})();

			// 4. Записать bank_sum в наблюдаемую
			self.m.s1.game.curjackpot(bank_sum);

		})();		
		
		//---------------------------------------------//
		// s1.n.9. Вычислить состояние текущего раунда //
		//---------------------------------------------//
		(function(){

			// 1] Проверить наличие необходимых ресурсов
			if(!self.m.s1.game.curprev().current().rounds_statuses) return;

			// 2] Записать имя статуса текущего раунда текущей комнаты в choosen_status
			self.m.s1.game.choosen_status(self.m.s1.game.curprev().current().rounds_statuses()[self.m.s1.game.curprev().current().rounds_statuses().length-1].status());

		})();		

		
	});



	//------------------------------//
	// 			        		 	          //
	// 	X. Подготовка к завершению  //
	// 			         			          //
	//------------------------------//

	//------------------------------------------//
	// X1. Вернуть ссылку self на объект-модель //
	//------------------------------------------//
	return self.m.s1;


}};	// конец модели









