/*//========================================////
////																		    ////
////   m.js	- клиентская модель документа		////
////																				////
////========================================////
//// 			        		 	    	   ////
//// 			    Оглавление  			 ////
//// 			         				       ////
////=============================//*/
/**
 *
 *
 *  А. Стартовая подготовка
 *
 *    А1. Сохранить ссылку на объект-модель в self
 *    А2. Подготовить объект-контейнер для всех свойств модели
 *    А3. Загрузить в модель весь её функционал из f.js
 *		А4. Подключение к websocket-серверам, назначение обработчиков для входящих сообщений
 *
 *	s0. Библиотека данных, доступных всем прочим моделям
 *
 * 		s0.1. Объект-контейнер для всех свойств модели
 * 	  s0.2. Модель "механизма отложенного сохранения для текстовых полей"
 *		s0.3. Счётчик ожидающих ответа ajax-запросов
 *		s0.4. Таймеры для функций, осуществляющих ajax-запросы
 *		s0.5. Виден ли щит "идёт ajax-запрос"
 *	  s0.6. Аутентификационная модель
 *
 *  s1. Модель управления поддокументами приложения
 *
 *		s1.1. Объект-контейнер для всех свойств модели
 *    s1.2. Группы поддокументов приложения
 *    s1.3. Наблюдаемый массив поддокументов приложения
 *    s1.n. Индексы и вычисляемые значения
 *
 *  s2. Модель группы документов, связанных с ботами
 *
 *    s2.1. Объект-контейнер для всех свойств модели
 *    s2.2. Наблюдаемый массив с элементами-ботами
 *    s2.3. Модель чекбокса "Выбрать всех ботов"
 *    s2.4. Ботов всего
 *    s2.5. Кол-во выделенных ботов (зависит ещё от того, стоит ли галочка "Выбрать всех ботов")
 *    s2.6. Модель редактирования бота
 *    s2.7. Модель опций для эл-в select со значениями true/false
 *    s2.8. Модель ошибок обновления цен
 *    s2.n. Индексы и вычисляемые значения
 *
 *  s3. Модель инвентаря выбранного бота
 *
 *    s3.1. Объект-контейнер для всех свойств модели
 *    s3.2. Наблюдаемый массив с элементами-предметами инвентаря
 *    s3.3. Общее количество вещей в инвентаре выбранного бота
 *    s3.4. Общее количество выделенных вещей в инвентаре выбранного бота
 *    s3.5. Объект с экземпляром scroll для инвентаря выбранного бота
 *    s3.6. Идёт ли сейчас ajax-запрос, или нет
 *    s3.7. Строка поиска в инвентаре
 *    s3.8. Массив с ID эл-в инвентаря, прошедших фильтр строкой поиска
 *    s3.9. Массив с ID эл-в инвентаря, выбранных для торговли
 *    s3.10. Суммарная стоимость выбранных для отдачи вещей
 *    s3.n. Индексы и вычисляемые значения
 *
 *  s4. Модель генератора мобильных аутентификационных кодов
 *
 *  	s4.1. Объект-контейнер для всех свойств модели
 *    s4.2. Текущий код для выбранного бота
 *    s4.3. Сколько секунд осталось до истечения текущего кода
 *    s4.4. Временная метка клиентского времени последнего получения кода
 *  	s4.5. Обновляемая таймером каждые N секунд временная метка текущего времени
 *    s4.6. Валиден ли текущий отображаемый код, или нет
 *    s4.7. Сколько осталось жить текущему коду в %
 *    s4.8. Идёт ли сейчас ajax-запрос, или нет
 *  	s4.n. Индексы и вычисляемые значения
 *
 *  s5. Модель торгового партнёра
 *
 *  	s5.1. Объект-контейнер для всех свойств модели
 *  	s5.2. Свойства партнёра
 *  	s5.n.	Индексы и вычисляемые значения
 *
 *  s6. Модель инвентаря торгового партнёра
 *
 *    s6.1. Объект-контейнер для всех свойств модели
 *    s6.2. Наблюдаемый массив с элементами-предметами инвентаря
 *    s6.3. Общее количество вещей в инвентаре торгового партнёра
 *    s6.4. Общее количество выделенных вещей в инвентаре торгового партнёра
 *    s6.5. Объект с экземпляром scroll для инвентаря торгового партнёра
 *    s6.6. Идёт ли сейчас ajax-запрос, или нет
 *    s6.7. Строка поиска в инвентаре
 *    s6.8. Массив с ID эл-в инвентаря, прошедших фильтр строкой поиска
 *    s6.9. Массив с ID эл-в инвентаря, выбранных для торговли
 *    s6.10. Суммарная стоимость выбранных для получения вещей
 *    s6.n. Индексы и вычисляемые значения
 *
 *  s7. Модель торговых предложений выбранного бота
 *
 *  	s7.1. Объект-контейнер для всех свойств модели
 *    s7.2. Наблюдаемый массив со входящими активными торговыми предложениями
 *    s7.3. Наблюдаемый массив со входящими закрытыми торговыми предложениями
 *    s7.4. Наблюдаемый массив с исходящими активными торговыми предложениями
 * 		s7.5. Наблюдаемый массив с исходящими закрытыми торговыми предложениями
 * 		s7.6. Включить ли автообновление
 * 		s7.7. Модель блока radio-кнопок торговых предложений
 * 	  s7.8. Идёт ли сейчас ajax-запрос, или нет
 *  	s7.n. Индексы и вычисляемые значения
 *
 *  sN. Данные, которым доступны все прочие данные
 *
 *    sN.1. Объект-контейнер для всех свойств модели
 *    sN.2.
 * 		sN.n. Индексы и вычисляемые значения
 *
 *  X. Подготовка к завершению
 *
 * 		X1. Сервис провайдер клиентской модели
 *    X2. Вернуть ссылку self на объект-модель
 *
 *
 *
 */


//====================//
// 			        		 	//
// 			 Модель  			//
// 			         			//
//====================//
var ModelProto = { constructor: function(ModelFunctions) {

	//--------------------------------------//
	// 			        		 	                  //
	// 			 А. Стартовая подготовка  			//
	// 			         			                  //
	//--------------------------------------//

	//----------------------------------------------//
	// А1. Сохранить ссылку на объект-модель в self //
	//----------------------------------------------//
	var self = this;

	//----------------------------------------------------------//
	// А2. Подготовить объект-контейнер для всех свойств модели //
	//----------------------------------------------------------//
	self.m = {};

	//---------------------------------------------------//
	// А3. Загрузить в модель весь её функционал из f.js //
	//---------------------------------------------------//
	self.f = Object.create(ModelFunctions).constructor(self);

	//--------------------------------------------------------------------------------------//
	// А4. Подключение к websocket-серверам, назначение обработчиков для входящих сообщений //
	//--------------------------------------------------------------------------------------//
	ko.computed(function(){


		//-------------------------------------------------------------//
		// А4.1. Выполнять код ниже лишь 1 раз, при загрузке документа //
		//-------------------------------------------------------------//
		if(!ko.computedContext.isInitial()) return;


		//----------------------------------------//
		// А4.2. Подключения к websocket-серверам //
		//----------------------------------------//
		self.websocket = {};

			// А4.2.1. Подключение ws1 //
			//-------------------------//

				// 1] Убрать из websocket_server лишние порты
				// - Они появляются при работе через browser-sync
				server.data.websocket_server = server.data.websocket_server.replace(/:\d+.*$/i, "");
				server.data.websocket_server = server.data.websocket_server + ':6001';

				// 2] Подключить ws1
				self.websocket.ws1 = io(server.data.websocket_server);



		//--------------------------------------------------------------//
		// А4.3. Назначение обработчиков сообщений с websocket-серверов //
		//--------------------------------------------------------------//

			// A4.3.1. Обработка сообщений об обновлении информации о кол-ве вещей в инвентарях  //
			//-----------------------------------------------------------------------------------//
			self.websocket.ws1.on('m8:update_bots_inventory_count', function(message) {

				// Обновить данные ботов, связанные с инвентарём
				for(var i=0; i<self.m.s2.bots().length; i++) {
					for(var j=0; j<message.data.data.bots.length; j++) {
						if(self.m.s2.bots()[i]().id() == message.data.data.bots[j].id) {
							self.m.s2.bots()[i]().inventory_count(message.data.data.bots[j].inventory_count);
							self.m.s2.bots()[i]().inventory_count_last_update(message.data.data.bots[j].inventory_count_last_update);
							self.m.s2.bots()[i]().inventory_count_last_bug(message.data.data.bots[j].inventory_count_last_bug);
						}
					}
				}

			});

			// A4.3.2. Обработка сообщений об обновлении информации об авторизации ботов //
			//---------------------------------------------------------------------------//
			self.websocket.ws1.on('m8:update_bots_authorization_statuses', function(message) {

				// Обновить данные ботов, связанные с инвентарём
				for(var i=0; i<self.m.s2.bots().length; i++) {
					for(var j=0; j<message.data.data.bots.length; j++) {
						if(self.m.s2.bots()[i]().id() == message.data.data.bots[j].id) {
							self.m.s2.bots()[i]().authorization(message.data.data.bots[j].authorization);
							self.m.s2.bots()[i]().authorization_last_update(message.data.data.bots[j].authorization_last_update);
							self.m.s2.bots()[i]().authorization_status_last_bug(message.data.data.bots[j].authorization_status_last_bug);
							self.m.s2.bots()[i]().authorization_last_bug(message.data.data.bots[j].authorization_last_bug);
							self.m.s2.bots()[i]().authorization_last_bug_code(message.data.data.bots[j].authorization_last_bug_code);
						}
					}
				}

			});

			// A4.3.3. Обработка сообщений об успешной аутентификации через Steam //
			//--------------------------------------------------------------------//
			self.websocket.ws1.on(server.data.websockets_channel, function(message) {

				// 1] Сообщить об успешной аутентификации через Steam
				notify({msg: 'Successful auth with Steam!', time: 5, fontcolor: 'RGB(50,120,50)'});
				console.log('Successful auth with Steam!');

				// 2] Перезагрузить документ
				location.reload();

			});


	});


	//------------------------------------------------------------------//
	// 			        		 	                                              //
	// 			 s0. Библиотека данных, доступных всем прочим моделям  			//
	// 			         			                                              //
	//------------------------------------------------------------------//

	//------------------------------------------------//
	// s0.1. Объект-контейнер для всех свойств модели //
	//------------------------------------------------//
	self.m.s0 = {};

	//---------------------------------------------------------------------//
	// s0.2. Модель "механизма отложенного сохранения для текстовых полей" //
	//---------------------------------------------------------------------//
	self.m.s0.txt_delay_save = {};

		//-------------------------//
		// s0.2.1. Свойства модели //
		//-------------------------//

			// 1] Через сколько мс после послед.редакт. выполнять сохранение
			//--------------------------------------------------------------------//
			self.m.s0.txt_delay_save.gap = 2000;

			// 2] Свойство для сохранения timestamp послед.редактирования //
			//-----------------------------------------------------------------//
			self.m.s0.txt_delay_save.lastupdate = ko.observable(Date.now());

			// 3] Свойство для сохранения id последнего установленного таймера //
			//----------------------------------------------------------------------//
			self.m.s0.txt_delay_save.settimeoutid = ko.observable();

			// 4] Есть ли не сохранённые данные (для предотвращения закрытия документа) //
			//-------------------------------------------------------------------------------//
			self.m.s0.txt_delay_save.is_unsaved_data = ko.observable();

		//--------------------------------//
		// s0.2.2. Назначение обработчика //
		//--------------------------------//
		// - он будет запрашивать confirm, если есть не сохранённые данные
		ko.computed(function(){

			// Если это не первый запуск, завершить
			if(!ko.computedContext.isInitial()) return;

			// Назначить событию beforeunload функцию обработчик
			// - Она должна проверять свойство self.m.s0.save.is_unsaved_data()
			// - Если оно равно 1, то с помощью confirm уведомлять пользователя.
			//   о возможной потере данных при выходе.
			addEvent(window, 'beforeunload', function(event, params){

				if(self.m.s0.txt_delay_save.is_unsaved_data() == 1) {
					var message = "В документе есть не сохранённые данные, его закрытие приведёт к их потере. Вы уверены, что хотите закрыть документ?";
					event.returnValue = message;
				}

			}, {});

		});

	//----------------------------------------------//
	// s0.3. Счётчик ожидающих ответа ajax-запросов //
	//----------------------------------------------//
	self.m.s0.ajax_counter = ko.observable(0);

	//--------------------------------------------------------//
	// s0.4. Таймеры для функций, осуществляющих ajax-запросы //
	//--------------------------------------------------------//
	// - С их помощью можно игнорировать устаревшие ajax-ответы.
	self.m.s0.ajax_timers = {};

	//---------------------------------------//
	// s0.5. Виден ли щит "идёт ajax-запрос" //
	//---------------------------------------//
	self.m.s0.is_loadshield_on = ko.observable(0);
	ko.computed(function(){

		if(self.m.s0.ajax_counter() > 0)
			self.m.s0.is_loadshield_on(1);
		else
			self.m.s0.is_loadshield_on(0);

	});

	//---------------------------------//
	// s0.6. Аутентификационная модель //
	//---------------------------------//
	self.m.s0.auth = {};

		// 1] Аутентифицирован ли пользователь, как анонимный (гость) //
		//------------------------------------------------------------//
		self.m.s0.auth.is_anon = ko.observable(-1);

		// 2] Данные об аутентифицированном пользователе //
		//-----------------------------------------------//
		self.m.s0.auth.user = ko.observable({});

		// 3] Данные об аутентификационной записи пользователя //
		//-----------------------------------------------------//
		self.m.s0.auth.auth = ko.observable({});

		// 4] Вошёл ли пользователь в аккаунт //
		//------------------------------------//
		self.m.s0.is_logged_in = ko.observable(false);

		// n] Приём и обработка аутентификационных данных при 1-й загрузке //
		//-----------------------------------------------------------------//
		ko.computed(function(){

			// n.1] Если это не первый запуск, завершить
			if(!ko.computedContext.isInitial()) return;

			// n.2] Если сервер не прислал данные, завершить
			if(!server || !server.data || !server.data.auth) return;

			// n.3] Распаковать данные, и проверить
			var auth = JSON.parse(server.data.auth);
			if((!auth.is_anon && auth.is_anon != 0) || !auth.user || !auth.auth) return;

			// n.4] Наполнить m.s0.auth.is_anon
			self.m.s0.auth.is_anon(auth.is_anon);

			// n.5] Наполнить m.s0.auth.user
			for(var key in auth.user) {

				// 1] Если свойство не своё, пропускаем
				if(!auth.user.hasOwnProperty(key)) continue;

				// 2] Добавим свойство key в m.s0.auth.user
				self.m.s0.auth.user()[key] = ko.observable(auth.user[key]);

			}

			// n.6] Наполнить m.s0.auth.auth
			for(var key in auth.auth) {

				// 1] Если свойство не своё, пропускаем
				if(!auth.auth.hasOwnProperty(key)) continue;

				// 2] Добавим свойство key в m.s0.auth.auth
				self.m.s0.auth.auth()[key] = ko.observable(auth.auth[key]);

			}

			// n.7] Наполнить is_logged_in
			(function(){

				// Если пользователь "Not authenticated", записать false
				if(!self.m.s0.auth.user() || !self.m.s0.auth.user().id || !self.m.s0.auth.user().id())
					self.m.s0.is_logged_in(false);

				// Если этот анонимный пользователь, записать false
				else if(self.m.s0.auth.is_anon() != 0)
					self.m.s0.is_logged_in(false);

				// В противном случае, записать true
				else
					self.m.s0.is_logged_in(true);

			})();

		});


	//-----------------------------------------------------------//
	// 			        		 	                                       //
	// 			 s1. Модель управления поддокументами приложения 		 //
	// 			         			                                       //
	//-----------------------------------------------------------//

	//------------------------------------------------//
	// s1.1. Объект-контейнер для всех свойств модели //
	//------------------------------------------------//
	self.m.s1 = {};

	//---------------------------------------//
	// s1.2. Группы поддокументов приложения //
	//---------------------------------------//

		// 1] Наблюдаемый массив групп поддокументов приложения //
		//------------------------------------------------------//
		self.m.s1.groups = ko.observableArray([

			ko.observable({
				id: ko.observable('1'),
				name: ko.observable('Bots')
			}),
			ko.observable({
				id: ko.observable('2'),
				name: ko.observable('Bot')
			})

		]);

		// 2] Выбранная группа поддокументов приложения //
		//----------------------------------------------//
		self.m.s1.selected_group = ko.observable(self.m.s1.groups()[0]());

	//---------------------------------------------------//
	// s1.3. Наблюдаемый массив поддокументов приложения //
	//---------------------------------------------------//

		// 1] Наблюдаемый массив поддокументов приложения //
		//------------------------------------------------//
		self.m.s1.subdocs = ko.observableArray([

			// Поддокументы группы №1
			ko.observable({
				id: ko.observable('1'),
				name: ko.observable('Bots'),
				query: ko.observable('?group=bots'),
				group: ko.observable('1')
			}),

			// Поддокументы группы №2
			ko.observable({
				id: ko.observable('100'),
				name: ko.observable('Properties'),
				query: ko.observable('?group=bot&subdoc=properties'),
				group: ko.observable('2')
			}),
			ko.observable({
				id: ko.observable('101'),
				name: ko.observable('Authcode'),
				query: ko.observable('?group=bot&subdoc=authcode'),
				group: ko.observable('2')
			}),
			ko.observable({
				id: ko.observable('102'),
				name: ko.observable('Authorization'),
				query: ko.observable('?group=bot&subdoc=authorization'),
				group: ko.observable('2')
			}),
			ko.observable({
				id: ko.observable('103'),
				name: ko.observable('Newtrade'),
				query: ko.observable('?group=bot&subdoc=newtrade'),
				group: ko.observable('2')
			}),
			ko.observable({
				id: ko.observable('104'),
				name: ko.observable('Tradeoffers'),
				query: ko.observable('?group=bot&subdoc=tradeoffers'),
				group: ko.observable('2')
			})
		]);

		// 2] Выбранный поддокумент приложения //
		//------------------------------------//
		self.m.s1.selected_subdoc = ko.observable(self.m.s1.subdocs()[0]());

	//--------------------------------------//
	// s1.n. Индексы и вычисляемые значения //
	//--------------------------------------//
	ko.computed(function(){

		//--------------------------------------------------------------//
		// s1.n.1. Объект-контейнер для индексов и вычисляемых значений //
		//--------------------------------------------------------------//
		self.m.s1.indexes = {};

		//-------------------------------------//
		// s1.n.2. Индексы групп поддокументов //
		//-------------------------------------//

			// 1] Индекс групп поддокументов //
			//-------------------------------//
			// - По ID группы поддокумента можно получить ссылку на соотв. объект в self.m.s1.groups
			self.m.s1.indexes.groups = (function(){

				// 1. Подготовить объект для результатов
				var results = {};

				// 2. Заполнить results
				for(var i=0; i<self.m.s1.groups().length; i++) {
					results[self.m.s1.groups()[i]().id()] = self.m.s1.groups()[i]();
				}

				// 3. Вернуть results
				return results;

			}());

			// 2] Индекс поддокументов //
			//-------------------------//
			// - По name группы поддокумента можно получить ссылку на соотв. объект в self.m.s1.groups
			self.m.s1.indexes.groups_by_name = (function(){

				// 1. Подготовить объект для результатов
				var results = {};

				// 2. Заполнить results
				for(var i=0; i<self.m.s1.groups().length; i++) {
					results[self.m.s1.groups()[i]().name().toLowerCase()] = self.m.s1.groups()[i]();
				}

				// 3. Вернуть results
				return results;

			}());


		//-------------------------------//
		// s1.n.3. Индексы поддокументов //
		//-------------------------------//

			// 1] Индекс поддокументов //
			//-------------------------//
			// - По ID поддокумента можно получить ссылку на соотв. объект в self.m.s1.subdocs
			self.m.s1.indexes.subdocs = (function(){

				// 1. Подготовить объект для результатов
				var results = {};

				// 2. Заполнить results
				for(var i=0; i<self.m.s1.subdocs().length; i++) {
					results[self.m.s1.subdocs()[i]().id()] = self.m.s1.subdocs()[i]();
				}

				// 3. Вернуть results
				return results;

			}());

			// 2] Индекс поддокументов //
			//-------------------------//
			// - По name поддокумента можно получить ссылку на соотв. объект в self.m.s1.subdocs
			self.m.s1.indexes.subdocs_by_name = (function(){

				// 1. Подготовить объект для результатов
				var results = {};

				// 2. Заполнить results
				for(var i=0; i<self.m.s1.subdocs().length; i++) {
					results[self.m.s1.subdocs()[i]().name().toLowerCase()] = self.m.s1.subdocs()[i]();
				}

				// 3. Вернуть results
				return results;

			}());


	});


	//-------------------------------------------------------------//
	// 			        		 	                                         //
	// 			 s2. Модель группы документов, связанных с ботами 		 //
	// 			         			                                         //
	//-------------------------------------------------------------//

	//------------------------------------------------//
	// s2.1. Объект-контейнер для всех свойств модели //
	//------------------------------------------------//
	self.m.s2 = {};

	//----------------------------------------------//
	// s2.2. Наблюдаемый массив с элементами-ботами //
	//----------------------------------------------//
	self.m.s2.bots = ko.observableArray([]);

	//--------------------------------------------//
	// s2.3. Модель чекбокса "Выбрать всех ботов" //
	//--------------------------------------------//
	self.m.s2.select_all_bots = ko.observable(false);

	//-------------------//
	// s2.4. Ботов всего //
	//-------------------//
  self.m.s2.bots_total = ko.observable(0);

	//--------------------------------------------------------------------------------------------//
	// s2.5. Кол-во выделенных ботов (зависит ещё от того, стоит ли галочка "Выбрать всех ботов") //
	//--------------------------------------------------------------------------------------------//
	self.m.s2.num_of_selected_bots = ko.computed(function(){

		var result = 0;
		if(self.m.s2.select_all_bots()) result = self.m.s2.bots_total();
		else {
			for(var i=0; i<self.m.s2.bots().length; i++) {
				if(self.m.s2.bots()[i]().selected()) result = +result+1;
			}
		}
		return result;

	});

	//----------------------------------//
	// s2.6. Модель редактирования бота //
	//----------------------------------//
	self.m.s2.edit = {};

		self.m.s2.edit.login 													= ko.observable("");
		self.m.s2.edit.password 											= ko.observable("");
		self.m.s2.edit.steamid 												= ko.observable("");
		self.m.s2.edit.shared_secret 									= ko.observable("");
		self.m.s2.edit.serial_number 									= ko.observable("");
		self.m.s2.edit.revocation_code 								= ko.observable("");
		self.m.s2.edit.uri 														= ko.observable("");
		self.m.s2.edit.server_time 										= ko.observable("");
		self.m.s2.edit.account_name 									= ko.observable("");
		self.m.s2.edit.token_gid 											= ko.observable("");
		self.m.s2.edit.identity_secret 								= ko.observable("");
		self.m.s2.edit.secret_1 											= ko.observable("");
		self.m.s2.edit.device_id 											= ko.observable("");
		self.m.s2.edit.apikey 												= ko.observable("");
		self.m.s2.edit.apikey_domain									= ko.observable("");
		self.m.s2.edit.apikey_last_update	  					= ko.observable("");
		self.m.s2.edit.apikey_last_bug								= ko.observable("");
		self.m.s2.edit.trade_url											= ko.observable("");
		self.m.s2.edit.avatar_steam 									= ko.observable("");

		self.m.s2.edit.id   													= ko.observable("");
		self.m.s2.edit.ison_incoming 									= ko.observable("");
		self.m.s2.edit.ison_outcoming 								= ko.observable("");

		self.m.s2.edit.steam_name       							= ko.observable("");

		self.m.s2.edit.authorization    							= ko.observable("");
		self.m.s2.edit.authorization_status_last_bug 	= ko.observable("");
		self.m.s2.edit.authorization_last_bug 				= ko.observable("");
		self.m.s2.edit.authorization_last_bug_code  	= ko.observable("");

		self.m.s2.edit.captchagid                     = ko.observable("");
		self.m.s2.edit.captcha_text                   = ko.observable("");

	//-------------------------------------------------------------//
	// s2.7. Модель опций для эл-в select со значениями true/false //
	//-------------------------------------------------------------//
	self.m.s2.options_true_false = ko.observableArray([
		ko.observable({
			value: ko.observable('0'),
			name: ko.observable('off')
		}),
		ko.observable({
			value: ko.observable('1'),
			name: ko.observable('on')
		})
	]);

	//------------------------------------//
	// s2.8. Модель ошибок обновления цен //
	//------------------------------------//
	self.m.s2.price_update_errors = {};

		//---------------------------------------//
		// s2.8.1. Объект-контейнер для индексов //
		//---------------------------------------//
		self.m.s2.price_update_errors.csgofast_last_bug = ko.observable("");

		//---------------------------------------//
		// s2.8.2. Объект-контейнер для индексов //
		//---------------------------------------//
		self.m.s2.price_update_errors.steammarket_last_bug = ko.observable("");

	//--------------------------------------//
	// s2.n. Индексы и вычисляемые значения //
	//--------------------------------------//
	ko.computed(function(){

		//---------------------------------------//
		// s2.n.1. Объект-контейнер для индексов //
		//---------------------------------------//
		self.m.s2.indexes = {};

		//----------------------//
		// s2.n.2. Индекс ботов //
		//----------------------//
		// - По ID бота можно получить ссылку на него в m.s2.bots
		self.m.s2.indexes.bots = (function(){

			// 1. Подготовить массив для результатов
			var results = [];

			// 2. Заполнить results
			for(var i=0; i<self.m.s2.bots().length; i++) {
				results[self.m.s2.bots()[i]().id()] = self.m.s2.bots()[i]();
			}

			// 3. Вернуть results
			return results;

		}());

	});


	//-------------------------------------------------//
	// 			        		 	                             //
	// 			 s3. Модель инвентаря выбранного бота 		 //
	// 			         			                             //
	//-------------------------------------------------//

	//------------------------------------------------//
	// s3.1. Объект-контейнер для всех свойств модели //
	//------------------------------------------------//
	self.m.s3 = {};

	//------------------------------------------------------------//
	// s3.2. Наблюдаемый массив с элементами-предметами инвентаря //
	//------------------------------------------------------------//
	self.m.s3.inventory = ko.observableArray([]);

	//----------------------------------------------------------//
	// s3.3. Общее количество вещей в инвентаре выбранного бота //
	//----------------------------------------------------------//
	self.m.s3.inventory_total = ko.observable(0);

	//---------------------------------------------------------------------//
	// s3.4. Общее количество выделенных вещей в инвентаре выбранного бота //
	//---------------------------------------------------------------------//
	self.m.s3.inventory_selected = ko.observable(0);

	//-----------------------------------------------------------------//
	// s3.5. Объект с экземпляром scroll для инвентаря выбранного бота //
	//-----------------------------------------------------------------//
	self.m.s3.scroll = ko.observable("");

	//-------------------------------------------//
	// s3.6. Идёт ли сейчас ajax-запрос, или нет //
	//-------------------------------------------//
	self.m.s3.is_ajax_invoking = ko.observable(false);

	//---------------------------------//
	// s3.7. Строка поиска в инвентаре //
	//---------------------------------//
	self.m.s3.search_string = ko.observable('');

	//------------------------------------------------------------------------//
	// s3.8. Массив с assetid эл-в инвентаря, прошедших фильтр строкой поиска //
	//------------------------------------------------------------------------//
	self.m.s3.found_inventory_items = ko.observableArray([]);

	//---------------------------------------------------------------//
	// s3.9. Массив с assetid эл-в инвентаря, выбранных для торговли //
	//---------------------------------------------------------------//
	self.m.s3.inventory_items2trade = ko.observableArray([]);

	//-------------------------------------------------------//
	// s3.10. Суммарная стоимость выбранных для отдачи вещей //
	//-------------------------------------------------------//
	self.m.s3.items2trade_sumprice = ko.observable('');


	//--------------------------------------//
	// s3.n. Индексы и вычисляемые значения //
	//--------------------------------------//
	ko.computed(function(){

		//---------------------------------------//
		// s3.n.1. Объект-контейнер для индексов //
		//---------------------------------------//
		self.m.s3.indexes = {};

		//------------------------------------------------------------//
		// s3.n.2. Общее количество вещей в инвентаре выбранного бота //
		//------------------------------------------------------------//
		(function(){

			// 1] Подготовить объект для результатов
			var results = 0;

			// 2] Заполнить results
			for(var i=0; i<self.m.s3.inventory().length; i++) {
				results = +results + 1;
			}

			// 3] Записать results
			self.m.s3.inventory_total(results);

		}());

		//-----------------------------------------------------------------------//
		// s3.n.3. Общее количество выделенных вещей в инвентаре выбранного бота //
		//-----------------------------------------------------------------------//
		(function(){

			// 1] Подготовить объект для результатов
			var results = 0;

			// 2] Заполнить results
			for(var i=0; i<self.m.s3.inventory().length; i++) {
				if(self.m.s3.inventory()[i]().selected())
					results = +results + 1;
			}

			// 3] Записать results
			self.m.s3.inventory_selected(results);

		}());

		//------------------------------------------------------------------------------------//
		// s3.n.4. Наполнить массив с assetid эл-в инвентаря, прошедших фильтр строкой поиска //
		//------------------------------------------------------------------------------------//
		(function(){

			// 1] Очистить массив m.s3.found_inventory_items
			self.m.s3.found_inventory_items.removeAll();

			// 2] Наполнить массив m.s3.found_inventory_items
			for(var i=0; i<self.m.s3.inventory().length; i++) {

				// 2.1] Если строка поиска пуста, добавить assetid i-го элемента
				if(!self.m.s3.search_string())
					self.m.s3.found_inventory_items.push(self.m.s3.inventory()[i]().assetid());

				// 2.2] Если не пуст, провести валидацию, и если OK, добавить assetid i-го элемента
				else {
					if((new RegExp(self.m.s3.search_string(),'i')).test(self.m.s3.inventory()[i]().name()))
						self.m.s3.found_inventory_items.push(self.m.s3.inventory()[i]().assetid());
				}

			}

		}());

		//---------------------------------------------------------------------------//
		// s3.n.5. Наполнить массив с assetid эл-в инвентаря, выбранных для торговли //
		//---------------------------------------------------------------------------//
		(function(){

			// 1] Очистить массив m.s3.inventory_items2trade
			self.m.s3.inventory_items2trade.removeAll();

			// 2] Наполнить массив m.s3.found_inventory_items
			for(var i=0; i<self.m.s3.inventory().length; i++) {

				// 2.1] Если i-й элемент выбран, добавить его assetid в inventory_items2trade
				if(self.m.s3.inventory()[i]().selected())
					self.m.s3.inventory_items2trade.push(self.m.s3.inventory()[i]().assetid());

			}

		}());

		//-------------------------------------------------------------------//
		// s3.n.6. Подсчитать суммарную стоимость выбранных для отдачи вещей //
		//-------------------------------------------------------------------//
		(function(){

			// 1] Если никакие вещи не выбраны, записать 0
			if(!self.m.s3.inventory_items2trade().length)
				self.m.s3.items2trade_sumprice(0);

			// 2] В противном случае, подсчитать суммарную стоимость, и записать
			var price = 0;
			for(var i=0; i<self.m.s3.inventory().length; i++) {

				// 2.1] Если i-й эл-т не в m.s3.inventory_items2trade, перейти к след.итерации
				if(self.m.s3.inventory_items2trade.indexOf(self.m.s3.inventory()[i]().assetid()) == -1)
					continue;

				// 2.2] В противном случае, добавить цену i-го эл-та к price
				price = +price + +self.m.s3.inventory()[i]().price();

			}

			// 3] Записать price в m.s3.items2trade_sumprice
			self.m.s3.items2trade_sumprice(price);

		}());

	});


	//---------------------------------------------------------------------//
	// 			        		 	                                                 //
	// 			 s4. Модель генератора мобильных аутентификационных кодов 		 //
	// 			         			                                                 //
	//---------------------------------------------------------------------//

	//------------------------------------------------//
	// s4.1. Объект-контейнер для всех свойств модели //
	//------------------------------------------------//
	self.m.s4 = {};

	//---------------------------------------//
	// s4.2. Текущий код для выбранного бота //
	//---------------------------------------//
	self.m.s4.code = ko.observable('H8YGB');

	//----------------------------------------------------------//
	// s4.3. Сколько секунд осталось до истечения текущего кода //
	//----------------------------------------------------------//
	self.m.s4.expires_in_secs = ko.observable('');

	//---------------------------------------------------------------------//
	// s4.4. Временная метка клиентского времени последнего получения кода //
	//---------------------------------------------------------------------//
	self.m.s4.last_code_update_timestamp = ko.observable('');

	//-----------------------------------------------------------------------------//
	// s4.5. Обновляемая таймером каждые N секунд временная метка текущего времени //
	//-----------------------------------------------------------------------------//
	self.m.s4.now = ko.observable('');

	//----------------------------------------------------//
	// s4.6. Валиден ли текущий отображаемый код, или нет //
	//----------------------------------------------------//
	self.m.s4.is_current_code_valid = ko.computed(function(){

		// 1] Получить все необходимые временные метки
		var now 						= self.m.s4.now();
		var last 						= self.m.s4.last_code_update_timestamp();
		var expires_in_secs = self.m.s4.expires_in_secs();

		// 2] Определить, пора ли обновлять код
		var isvalid = (function(){

			// 3.1] Если last или expires_in_secs или now пусты, то не валиден
			if(!last || !expires_in_secs || !now) return false;

			// 3.2] Если время пришло, то не валиден
			if(+now - +last > +expires_in_secs*1000) return false;

			// 3.3] Если код дошёл сюда, то валиден
			return true;

		})();

		// 3] Вернуть результат
		return isvalid;

	});

	//-----------------------------------------------//
	// s4.7. Сколько осталось жить текущему коду в % //
	//-----------------------------------------------//
	self.m.s4.expire_percents = ko.computed(function(){

		// 1] Получить все необходимые временные метки
		var now 						= self.m.s4.now();
		var last 						= self.m.s4.last_code_update_timestamp();
		var expires_in_secs = self.m.s4.expires_in_secs();

		// 2] Если last или expires_in_secs или now пусты, то 0%
		if(!last || !expires_in_secs || !now) return '0%';

		// 3] Подсчитать оставшееся время жизни
		var rest = Math.round((+expires_in_secs*1000 - (+now - +last))/1000);

		// 4] Подсчитать оставшееся время в % от 30 секунд, вернуть результат
		return Math.round((rest/30)*100) + '%';

	});

	//-------------------------------------------//
	// s4.8. Идёт ли сейчас ajax-запрос, или нет //
	//-------------------------------------------//
	self.m.s4.is_ajax_invoking = ko.observable(false);



	//--------------------------------------//
	// s4.n. Индексы и вычисляемые значения //
	//--------------------------------------//
	ko.computed(function(){

		//---------------------------------------//
		// s4.n.1. Объект-контейнер для индексов //
		//---------------------------------------//
		self.m.s4.indexes = {};

	});


	//-----------------------------------------//
	// 			        		 	                     //
	// 			 s5. Модель торгового партнёра 		 //
	// 			         			                     //
	//-----------------------------------------//

	//------------------------------------------------//
	// s5.1. Объект-контейнер для всех свойств модели //
	//------------------------------------------------//
	self.m.s5 = {};

	//-------------------------//
	// s5.2. Свойства партнёра //
	//-------------------------//

		// 1] Trade URL //
		//--------------//
		self.m.s5.trade_url = ko.observable('');

		// 2] Steam Name //
		//---------------//
		self.m.s5.steam_name_partner = ko.observable('');

		// 3] Steam ID //
		//-------------//
		self.m.s5.steamid_partner = ko.observable('');

		// 4] Partner ID //
		//---------------//
		self.m.s5.partner = ko.observable('');

		// 5] Partner Token //
		//------------------//
		self.m.s5.token = ko.observable('');

		// 6] Escrow hold, days //
		//----------------------//
		self.m.s5.escrow_days_partner = ko.observable('');

		// 7] Partner avatar URL //
		//-----------------------//
		self.m.s5.avatar = ko.observable('');


	//--------------------------------------//
	// s5.n. Индексы и вычисляемые значения //
	//--------------------------------------//
	ko.computed(function(){

		//---------------------------------------//
		// s5.n.1. Объект-контейнер для индексов //
		//---------------------------------------//
		self.m.s5.indexes = {};

	});


	//---------------------------------------------------//
	// 			        		 	                               //
	// 			 s6. Модель инвентаря торгового партнёра 		 //
	// 			         			                               //
	//---------------------------------------------------//

	//------------------------------------------------//
	// s6.1. Объект-контейнер для всех свойств модели //
	//------------------------------------------------//
	self.m.s6 = {};

	//------------------------------------------------------------//
	// s6.2. Наблюдаемый массив с элементами-предметами инвентаря //
	//------------------------------------------------------------//
	self.m.s6.inventory = ko.observableArray([]);

	//-------------------------------------------------------------//
	// s6.3. Общее количество вещей в инвентаре торгового партнёра //
	//-------------------------------------------------------------//
	self.m.s6.inventory_total = ko.observable(0);

	//------------------------------------------------------------------------//
	// s6.4. Общее количество выделенных вещей в инвентаре торгового партнёра //
	//------------------------------------------------------------------------//
	self.m.s6.inventory_selected = ko.observable(0);

	//--------------------------------------------------------------------//
	// s6.5. Объект с экземпляром scroll для инвентаря торгового партнёра //
	//--------------------------------------------------------------------//
	self.m.s6.scroll = ko.observable("");

	//-------------------------------------------//
	// s6.6. Идёт ли сейчас ajax-запрос, или нет //
	//-------------------------------------------//
	self.m.s6.is_ajax_invoking = ko.observable(false);

	//---------------------------------//
	// s6.7. Строка поиска в инвентаре //
	//---------------------------------//
	self.m.s6.search_string = ko.observable('');

	//------------------------------------------------------------------------//
	// s6.8. Массив с assetid эл-в инвентаря, прошедших фильтр строкой поиска //
	//------------------------------------------------------------------------//
	self.m.s6.found_inventory_items = ko.observableArray([]);

	//---------------------------------------------------------------//
	// s6.9. Массив с assetid эл-в инвентаря, выбранных для торговли //
	//---------------------------------------------------------------//
	self.m.s6.inventory_items2trade = ko.observableArray([]);

	//----------------------------------------------------------//
	// s6.10. Суммарная стоимость выбранных для получения вещей //
	//----------------------------------------------------------//
	self.m.s6.items2trade_sumprice = ko.observable('');


	//--------------------------------------//
	// s6.n. Индексы и вычисляемые значения //
	//--------------------------------------//
	ko.computed(function(){

		//---------------------------------------//
		// s6.n.1. Объект-контейнер для индексов //
		//---------------------------------------//
		self.m.s6.indexes = {};

		//---------------------------------------------------------------//
		// s6.n.2. Общее количество вещей в инвентаре торгового партнёра //
		//---------------------------------------------------------------//
		(function(){

			// 1] Подготовить объект для результатов
			var results = 0;

			// 2] Заполнить results
			for(var i=0; i<self.m.s6.inventory().length; i++) {
				results = +results + 1;
			}

			// 3] Записать results
			self.m.s6.inventory_total(results);

		}());

		//--------------------------------------------------------------------------//
		// s6.n.3. Общее количество выделенных вещей в инвентаре торгового партнёра //
		//--------------------------------------------------------------------------//
		(function(){

			// 1] Подготовить объект для результатов
			var results = 0;

			// 2] Заполнить results
			for(var i=0; i<self.m.s6.inventory().length; i++) {
				if(self.m.s6.inventory()[i]().selected())
					results = +results + 1;
			}

			// 3] Записать results
			self.m.s6.inventory_selected(results);

		}());

		//------------------------------------------------------------------------------------//
		// s6.n.4. Наполнить массив с assetid эл-в инвентаря, прошедших фильтр строкой поиска //
		//------------------------------------------------------------------------------------//
		(function(){

			// 1] Очистить массив m.s6.found_inventory_items
			self.m.s6.found_inventory_items.removeAll();

			// 2] Наполнить массив m.s6.found_inventory_items
			for(var i=0; i<self.m.s6.inventory().length; i++) {

				// 2.1] Если строка поиска пуста, добавить assetid i-го элемента
				if(!self.m.s6.search_string())
					self.m.s6.found_inventory_items.push(self.m.s6.inventory()[i]().assetid());

				// 2.2] Если не пуст, провести валидацию, и если OK, добавить assetid i-го элемента
				else {
					if((new RegExp(self.m.s6.search_string(),'i')).test(self.m.s6.inventory()[i]().name()))
						self.m.s6.found_inventory_items.push(self.m.s6.inventory()[i]().assetid());
				}

			}

		}());

		//---------------------------------------------------------------------------//
		// s6.n.5. Наполнить массив с assetid эл-в инвентаря, выбранных для торговли //
		//---------------------------------------------------------------------------//
		(function(){

			// 1] Очистить массив m.s6.inventory_items2trade
			self.m.s6.inventory_items2trade.removeAll();

			// 2] Наполнить массив m.s6.found_inventory_items
			for(var i=0; i<self.m.s6.inventory().length; i++) {

				// 2.1] Если i-й элемент выбран, добавить его assetid в inventory_items2trade
				if(self.m.s6.inventory()[i]().selected())
					self.m.s6.inventory_items2trade.push(self.m.s6.inventory()[i]().assetid());

			}

		}());

		//----------------------------------------------------------------------//
		// s6.n.6. Подсчитать суммарную стоимость выбранных для получения вещей //
		//----------------------------------------------------------------------//
		(function(){

			// 1] Если никакие вещи не выбраны, записать 0
			if(!self.m.s6.inventory_items2trade().length)
				self.m.s6.items2trade_sumprice(0);

			// 2] В противном случае, подсчитать суммарную стоимость, и записать
			var price = 0;
			for(var i=0; i<self.m.s6.inventory().length; i++) {

				// 2.1] Если i-й эл-т не в m.s6.inventory_items2trade, перейти к след.итерации
				if(self.m.s6.inventory_items2trade.indexOf(self.m.s6.inventory()[i]().assetid()) == -1)
					continue;

				// 2.2] В противном случае, добавить цену i-го эл-та к price
				price = +price + +self.m.s6.inventory()[i]().price();

			}

			// 3] Записать price в m.s6.items2trade_sumprice
			self.m.s6.items2trade_sumprice(price);

		}());

	});


	//-----------------------------------------------------------//
	// 			        		 	                                       //
	// 			 s7. Модель торговых предложений выбранного бота 		 //
	// 			         			                                       //
	//-----------------------------------------------------------//

	//------------------------------------------------//
	// s7.1. Объект-контейнер для всех свойств модели //
	//------------------------------------------------//
	self.m.s7 = {};

	//-------------------------------------------------------------------------//
	// s7.2. Наблюдаемый массив со входящими активными торговыми предложениями //
	//-------------------------------------------------------------------------//
	self.m.s7.tradeoffers_incoming = ko.observableArray([]);

	//-------------------------------------------------------------------------//
	// s7.3. Наблюдаемый массив со входящими закрытыми торговыми предложениями //
	//-------------------------------------------------------------------------//
	self.m.s7.tradeoffers_incoming_history = ko.observableArray([]);

	//-------------------------------------------------------------------------//
	// s7.4. Наблюдаемый массив с исходящими активными торговыми предложениями //
	//-------------------------------------------------------------------------//
	self.m.s7.tradeoffers_sent = ko.observableArray([]);

	//-------------------------------------------------------------------------//
	// s7.5. Наблюдаемый массив с исходящими закрытыми торговыми предложениями //
	//-------------------------------------------------------------------------//
	self.m.s7.tradeoffers_sent_history = ko.observableArray([]);

	//----------------------------------//
	// s7.6. Включить ли автообновление //
	//----------------------------------//
	self.m.s7.auto_update = ko.observable(false);

	//------------------------------------------------------//
	// s7.7. Модель блока radio-кнопок торговых предложений //
	//------------------------------------------------------//
	self.m.s7.types = {};

		// 1] Опции //
		//----------//
		self.m.s7.types.options = ko.observableArray([
			ko.observable({
				id: ko.observable('options_types1'),
				name: ko.observable('options_types'),
				text: ko.observable('Incoming'),
				value: ko.observable('1')
			}),
			ko.observable({
				id: ko.observable('options_types2'),
				name: ko.observable('options_types'),
				text: ko.observable('Incoming History'),
				value: ko.observable('2')
			}),
			ko.observable({
				id: ko.observable('options_types3'),
				name: ko.observable('options_types'),
				text: ko.observable('Sent'),
				value: ko.observable('3')
			}),
			ko.observable({
				id: ko.observable('options_types4'),
				name: ko.observable('options_types'),
				text: ko.observable('Sent History'),
				value: ko.observable('4')
			})
		]);

		// 2] Выбранная опция //
		//--------------------//
		self.m.s7.types.choosen = ko.observable('1');

	//-------------------------------------------//
	// s7.8. Идёт ли сейчас ajax-запрос, или нет //
	//-------------------------------------------//
	self.m.s7.is_ajax_invoking = ko.observable(false);


	//--------------------------------------//
	// s7.n. Индексы и вычисляемые значения //
	//--------------------------------------//
	ko.computed(function(){

		//---------------------------------------//
		// s7.n.1. Объект-контейнер для индексов //
		//---------------------------------------//
		self.m.s7.indexes = {};


	});



	//------------------------------------------------------------//
	// 			        		 	                                        //
	// 			 sN. Данные, которым доступны все прочие данные  			//
	// 			         			                                        //
	//------------------------------------------------------------//

	//------------------------------------------------//
	// sN.1. Объект-контейнер для всех свойств модели //
	//------------------------------------------------//
	self.m.sN = {};

	//-------------------------------------------------------//
	// sN.2. 	 //
	//-------------------------------------------------------//



	//--------------------------------------//
	// sN.n. Индексы и вычисляемые значения //
	//--------------------------------------//
	ko.computed(function(){

		//---------------------------------------//
		// sN.n.1. Объект-контейнер для индексов //
		//---------------------------------------//
		self.m.sN.indexes = {};


	});

	//----------------------------------------//
	// 			        		 	                    //
	// 			 X. Подготовка к завершению  			//
	// 			         			                    //
	//----------------------------------------//

	//----------------------------------------//
	// X1. Сервис провайдер клиентской модели //
	//----------------------------------------//
	// - Код здесь выполняется лишь 1 раз, при открытии документа в браузере.
	// - Отличное место, скажем, для назначения обработчиков событий.
	ko.computed(function(){

		//-------------------------------------------------------------//
		// X1.1. Выполнять код ниже лишь 1 раз, при загрузке документа //
		//-------------------------------------------------------------//
		if(!ko.computedContext.isInitial()) return;

		//-------------------------------------------------//
		// X1.2. Добавление в историю стартового состояния //
		//-------------------------------------------------//
		//History.pushState({state:self.m.s1.selected_subdoc().id()}, self.m.s1.selected_subdoc().name(), self.m.s1.selected_subdoc().query());

		//--------------------------------------------------------------------------//
		// X1.3. На основе параметров page и subdoc с сервера открыть соотв.докуент //
		//--------------------------------------------------------------------------//
		// - И заодно добавить стартовое состояние.
		// - А также назначить функцию-обработчик, срабатывающую при смене состояния.
		(function(){

			// 1] На основе параметров page и subdoc с сервера открыть соотв.докуент, добавить стартовое состояние.
			self.f.s1.choose_subdoc({
				group: server.data.group,
				subdoc: server.data.subdoc,
				reload: false,
				first: true
			}, '', '');

			// 2] Назначить функцию-обработчик, срабатывающую при смене состояния
			History.Adapter.bind(window, 'statechange', function() {

				// 1] Получить текущее новое состояние
				var state = History.getState();
				var state_id = state.data.state;

				// 2] Если состояния приложения и истории расходятся
				// - То привести состояние приложения в соответствие
				if(self.m.s1.selected_subdoc().id() != state_id) {

					// 2.1] Получить объект поддокумента
					var subdoc = self.m.s1.indexes.subdocs[state_id];

					// 2.2] Если subdoc не найден, вернуть ошибку и завершить
					if(!subdoc) {
						console.log('Ошибка: при смене состояния истории не найден поддокумент.');
						return;
					}

					// 2.3] Получить группу поддокумента
					var group = self.m.s1.indexes.groups[subdoc.group()];

					// 2.4] Если group не найдена, вернуть ошибку и завершить
					if(!group) {
						console.log('Ошибка: при смене состояния истории не найдена группа поддокумента.');
						return;
					}

					// 2.5] Сменить состояние
					self.f.s1.choose_subdoc({
						group: group.name().toLowerCase(),
						subdoc: subdoc.name().toLowerCase()
					});

				}

			});

		})();

		//---------------------------------------------------------------------//
		// X1.4. Обновить модель ботов на основе переданных в аргументе данных //
		//---------------------------------------------------------------------//
		(function(){

			self.f.s0.update_bots(server.data.bots.data);

		})();

		//--------------------------------------------------------------------------------//
		// X1.5. В интерфейсе бота каждую секунду проверять, не пора ли обновить код бота //
		//--------------------------------------------------------------------------------//
		setInterval(function(){

			// 1] Если выбран не поддокумент с интерфейсом бота, завершить
			// - Или если включен ajax-экран
			if(self.m.s1.selected_group().name() != "Bot" || self.m.s1.selected_subdoc().name() != "Authcode" || self.m.s0.ajax_counter() != 0) return;

			// 2] Получить все необходимые временные метки
			var now 						= Date.now();
			  self.m.s4.now(now);
			var last 						= self.m.s4.last_code_update_timestamp();
			var expires_in_secs = self.m.s4.expires_in_secs();
			var code 						= self.m.s4.code();

			// 3] Определить, пора ли обновлять код
			var itstime = (function(){

				// 3.1] Если last или expires_in_secs или code пусты, то пора
				if(!last || !expires_in_secs || !code) return true;

				// 3.2] Если время пришло, значит пора
				if(+Date.now() - +last > +expires_in_secs*1000) return true;

				// 3.3] Если код дошёл сюда, значит не пора
				return false;

			})();

			// 4] Обновить код мобильного аутентификатора для выбранного бота
			if(itstime && !self.m.s4.is_ajax_invoking()) self.f.s4.update();

		}, 1000);

		//-----------------------------------------------------//
		// X1.6. Обновить модель ошибок обновления цен на вещи //
		//-----------------------------------------------------//
		(function(){

			self.f.s0.upd_price_update_errors(server.data.price_update_errors);

		})();

		//--------------------------------------------------------------------------//
		// X1.7. Каждую минуту обновлять массив с выбранным типом торговых операций //
		//--------------------------------------------------------------------------//
		(function(){

			// Установить таймер
			setInterval(function(){

				// 1] Если автоматическое обновление отключено, завершить
				if(!self.m.s7.auto_update()) return;

				// 2] Если выбран не поддокумент группы №2, закончить
				if(self.m.s1.selected_group().id() != 2) return;

				// 3] Выполнить обновление
				self.f.s7.update({silent: true});

			}, 1000*60);

		})();

		//---------------------------------------------------------------------------//
		// X1.8. Подписаться на изменение значения выбранного типа торговых операций //
		//---------------------------------------------------------------------------//
		(function(){

			self.m.s7.types.choosen.subscribe(function(newValue) {

				// Тихо обновить наблюдаемый массив типа торговых предложений с id = newValue
				self.f.s7.update({silent: true});

			});

		})();

	});

	//------------------------------------------//
	// X2. Вернуть ссылку self на объект-модель //
	//------------------------------------------//
	return self;


}};	// конец модели









