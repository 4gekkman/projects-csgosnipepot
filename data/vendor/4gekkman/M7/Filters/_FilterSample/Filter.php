<?php
////==========================================================////
////																													////
////              Фильтр для сервера изображений				      ////
////																													////
////==========================================================////
//// 			        		 	    	                         ////
//// 			    Подключение необходимых ресурсов  			 ////
//// 			         				                             ////
////===================================================////

  //---------------------------//
  // Пространство имён фильтра //
  //---------------------------//

    // TODO: заменить [имя фильтра] на настоящее имя фильтра
    //namespace M7\Filters\[имя фильтра]

  //---------------------------------//
  // Подключение необходимых классов //
  //---------------------------------//

    // Классы, поставляемые Laravel
    use Illuminate\Support\Facades\App,
        Illuminate\Support\Facades\Artisan,
        Illuminate\Support\Facades\Auth,
        Illuminate\Support\Facades\Blade,
        Illuminate\Support\Facades\Bus,
        Illuminate\Support\Facades\Cache,
        Illuminate\Support\Facades\Config,
        Illuminate\Support\Facades\Cookie,
        Illuminate\Support\Facades\Crypt,
        Illuminate\Support\Facades\DB,
        Illuminate\Database\Eloquent\Model,
        Illuminate\Support\Facades\Event,
        Illuminate\Support\Facades\File,
        Illuminate\Support\Facades\Hash,
        Illuminate\Support\Facades\Input,
        Illuminate\Foundation\Inspiring,
        Illuminate\Support\Facades\Lang,
        Illuminate\Support\Facades\Log,
        Illuminate\Support\Facades\Mail,
        Illuminate\Support\Facades\Password,
        Illuminate\Support\Facades\Queue,
        Illuminate\Support\Facades\Redirect,
        Illuminate\Support\Facades\Redis,
        Illuminate\Support\Facades\Request,
        Illuminate\Support\Facades\Response,
        Illuminate\Support\Facades\Route,
        Illuminate\Support\Facades\Schema,
        Illuminate\Support\Facades\Session,
        Illuminate\Support\Facades\Storage,
        Illuminate\Support\Facades\URL,
        Illuminate\Support\Facades\Validator,
        Illuminate\Support\Facades\View;

    // Прочие классы



////===================================================////
class Filter implements \Intervention\Image\Filters\FilterInterface
{

  //----------------------------//
  // А. Указать свойства класса //
  //----------------------------//

    // А1. Входящие данные //
    //---------------------//
    //private $data = 10;


  //-----------------------//
  // Б. Конструктор класса //
  //-----------------------//
  public function __construct(/* $data */)  // TODO: указать аргументы
  {

    // TODO: принять аргументы
    // $this->data = $data;

  }


  //-----------------//
  // В. Метод-фильтр //
  //-----------------//
  // - Он принимает $image, изменяет его, и возвращает.
  public function applyFilter(\Intervention\Image\Image $image)
  {

    // TODO: написать код фильтра


    // 1] Пример - сделать изображение черно-белым
    //$image->greyscale();


    // n] Вернуть изображение
    return $image;

  }



}

/*//=======================================////
//// 			        		 	    	             ////
//// 			    Справочная информация  			 ////
//// 			         				                 ////
////=======================================////
//// - Intervention Image API

--------------------------------------
Подоглавление:

  Создание и считывание изображений
  ---------------------------------

    # canvas        | создать новое изобр.-экз. II с width, height и color
    # make          | создать новое изобр.-экз. из указанного источника

  Изменение размеров изображений
  ------------------------------

    # resize        | изменить размер изобр. на [width]/[height]; можно сохр.соотн.сторон и не допустить увелич.веса
    # widen         | изменить размер изобр. пропорционально указанному width; можно не допустить увелич.веса
    # heighten      | изменить размер изобр. пропорционально указанному height; можно не допустить увелич.веса
    # fit           | crop (в соотв. с заданной пропорцией) + resize (с сохр.соотн.сторон)
    # resizeCanvas  | изменить размер границ изображения на указанный; можно указать якор.точку, откуда изменять
    # crop          | вырезать прямоугольник [width]/[height] из изображения, с позиции [x]/[y]
    # trim          | обрезает пустые участки по краям изображения

  Работа с цветом изображений
  ---------------------------

    # gamma         | коррекция гаммы изображения
    # brightness    | коррекция яркости изображения
    # contrast      | коррекция контраста изображения
    # colorize      | коррекция содержания RED, GREEN, BLUE цветов в изображении
    # greyscale     | сделать изображение черно-белым
    # invert        | инвертировать все цвета изображения
    # mask          | применить указанный source, как альфа-маску, к указанному изображению
    # flip          | зеркально отразить изображение (горизонтально/вертикально)
    # limitColors   | ограничить max число цветов в изображении (оно конвертируется)
    # pickColor     | считывает цвет из точки X изображения и возвращает в указанном формате

  Применение эффектов и фильтров
  ------------------------------

    # filter        | применить пользовательский фильтр к изображению
    # pixelate      | применить эффект пикселизации к изображению, с указанным размером пикселя
    # rotate        | повернуть изображение против часовй стрелки на угол angle; можно указать цвет для пустых мест, появившихся после поворота
    # orientate     | читает из exif-данных инфу об ориентации изображения, и корректирует её, чтобы отобразить его корректно
    # blur          | применить фильтр размытия по гауссу к изображению
    # sharpen       | увеличить резкость изображения
    # opacity       | установить непрозрачность изображения от 0% (прозрачное) до 100% (непрозрачное)

  Рисование
  ---------

    # text          | написать текст на изображении в указанном месте (текст и его параметры можно задавать)
    # pixel         | нарисовать 1 пиксель указанного цвета в указанном месте
    # line          | нарисовать линию из т.X в т.Y (цвет и ширину можно задать)
    # rectangle     | нарисовать прямоугольник по точкам ABCD (параметры границ и фона можно задать в колбэк-функции)
    # circle        | нарисовать круг с центром в точке X и радиусом R (параметры границ и фона можно задать в колбэк-функции)
    # ellipse       | нарисовать эллипс с центром в т.X и радиусами R1 и R2 (параметры границ и фона можно задать в колбэк-функции)
    # polygon       | рисует полигон по указанным точкам (параметры границ и фона можно задать в колбэк-функции)

  Вставка одного изображения в другое, водяной знак
  -------------------------------------------------

    # fill          | залить изображение указанным цветом, или другим изображением как плиткой (repeat)
    # insert        | поместить поверх изобр. другое (из указ.источн.), в указанном месте; м.б. использовано для создания водяных знаков (прозрачность поддерживаается)

  Извлечение информации
  ---------------------

    # width         | получить ширину изображения
    # height        | получить высоту изображения
    # mime          | получить MIME-тип изображения (если он установлен)
    # exif          | прочитать метаданные exif из изображения
    # filesize      | получить размер изображения в байтах, если оно получено из файла в файловой системе

  Возвращение изображения
  -----------------------

    # save          | сохранить изображение в файловую систему
    # encode        | закодировать изображение в указанный формат (jpeg по умолчанию), в указанном качестве (90 по умолчанию)
    # response      | encode + создать объект Illuminate\Http\Response и вложить в него закодированное изображение

  Прочее
  ------

    # backup        | сохранить в памяти текущ.сост.изобр. под именем [name] (откатить можно функцией reset)
    # reset         | вернуть файл к состоянию [name], сохранённому с помощью backup

    # cache         | [закэшировать]/[прочитать из кэша] указанное изображение

    # destroy       | высвободить память, связанную с изображением, до завершения php-скрипта
    # getCore       | получить изображение в формате используемого драйвера (GD или Imagick)
    # interlace     | вкл/выкл чересстрочную развертку изображения

--------------------------------------


Создание и считывание изображений
---------------------------------

  //----------------------------
  // # canvas
  //----------------------------
  // - создать новое изобр.-экз. II с width, height и color
  // - public Intervention\Image\ImageManager canvas(integer $width, integer $height, [mixed $bgcolor])
  //
  //    - $width    | ширина изображения в px
  //    - $height   | высота изображения в px
  //    - $bgcolor  | цвет фона изображения в любом поддерживаемом формате
  //

    - Создадим изображение 600x300 с фоном цвета '#eee'
        $img = Image::canvas(600, 300, '#eee');

    - Вернём это изображение клиенту:
        return $img->response();


  //----------------------------
  // # make
  //----------------------------
  // - создать новое изобр.-экз. из указанного источника

    - Из файла:
        $img = Image::make( URL::asset('armani_46.jpg') );

    - Из URL:
        $img = Image::make('http://bm.img.com.ua/nxs/img/prikol/images/large/7/1/159117_287309.jpg');

    - Вернуть клиенту:
        return $img->response();


Изменение размеров изображений
------------------------------

  //----------------------------
  // # resize
  //----------------------------
  // - изменить размер изобр. на [width]/[height]; можно сохр.соотн.сторон и не допустить увелич.веса
  // - public Intervention\Image\Image resize ( integer $width, integer $height, [Closure $callback] )
  //
  //   - $width     | новая ширина
  //   - $height    | новая высота
  //   - $callback  | анонимная функция, в которой наложить ограничения:
  //                  - aspectRatio() | сохранить соотношение сторон
  //                  - upsize()      | не дать увеличить размер файла по сравнению с первоначальным
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Изменим его размер на 300x200:
        $img->resize(300, 200);           // будет растянуто/сжато

    - Изменим только его ширину на 300:
        $img->resize(300, null);          // будет растянуто/сжато

    - Изменим только его высоту на 200:
        $img->resize(null, 200);          // будет растянуто/сжато

    - Изменим только его ширину на 300 и сохраним соотношение сторон:
        $img->resize(300, null, function($constraint){
          $constraint->aspectRatio();                     // НЕ будет растянуто/сжато
        });

    - Изменим только его высоту на 200 и сохраним соотношение сторон:
        $img->resize(null, 200, function($constraint){
          $constraint->aspectRatio();                     // НЕ будет растянуто/сжато
        });

    - Изменим только его высоту на 400 и предотвратим увеличение размера, и сохраним соотн.сторон:
        $img->resize(null, 400, function($constraint){
          $constraint->aspectRatio();                    // НЕ будет растянуто/сжато
          $constraint->upsize();                         // размер НЕ станет больше
        });

  //----------------------------
  // # widen
  //----------------------------
  // - изменить размер изобр. пропорционально указанному width; можно не допустить увелич.веса
  // - public Intervention\Image\Image widen ( integer $width, [Closure $callback] )
  //
  //   - $width     | новая ширина
  //   - $callback  | анонимная функция с ограничениями (доступно лишь 1: upsize())
  //
  // - По сути это resize, в котором можно менять только width, и соотн.сторон всегда сохраняется
  // - Аналог heighten, только для ширины.
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Установим ширину изображения равной 500px (высота автоматом изменится пропорционально):
        $img->widen(500);   // изначальные пропорции сохранены

    - Сделаем тоже самое, но установим ограничение - результат не должен по весу быть больше исходника:
        $img->widen(500, , function($constraint){
          $constraint->upsize();
        });

  //----------------------------
  // # heighten
  //----------------------------
  // - изменить размер изобр. пропорционально указанному height; можно не допустить увелич.веса
  // - public Intervention\Image\Image heighten ( integer $height, [Closure $callback] )
  //
  //   - $height    | новая высота
  //   - $callback  | анонимная функция с ограничениями (доступно лишь 1: upsize())
  //
  // - По сути это resize, в котором можно менять только height, и соотн.сторон всегда сохраняется
  // - Аналог widen, только для высоты.
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Установим высоту изображения равной 500px (высота автоматом изменится пропорционально):
        $img->heighten(500);   // изначальные пропорции сохранены

    - Сделаем тоже самое, но установим ограничение - результат не должен по весу быть больше исходника:
        $img->heighten(500, , function($constraint){
          $constraint->upsize();
        });


  //----------------------------
  // # fit
  //----------------------------
  // - crop (в соотв. с заданной пропорцией) + resize (с сохр.соотн.сторон)
  // - public Intervention\Image\Image fit( int $width, [ [int $height], [Closure $callback, [ string $position ]] ])
  //
  //   - $width     | ширина
  //   - $height    | высота
  //   - $callback  | анон.функция, позволяющая задать доп. параметры:
  //                  - upsize()    | предотвратить рост веса результата по сравнению с исходником
  //                  - position()  | позиция вырезаемого прямоугольника (доступные значения см. ниже)
  //
  // - Принцип работы:
  //   1) Вычисляет соотношение сторон R, как $width / $height
  //   2) Вычисляет размеры прямоугольника с R, наилучшим образом влезующего в изображение
  //      - Его размеры НЕ $width и $height!
  //      - Его размеры равны размерам изображения!
  //      - Но его соотношение сторон равно R.
  //   3) Вырезает этот прямоугольник из изображения в соотв. с position
  //      - По умолчанию центр прямоугольника в центре изображения.
  //      - Но в position можно задать иное положение прямоугольника.
  //      - Доступные значения: top-left, top, top-right, left, center (по умолч.), right, bottom-left, bottom, bottom-right
  //   4) Изменяет размеры вырезанного прямоугольника до $width и $height
  //      - Разумеется, соотношение сторон остаётся равным R.
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Вырежем прямоуг.MAX разм. с соотн.сторон 100x50, и изменим его размер на 100x50:
        $img->fit(100, 50);


  //----------------------------
  // # resizeCanvas
  //----------------------------
  // - изменить размер границ изображения на указанный; можно указать якор.точку, откуда изменять
  // - public Intervention\Image\Image resizeCanvas (int $width, int $height, [string $anchor, [boolean $relative, [mixed $bgcolor]]])
  //
  //   $width     | новая ширина холста в px
  //   $height    | новая высота холста в px
  //   $anchor    | определяет, с каких сторон будет обрезано/наращено изображение (варианты см.ниже)
  //   $relative  | включить ли "относительный режим", когда $width и $height будут добавлены к текущим размерам холста: true / false (по умолчанию)
  //   $bgcolor   | цвет фона наращенных пустых областей (если новые размеры больше старых)
  //
  // - Операция аналогична операции "изменить размер холста" в Photoshop.
  // - Если новые размеры меньше, изображение просто обрезается там, где задано настройками.
  // - А если больше, то туда добавляется пустое пространство с цветом фона $bgcolor
  // - Возможные значения $anchor: top-left, top, top-right, left, center (по умолч.), right, bottom-left, bottom, bottom-right
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Уменьшим размер холста до 100x100, изображение будет обрезано со всех сторон, к центру:
        $img->resizeCanvas(100, 100);
        $img->resizeCanvas(100, 100, 'center');

    - Нарастим холст с каждой стороны на 50px, пустые области закрасим серым:
        $img->resizeCanvas(100, 100, 'center', true, '#eee');

    - Обрежем холст с каждой стороны на 50px:
        $img->resizeCanvas(-100, -100, 'center', true);

    - Нарастим холст слева/справа на 50px, а снизу на 100px, пустые области закрасим серым:
        $img->resizeCanvas(100, 100, 'top', true, '#eee');

    - Обрежем холст слева/справа на 50px, а снизу на 100px:
        $img->resizeCanvas(-100, -100, 'top', true);


  //----------------------------
  // # crop
  //----------------------------
  // - вырезать прямоугольник [width]/[height] из изображения, с позиции [x]/[y]
  // - public Intervention\Image\Image crop(int $width, int $height, [int $x, int $y])
  //
  //   - $width   | ширина прямоугольника, который надо вырезать
  //   - $height  | высота прямоугольника, который надо вырезать
  //   - $x       | координата X лев.верх. угла вырезаемого прямоугольника
  //   - $y       | координата Y лев.верх. угла вырезаемого прямоугольника
  //
  // - По умолчанию, центр вырезаемого прямоугольника находится в центре изображения.
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Вырежем квардрат 100x100 по центру $img:
        $img->crop(100, 100);

    - Вырежем квардрат 100x100 с ЛВ углом в ЛВ угле изображения (0,0):
        $img->crop(100, 100, 0, 0);


  //----------------------------
  // # trim
  //----------------------------
  // - обрезает пустые участки по краям изображения
  // - public Intervention\Image\Image trim( [string $base, [array $away, [int $tolerance, [int $feather]]]] )
  //
  //   $base        | место для взятия образца цвета, который надо срезать по краям
  //                  - доступные значения: top-left (по умолч.), bottom-right, transparent
  //   $away        | с какой стороны надо срезать (по умолч. срезается со всех)
  //   $away          - доступные значения: top, left, bottom, right
  //   $tolerance   | чувствительность от 0 (по умолч.) до 100, чем больше, тем больше похожих цветов удаляет
  //   $feather     | оставить нетронутым область такой толщины в px вокруг изображения
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Нарастим границу цвета '#eee' 50px вокруг $img (для дальнейшего обрезания):
        $img->resizeCanvas(100, 100, 'center', true, '#eee');

    - Обрежем границу вокруг $img со всех сторон, цвет возьмём из ЛВ угла:
        $img->trim();

    - Обрежем границу вокруг $img со всех сторон, цвет возьмём из Пн угла:
        $img->trim('bottom-right');

    - Обрежем прозрачную границу вокруг $img со всех сторон, цвет возьмём из Пн угла:
        $img->resizeCanvas(100, 100, 'center', true, 'RGBA(0,0,0,0)');
        $img->trim('transparent');

    - Обрежем границу вокруг $img только слева, цвет возьмём из ЛВ угла:
        $img->trim('top-left', 'left');

    - Обрежем границу вокруг $img со всех сторон с 50% толерантностью и 10px нетронутой границы, цвет возьмём из ЛВ угла:
        $img->trim('top-left', null, 50, 10);


Работа с цветом изображений
--------------------

  //----------------------------
  // # gamma
  //----------------------------
  // - коррекция гаммы изображения
  // - public Intervention\Image\Image gamma( float $correction )
  //
  //   $correction    | во сколько раз изменить гамму (0 - полная чернота, 1 - текущее состояние, 2 - в 2 раза выше и т.д.)
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Изменим гамму до полной черноты:
        $img->gamma(0);

    - Увеличим гамму в 4 раза:
        $img->gamma(4);


  //----------------------------
  // # brightness [!почему-то не сработала]
  //----------------------------
  // - коррекция яркости изображения
  // - public Intervention\Image\Image brightness( integer $level )
  //
  //   $level   | уровень яркости (MIN: -100, NORM: 0, MAX: +100)
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Изменим яркость до -50:
        $img->brightness(-50);

    - Изменим яркость до +50:
        $img->brightness(50);


  //----------------------------
  // # contrast
  //----------------------------
  // - коррекция контраста изображения
  // - public Intervention\Image\Image contrast(integer $level)
  //
  //   $level   | уровень контраста (MIN: -100, NORM: 0, MAX: +100)
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Изменим контраст до -50:
        $img->contrast(-50);

    - Изменим контраст до +50:
        $img->contrast(50);


  //----------------------------
  // # colorize
  //----------------------------
  // - коррекция содержания RED, GREEN, BLUE цветов в изображении
  // - public Intervention\Image\Image colorize(integer $red, integer $green, integer $blue)
  //
  //   $red     | уровень красного (MIN: -100, NORM: 0, MAX: +100)
  //   $green   | уровень зелёного (MIN: -100, NORM: 0, MAX: +100)
  //   $blue    | уровень синего (MIN: -100, NORM: 0, MAX: +100)
  //
  // - Уровни цветов, как видно, нормализованы.
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Уберём красный, оставим зелёный без изменений, и прибавим синего:
        $img->colorize(-100, 0, 100);


  //----------------------------
  // # greyscale [!почему-то не сработала]
  //----------------------------
  // - сделать изображение черно-белым
  // - public Intervention\Image\Image greyscale()
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Сделаем изображение черно-белым:
        $img->greyscale();


  //----------------------------
  // # invert
  //----------------------------
  // - инвертировать все цвета изображения
  // - public Intervention\Image\Image invert()
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Инвертируем все цвета изображения:
        $img->invert();


  //----------------------------
  // # mask
  //----------------------------
  // - применить указанный source, как альфа-маску, к указанному изображению
  // - public Intervention\Image\Image mask( mixed $source, [bool $mask_with_alpha] )
  //
  //   $source            | источник изображения-маски (принимается любой разрешённый формат)
  //   $mask_with_alpha   | содержит ли маска альфа-канал (true/false)
  //
  // - Альфа-маска позволяет сделать эффект сведения изображения на нет.
  // - Допустим, как-будто изображение по краям сходит на нет.
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Создадим изображение из URL, которое будем испольозвать, как маску:
        $mask = Image::make('http://img0.liveinternet.ru/images/attach/c/2//66/154/66154940_0_4f676_7de0df89_L.png');

    - Применим $mask к $img, как альфа-маску:
        $img->mask($mask);

    - Применим $mask с альфа-каналом к $img:
        $img->mask($mask, true);


  //----------------------------
  // # flip
  //----------------------------
  // - зеркально отразить изображение (горизонтально/вертикально)
  // - public Intervention\Image\Image flip( [mixed $mode] )
  //
  //   $mode  | 'h' - горизонтально (по умолч.), 'v' - вертикально
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Отразим его горизонтально:
        $img->flip();

    - Отразим его вертикально:
        $img->flip('v');


  //----------------------------
  // # limitColors
  //----------------------------
  // - ограничить max число цветов в изображении (оно конвертируется)
  // - public Intervention\Image\Image limitColors( integer $count, [mixed $matte] )
  //
  //   $count   | null - truecolor, или число - MAX кол-во цветов в палитре
  //   $matte   | цвет, который будет применяться к прозрачным пикселам (по умолчанию отключено)
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Оставим изображению лишь 3 цвета:
        $img->limitColors(3);

    - Оставим изображению лишь 3 цвета, а к прозрачным пикселам применим серый цвет:
        $img->limitColors(3, '#eee');


  //----------------------------
  // # pickColor
  //----------------------------
  // - считывает цвет из точки X изображения и возвращает в указанном формате
  // - public Intervention\Image\Image pickColor( int $x, int $y, [string $format] )
  //
  //   $x       | x-коорд. точки, откуда брать цвет
  //   $y       | x-коорд. точки, откуда брать цвет
  //   $format  | в каком формате функция вернёт результат
  //              - array: array(255, 255, 255, 1)    (по умолч.)
  //              - rgb: rgb(255, 255, 255)
  //              - rgba: rgba(255, 255, 255, 0.5)
  //              - hex: #cccccc
  //              - int: 16776956
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Возьмём цвет в формате hex из ЛВ угла (0,0) изображения:
        $color = $img->pickColor(0, 0, 'hex');

    - Возьмём цвет в формате array из точки (100,100) изображения:
        $color = $img->pickColor(100, 100);


Применение эффектов и фильтров
------------------------------

  //----------------------------
  // # filter
  //----------------------------
  // - применить пользовательский фильтр к изображению
  // - public Intervention\Image\Image filter( Intervention\Image\Filters\FilterInterface $filter )
  //
  //   $filter  | фильтр, который надо применить к изображению
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Применим к нему DemoFilter:
        $img->filter(new DemoFilter(45));


  //----------------------------
  // # pixelate
  //----------------------------
  // - применить эффект пикселизации к изображению, с указанным размером пикселя
  // - public Intervention\Image\Image pixelate( integer $size )
  //
  //   $size  | размер пиксела
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Применим к нему pixelate с размером пиксела 3:
        $img->pixelate(3);


  //----------------------------
  // # rotate
  //----------------------------
  // - повернуть изображение против часовй стрелки на угол angle; можно указать цвет для пустых мест, появившихся после поворота
  // - public Intervention\Image\Image rotate( float $angle, [string $bgcolor] )
  //
  //   $angle     | угол, на который надо повернуть изображение
  //   $bgcolor   | цвет, которым закрасить пустые места, которые могут появиться при повороте
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Повернём изображение на 45° против ЧС
        $img->rotate(45);

    - Повернём изображение на 45° по ЧС
        $img->rotate(-45);

    - Повернём изображение на 45° по ЧС, пустые места закрасим серым:
        $img->rotate(-45, '#eee');


  //----------------------------
  // # orientate
  //----------------------------
  // - читает из exif-данных инфу об ориентации изображения, и корректирует её, чтобы отобразить его корректно
  // - public Intervention\Image\Image orientate()
  // - допустим, фото было сделано на смартфон в горизонтальной ориентации
  // - инфа об этом как раз и есть в exif
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Ориентируем его правильно, согласно данным из exif:
        $img->orientate();


  //----------------------------
  // # blur
  //----------------------------
  // - применить фильтр размытия по гауссу к изображению
  // - public Intervention\Image\Image blur( [integer $amount] )
  //
  //   $amount  | значение от 0 (не размыто) до 100 (max размытие)
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Слегка размоем его:
        $img->blur(2);

    - Сильно размоем его:
        $img->blur(60);


  //----------------------------
  // # sharpen
  //----------------------------
  // - увеличить резкость изображения
  // - public Intervention\Image\Image sharpen( [integer $amount] )
  //
  //   $amount  | значение от 0 (не размыто) до 100 (max размытие)
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');

    - Слегка наведём резкость на него:
        $img->sharpen(10);

    - Наведём на него резкость по-серьёзному:
        $img->sharpen(60);


  //----------------------------
  // # opacity
  //----------------------------
  // - установить непрозрачность изображения от 0% (прозрачное) до 100% (непрозрачное)
  // - public Intervention\Image\Image opacity( integer $transparency )
  //
  //   $transparency  | значение от 100 (непрозрачный) до 0 (прозрачный)
  //
  // *Примечание:
  //    - Чтобы эффект был заметен, надо кодировать в формате PNG.
  //

    - Создадим изображение из URL:
        $img = Image::make('http://www.ridus.ru/images/2014/11/17/248552/4d70ea01a9.gif');


    - Сделаем его полупрозрачным:
        $img->opacity(50);

    - Сделаем его непрозрачным:
        $img->opacity(0);

    - Сделаем его почти полностью прозрачным:
        $img->opacity(90);


    - Возвращаем клиенту в формате PNG!
        $img->response('png');


Рисование
---------

  //----------------------------
  // # text
  //----------------------------
  // - написать текст на изображении в указанном месте (текст и его параметры можно задавать)
  // - public Intervention\Image\Image text( string $text, [integer $x, [integer $y, [Closure $callback]]] )
  //
  //   - $text      | текст, который надо написать
  //   - $x         | координата x центра текста (== 0 по умолчанию)
  //   - $y         | координата y центра текста (== 0 по умолчанию)
  //   - $callback  | анонимная функция, позволяющая задать параметры текста
  //

    - Создадим изображение:
        $img = Image::canvas(600, 300, '#eee');

    - Напишем на нём "Сарай", и зададим параметры текста:

        $img->text('foo', 200, 100, function($font) {
            $font->file('resources/other/PT sans ttf/PTC55F.ttf');   | путь к ttf-шрифру или цифра от 1 до 5 (встроенные в GD шрифты, 1 по умолчанию)
            $font->size(70);                                         | размер шрифта в px
            $font->color('#000');                                    | цвет шрифта
            $font->align('center');                                  | гориз.выравнивание (center / right / left)
            $font->valign('top');                                    | вертик.выравнивание (tom / middle/ bottom)
            $font->angle(10);                                        | угол поворота против ч.с.
        });

    - Вернём клиенту:
        return $img->response();


  //----------------------------
  // # pixel
  //----------------------------
  // - нарисовать 1 пиксель указанного цвета в указанном месте
  // - public Intervention\Image\Image pixel( mixed $color, integer $x, integer $y )
  //
  //   $color   | цвет пиксела в любом принимаемом формате
  //   $x       | x-координата точки, где надо нарисовать пиксел
  //   $y       | y-координата точки, где надо нарисовать пиксел
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 300, '#000');

    - В его центре поставим белый пиксел:
        $img->pixel('#fff', 300, 150);


  //----------------------------
  // # line
  //----------------------------
  // - нарисовать линию из т.X в т.Y (цвет и ширину можно задать)
  // - public Intervention\Image\Image line( int $x1, int $y1, int $x2, int $y2, [Closure $callback] )
  //
  //   $x1        | x-координата точки №1, откуда нужно вести линию
  //   $y1        | y-координата точки №1, откуда нужно вести линию
  //   $x2        | x-координата точки №2, куда нужно вести линию
  //   $y2        | y-координата точки №2, куда нужно вести линию
  //   $callback  | анон.функ., где можно определить цвет и ширину линии
  //                - color(string $color)
  //                - width(integer $width)
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 300, '#000');

    - Проведём белую линию шириной 10px от ЛВ до ПН угла
        $img->line(0,0, 600,300, function($draw){
          $draw->color('#fff');
          $draw->width(10);
        });


  //----------------------------
  // # rectangle
  //----------------------------
  // - нарисовать прямоугольник по точкам ABCD (параметры границ и фона можно задать в колбэк-функции)
  // - public Intervention\Image\Image rectangle( int $x1, int $y1, int $x2, int $y2, [Closure $callback])
  //
  //   $x1        | x-координата ЛВ угла прямоугольника
  //   $y1        | y-координата ЛВ угла прямоугольника
  //   $x2        | x-координата ПН угла прямоугольника
  //   $y2        | y-координата ПН угла прямоугольника
  //   $callback  | анон.функ., где можно определить цвет и ширину линии
  //                - background(string $color)
  //                - border( integer $width, string $color )
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 300, '#000');

    - Нарисуем по центру белый квадрат с зелёной рамкой толщиной 10px:
        $img->rectangle(250,100, 350,200, function($draw){
          $draw->background('#fff');
          $draw->border(10, '#5f5');
        });


  //----------------------------
  // # circle
  //----------------------------
  // - нарисовать круг с центром в точке X и радиусом R (параметры границ и фона можно задать в колбэк-функции)
  // - public Intervention\Image\Image circle( integer $radius, integer $x, integer $y, [Closure $callback] )
  //
  //   $radius    | радиус круга
  //   $x         | x-координата центра круга
  //   $y         | y-координата центра круга
  //   $callback  | анон.функ., где можно определить цвет и ширину линии
  //                - background(string $color)
  //                - border( integer $width, string $color )
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 300, '#000');

    - Нарисуем в центре белый круг с радиусом 100px, и зелёной рамкой толщиной 10px:
        $img->circle(100, 300,150, function($draw){
          $draw->background('#fff');
          $draw->border(10, '#5f5');
        });

  //----------------------------
  // # ellipse
  //----------------------------
  // - нарисовать эллипс с центром в т.X и радиусами R1 и R2 (параметры границ и фона можно задать в колбэк-функции)
  // - public Intervention\Image\Image ellipse(int $width, int $height, int $x, int $y, [Closure $callback])
  //
  //   $width     | ширина эллипса (10 по умолчанию)
  //   $height    | высота эллипса (10 по умолчанию)
  //   $x         | x-координата центра эллипса
  //   $y         | y-координата центра эллипса
  //   $callback  | анон.функ., где можно определить цвет и ширину линии
  //                - background(string $color)
  //                - border( integer $width, string $color )
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 300, '#000');

    - Нарисуем в центре белый эллипс 200x100, и зелёной рамкой толщиной 10px:
        $img->ellipse(200,100, 300,150, function($draw){
          $draw->background('#fff');
          $draw->border(10, '#5f5');
        });


  //----------------------------
  // # polygon
  //----------------------------
  // - рисует полигон по указанным точкам (параметры границ и фона можно задать в колбэк-функции)
  // - public Intervention\Image\Image polygon(array $points, [Closure $callback])
  //
  //   $points    | 1d-массив точек полигона
  //   $callback  | анон.функ., где можно определить цвет и ширину линии
  //                - background(string $color)
  //                - border( integer $width, string $color )
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 300, '#000');

    - Подготовим массив координат точек для 6-конечного полигона:
        $points = array(
          200,100,
          300,50,
          400,100,
          400,200,
          300,250,
          200,200
        );

    - Нарисуем 6-конечный полигон с зелёной рамкой толщиной 10px:
        $img->polygon($points, function($draw){
          $draw->background('#fff');
          $draw->border(10, '#5f5');
        });


Вставка одного изображения в другое, водяной знак
-------------------------------------------------

  //----------------------------
  // # fill
  //----------------------------
  // - залить изображение указанным цветом, или другим изображением как плиткой (repeat)
  // - public Intervention\Image\ImageManager fill(mixed $filling, [integer $x, integer $y])
  //
  //   $filling   | цвет (в любом из допустимых форматов) или источник изображения (любой из допустимых)
  //   $x         | x-координата стартовой точки для заливки
  //   $y         | y-координата стартовой точки для заливки
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 300, '#000');

    - Зальём его полностью зелёным цветом:
        $img->fill('#5f5');

    - Зальём его полностью повторяющимся изображением из URL:
        $img->fill('http://www.diabetesmine.com/wp-content/uploads/2009/03/facebook-small-icon.png');


  //----------------------------
  // # insert
  //----------------------------
  // - поместить поверх изобр. другое (из указ.источн.), в указанном месте; м.б. использовано для создания водяных знаков (прозрачность поддерживаается)
  // - public Intervention\Image\Image insert(mixed $source, [string $position, [integer $x, integer $y]])
  //
  //   $source    | источник изображения
  //   $position  | где разместить: top-left (default), top, top-right, left, center, right, bottom-left, bottom, bottom-right
  //   $x         | сдвиг по оси x относительно $position
  //   $y         | сдвиг по оси y относительно $position
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 600, '#000');

    - Подготовим полупрозрачный водяной знак:
        $mark = Image::make('http://res.cloudinary.com/demo/image/upload/sample_watermark.png');

    - Поместим $mark справа-снизу в $img:
        $img->insert($mark, 'bottom-right');


Извлечение информации
---------------------

  //----------------------------
  // # width
  //----------------------------
  // - получить ширину изображения
  // - public Intervention\Image\Image width()
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 300, '#000');

    - Получим ширину изображения:
        $w = $img->width();       // 600


  //----------------------------
  // # height
  //----------------------------
  // - получить высоту изображения
  // - public Intervention\Image\Image height ()
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 300, '#000');

    - Получим высоту изображения:
        $w = $img->height();       // 300


  //----------------------------
  // # mime
  //----------------------------
  // - получить MIME-тип изображения (если он установлен)
  // - public Intervention\Image\Image mime()
  //

    - Получим изображение из URL:
        $img = Image::make('http://res.cloudinary.com/demo/image/upload/sample_watermark.png');

    - Получим его mime-тип:
        $mime = $img->mime();   // image/png


  //----------------------------
  // # exif
  //----------------------------
  // - прочитать метаданные exif из изображения
  // - public Intervention\Image\Image exif([string $key])
  //
  //   $key   | извлечь значение только св-ва с указанным ключём
  //

    - Получим изображение из URL:
        $img = Image::make('http://res.cloudinary.com/demo/image/upload/sample_watermark.png');

    - Извлечём данные exif изображения в массив:
        $exif = $img->exif();

    - Извлечём данные о модели камеры, которым снято изображение, в переменную:
        $name = $img->exif('Model');


  //----------------------------
  // # filesize [!почему-то не сработала]
  //----------------------------
  // - получить размер изображения в байтах, если оно получено из файла в файловой системе
  // - public Intervention\Image\Image filesize()
  //

    - Получим изображение из файла:
        $img = Image::make( URL::asset('armani_46.jpg') );

    - Узнаем размер этого изображения:
        $size = $img->filesize();


Возвращение изображения
-----------------------

  //----------------------------
  // # save
  //----------------------------
  // - сохранить изображение в файловую систему
  // - public Intervention\Image\Image save( [string $path, [int $quality]] )
  //
  //   $path      | куда сохранить
  //                - если $img создано из существующего файла, а $path не указан, то он будет перезаписан
  //   $quality   | в каком качестве сохранить, (от 0 до 100), 90 по умолчанию
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 300, '#000');

    - Закодируем его в PNG-формат с качеством 100
        $img->encode('png', 100);

    - Сохраним его, как 'blackhole.png' в файловую систему (папку public в Laravel), в качестве 90:
        $img->save('blackhole.png');

    - Сохраним его, как 'blackhole.png' в файловую систему (папку public в Laravel), в качестве 100:
        $img->save('blackhole.png', 100);


  //----------------------------
  // # encode
  //----------------------------
  // - закодировать изображение в указанный формат (jpeg по умолчанию), в указанном качестве (90 по умолчанию)
  // - public Intervention\Image\Image encode([mixed $format, [int $quality]])
  //
  //   $format    | jpg / png / gif / tif / bmp
  //                - По умолчанию изображение будет закодировано в типе текущего изображения
  //                - Если тип изображения ещё не определён, то в jpg
  //   $quality   | качество (от 0 до 100), 90 по умолчанию
  //
  // - encode() нужно применять, скажем, перед save()
  //

    - Пример см.выше


  //----------------------------
  // # response
  //----------------------------
  // - encode + создать объект Illuminate\Http\Response и вложить в него закодированное изображение
  // - public Intervention\Image\Image response( [string $format, [integer $quality]] )
  //
  //   $format    | jpg / png / gif / tif / bmp
  //                - По умолчанию изображение будет закодировано в типе текущего изображения
  //                - Если тип изображения ещё не определён, то в jpg
  //   $quality   | качество (от 0 до 100), 90 по умолчанию
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 300, '#000');

    - Вернём его клиенту:

      ● В качестве 90 в виде jpg-файла
          return $img->response();

      ● В качестве 50 в виде png-файла
          return $img->response('png', 50);


Прочее
------

  //----------------------------
  // # backup
  //----------------------------
  // - сохранить в памяти текущ.сост.изобр. под именем [name] (откатить можно функцией reset)
  // - public Intervention\Image\Image backup( [string $name] )
  //
  //   $name  | имя бэкапа состояния изображения в памяти
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 300, '#000');

    - Сохраним его состояние в памяти, как 'backup1':
        $img->backup('backup1');

    - Сделаем его полупрозрачным:
        $img->opacity(50);

    - Вернём его к состоянию 'backup1':
        $img->reset('backup1');


  //----------------------------
  // # reset
  //----------------------------
  // - вернуть файл к состоянию [name], сохранённому с помощью backup
  // - public Intervention\Image\Image reset( [string $name] )
  //
  //   $name  | имя бэкапа состояния, к которому надо вернуть изображение
  //

    - см. пример выше


  //----------------------------
  // # cache
  //----------------------------
  // - [закэшировать]/[прочитать из кэша] указанное изображение
  // - public Intervention\Image\ImageManager cache( Closure $callback, [int $lifetime, [bool $returnObj]] )
  //
  //   $callback    | анон.функ. с операциями над изображением, определяющими закэшированное изображение
  //   $lifetime    | время жизни кэша в минутах (5 по умолчанию)
  //   $returnObj   | что вернуть: экземпляр II (по умолч.) или поток изображения (стрку)
  //

    - Как только IICache установлен, становится доступен метод cache.
    - Через него и следует проводить все манипуляции с изображением.
    - Допустим, у нас есть изображение 'public/foo.jpg'.
    - И мы хотим получить его же, но в размере 300x200.
    - Получаем объект II в 1-й раз, через cache. Кэшируем на 10 минут.

        $img = Image::cache(function($image) {
           $image->make('public/foo.jpg')->resize(300, 200);
        }, 10, true);

    - Через в течение 10 минут оно снова нам понадобилось.
    - Делаем точно такой-же запрос.
    - Но в этот раз оно будет извлечено уже из кэша:

        $img = Image::cache(function($image) {
           $image->make('public/foo.jpg')->resize(300, 200);
        }, 10, true);


  //----------------------------
  // # destroy
  //----------------------------
  // - высвободить память, связанную с изображением, до завершения php-скрипта
  // - public Intervention\Image\Image destroy()
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 300, '#000');

    - Закодируем его в PNG-формат с качеством 100
        $img->encode('png', 100);

    - Сохраним его, как 'blackhole.png' в файловую систему (папку public в Laravel), в качестве 90:
        $img->save('blackhole.png');

    - Высвободим связанную с $img память:
        $img->destroy();


  //----------------------------
  // # getCore
  //----------------------------
  // - получить изображение в формате используемого драйвера (GD или Imagick)
  // - public Intervention\Image\Image getCore()
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 300, '#000');

    - Получим его в формате Imagick
        $imagick = $img->getCore();


  //----------------------------
  // # interlace
  //----------------------------
  // - вкл/выкл чересстрочную развертку изображения
  // - public Intervention\Image\Image interlace( [boolean $interlace] )
  //
  //   $interlace   | true (по умолч.) / false
  //

    - Создадим чёрное изображение:
        $img = Image::canvas(600, 300, '#000');

    - Включить чересстрочную развертку:
        $img->interlace();

    - Выключить чересстрочную развертку:
        $img->interlace(false);


////=======================================//*/







